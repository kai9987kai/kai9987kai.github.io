<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>EcoSim v4: The Ultimate Hybrid</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>

  <style>
    :root { --bg: #0b0d10; --panel: rgba(15, 19, 24, 0.9); --accent: #00d2ff; --text: #c0c5ce; }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: monospace; overflow: hidden; }
    canvas { position: absolute; top: 0; left: 0; }
    
    /* UI Overlay */
    .ui { position: absolute; pointer-events: none; width: 100%; height: 100%; z-index: 10; }
    .panel { pointer-events: auto; background: var(--panel); border: 1px solid rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; backdrop-filter: blur(4px); }
    
    #controls { top: 10px; left: 10px; width: 250px; position: absolute; }
    #stats { top: 10px; right: 10px; width: 220px; position: absolute; }
    #inspector { bottom: 10px; left: 10px; width: 260px; height: 200px; position: absolute; display: flex; flex-direction: column; }
    #env-readout { bottom: 10px; right: 10px; position: absolute; text-align: right; }
    
    h3 { margin: 0 0 5px 0; font-size: 12px; color: var(--accent); text-transform: uppercase; }
    .row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; }
    button { width: 100%; background: #222; color: var(--accent); border: 1px solid var(--accent); cursor: pointer; padding: 4px; margin-top: 5px; }
    button:hover { background: var(--accent); color: #000; }
    
    /* Layering */
    #pheroCanvas { z-index: 0; opacity: 0.5; }
    #mainCanvas { z-index: 1; }
  </style>
</head>
<body>

<canvas id="pheroCanvas"></canvas>
<canvas id="mainCanvas"></canvas>

<div class="ui">
  <!-- Controls -->
  <div id="controls" class="panel">
    <h3>EcoSim v4: Hybrid</h3>
    <div class="row"><label>Pop Limit</label><input type="number" id="popCap" value="120" style="width:50px"></div>
    <div class="row"><label>Sim Speed</label><input type="range" id="timeScale" min="1" max="10" value="1"></div>
    <div class="row"><label>Pheromones</label><input type="checkbox" id="showPhero" checked></div>
    <button onclick="resetSim()">RESET SIMULATION</button>
    <div style="font-size:10px; margin-top:8px; opacity:0.7;">
      Features: PBT Learning, Curiosity, Lidar Vision, Day/Night Cycle, Spatial Hash.
    </div>
  </div>

  <!-- Dashboard -->
  <div id="stats" class="panel">
    <div class="row"><span>Agents</span><span id="stCount">0</span></div>
    <div class="row" style="color:#4f4"><span>Herbivores</span><span id="stHerb">0</span></div>
    <div class="row" style="color:#f44"><span>Carnivores</span><span id="stCarn">0</span></div>
    <div class="row"><span>Avg Age</span><span id="stAge">0</span></div>
    <div class="row"><span>Best Policy</span><span id="stBest">ID: -</span></div>
    <canvas id="chart" height="80"></canvas>
  </div>

  <!-- Inspector -->
  <div id="inspector" class="panel" style="display:none">
    <h3>Neural Inspector</h3>
    <div class="row">ID: <span id="inspId"></span></div>
    <div class="row">State: <span id="inspState"></span></div>
    <div class="row">Curiosity: <span id="inspCuriosity">0</span></div>
    <canvas id="brainView" width="240" height="120" style="background:#000; border:1px solid #333; margin-top:auto"></canvas>
  </div>
  
  <!-- Environment Readout -->
  <div id="env-readout" class="panel">
    <div style="font-size:14px; font-weight:bold;" id="clock">12:00</div>
    <div style="font-size:11px;" id="weather">Sunny</div>
    <div style="font-size:11px;" id="temp">25°C</div>
  </div>
</div>

<script>
(async () => {
  /* ================= CONFIG & GLOBALS ================= */
  const CFG = {
    grid: 60,         // Spatial Hash Cell
    pGrid: 10,        // Pheromone Resolution
    fov: 140,         // Vision Range
    sectors: 8,       // Lidar Rays
    inputs: 36,       // 8*(Wall,Food,Enemy,Friend) + 4 Phero/State
    outputs: 2,       // Turn, Speed
    noveltyCell: 50   // Size of grid for curiosity tracking
  };

  const cvs = document.getElementById('mainCanvas');
  const ctx = cvs.getContext('2d', {alpha: false});
  const pCvs = document.getElementById('pheroCanvas');
  const pCtx = pCvs.getContext('2d');
  
  // Resizing
  const resize = () => {
    cvs.width = pCvs.width = window.innerWidth;
    cvs.height = pCvs.height = window.innerHeight;
    initGrids();
  };
  window.addEventListener('resize', resize);

  /* ================= HELPERS ================= */
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, m, M) => Math.max(m, Math.min(M, v));
  // Standard Normal Variate (Box-Muller)
  const randn = () => {
    let u=0,v=0; 
    while(u===0)u=Math.random(); while(v===0)v=Math.random();
    return Math.sqrt(-2.0*Math.log(u))*Math.cos(2.0*Math.PI*v);
  };

  /* ================= SPATIAL HASH (Optimization) ================= */
  class SpatialHash {
    constructor(size) { this.size = size; this.map = new Map(); }
    clear() { this.map.clear(); }
    key(x, y) { return (Math.floor(x/this.size)) + ',' + (Math.floor(y/this.size)); }
    add(agent) {
      const k = this.key(agent.x, agent.y);
      if(!this.map.has(k)) this.map.set(k, []);
      this.map.get(k).push(agent);
    }
    query(x, y) {
      const cx = Math.floor(x/this.size), cy = Math.floor(y/this.size);
      let res = [];
      for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
        const k = (cx+i)+','+(cy+j);
        if(this.map.has(k)) res.push(...this.map.get(k));
      }
      return res;
    }
  }
  const spatial = new SpatialHash(CFG.grid);

  /* ================= PHEROMONES & CURIOSITY GRIDS ================= */
  let pData, pW, pH;
  let visitMap = new Map(); // For Curiosity (Novelty Search)

  function initGrids() {
    pW = Math.ceil(cvs.width / CFG.pGrid);
    pH = Math.ceil(cvs.height / CFG.pGrid);
    pData = new Float32Array(pW * pH * 2); // [FoodScent, DangerScent]
    visitMap.clear();
  }
  resize();

  function updatePhero() {
    // Decay
    for(let i=0; i<pData.length; i++) pData[i] *= 0.97; 
    
    // Render
    if (!document.getElementById('showPhero').checked) {
       pCtx.clearRect(0,0,pCvs.width,pCvs.height); return;
    }
    
    const img = pCtx.createImageData(pW, pH);
    for(let i=0; i<pW*pH; i++) {
      const f = pData[i*2], d = pData[i*2+1];
      if(f>0.1 || d>0.1) {
        const idx = i*4;
        img.data[idx] = Math.min(255, d*200);   // R (Danger)
        img.data[idx+1] = Math.min(255, f*200); // G (Food)
        img.data[idx+2] = Math.min(255, (f+d)*50); // B
        img.data[idx+3] = Math.min(120, (f+d)*100); // Alpha
      }
    }
    // Draw scaled
    const tC = document.createElement('canvas'); tC.width=pW; tC.height=pH;
    tC.getContext('2d').putImageData(img,0,0);
    pCtx.clearRect(0,0,pCvs.width,pCvs.height);
    pCtx.drawImage(tC, 0, 0, pCvs.width, pCvs.height);
  }

  function addScent(x, y, type, val) {
    const gx=Math.floor(x/CFG.pGrid), gy=Math.floor(y/CFG.pGrid);
    if(gx>=0 && gx<pW && gy>=0 && gy<pH) {
      const i = (gy*pW + gx)*2 + type;
      pData[i] = Math.min(10, pData[i] + val);
    }
  }

  /* ================= PBT (POPULATION BASED TRAINING) ================= */
  // We keep a "Policy Bank" of the best weights. New agents borrow from this bank.
  const POLICY_BANK_SIZE = 5;
  let policyBank = []; // Array of {weights: Tensor[], score: num}

  function addToBank(brain, score) {
    if (policyBank.length < POLICY_BANK_SIZE) {
       policyBank.push({weights: brain.getWeights().map(w=>w.clone()), score});
    } else {
       // Replace worst if better
       policyBank.sort((a,b) => a.score - b.score);
       if (score > policyBank[0].score) {
          policyBank[0].weights.forEach(w=>w.dispose());
          policyBank[0] = {weights: brain.getWeights().map(w=>w.clone()), score};
       }
    }
  }

  /* ================= AGENT ================= */
  class Agent {
    constructor(x, y, type, brainWeights = null) {
      this.id = Math.random().toString(36).substr(2,5);
      this.x = x; this.y = y;
      this.type = type; // 0=Herb, 1=Carn
      this.angle = rand(0, Math.PI*2);
      this.vx = 0; this.vy = 0;
      
      // Stats
      this.energy = 100;
      this.health = 100;
      this.age = 0;
      this.curiosityScore = 0;
      
      // Genome (Morphology)
      this.genes = {
        speed: rand(0.5, 1.2),
        size: rand(0.5, 1.2),
        aggr: type===1 ? rand(0.5,1) : rand(0,0.3),
        color: type===0 ? {h:110,s:80} : {h:0,s:90}
      };
      
      this.radius = 5 + this.genes.size*5;
      
      // Brain
      this.brain = tf.sequential();
      this.brain.add(tf.layers.dense({units: 16, inputShape:[CFG.inputs], activation:'relu'}));
      this.brain.add(tf.layers.dense({units: 16, activation:'relu'}));
      this.brain.add(tf.layers.dense({units: CFG.outputs, activation:'tanh'})); // Turn, Speed
      
      if (brainWeights) {
        // Inherit
        const mutated = brainWeights.map(w => {
           return tf.tidy(() => w.add(tf.randomNormal(w.shape, 0, 0.05)));
        });
        this.brain.setWeights(mutated);
        mutated.forEach(t=>t.dispose());
      } else if (policyBank.length > 0 && Math.random() < 0.7) {
        // PBT: Borrow from best
        const donor = policyBank[Math.floor(Math.random()*policyBank.length)];
        const copy = donor.weights.map(w=>w.clone());
        // Slight mutation
        const mutated = copy.map(w => {
           const res = tf.tidy(() => w.add(tf.randomNormal(w.shape, 0, 0.02)));
           w.dispose(); return res;
        });
        this.brain.setWeights(mutated);
        mutated.forEach(t=>t.dispose());
      }
    }

    async think(envData) {
      // 1. SENSORS (Lidar)
      // 8 Rays. Each returns [Wall, Food, Danger, Friend]
      const sensors = new Float32Array(CFG.inputs);
      const angleStep = (Math.PI*2)/CFG.sectors;
      
      // Apply Environment (Night reduces vision)
      const currentVision = CFG.fov * envData.lightLevel * (this.genes.size > 0.8 ? 1.2 : 1.0);
      
      // Raycast logic
      const nearby = spatial.query(this.x, this.y);
      
      for(let i=0; i<CFG.sectors; i++) {
        const th = this.angle + i*angleStep;
        const dx = Math.cos(th), dy = Math.sin(th);
        
        let wallDist = 1.0;
        // Wall check (simple box)
        if(dx>0) wallDist = Math.min(wallDist, (cvs.width-this.x)/(dx*currentVision));
        else if(dx<0) wallDist = Math.min(wallDist, (0-this.x)/(dx*currentVision));
        if(dy>0) wallDist = Math.min(wallDist, (cvs.height-this.y)/(dy*currentVision));
        else if(dy<0) wallDist = Math.min(wallDist, (0-this.y)/(dy*currentVision));
        
        sensors[i*4] = 1 - clamp(Math.abs(wallDist), 0, 1);
        
        // Entity Check
        let fDist=0, dDist=0, frDist=0;
        
        for(let e of nearby) {
          if(e === this || !e.alive) continue;
          const ex = e.x-this.x, ey = e.y-this.y;
          const d2 = ex*ex + ey*ey;
          if(d2 > currentVision*currentVision) continue;
          
          // Angle check (is it in this sector?)
          let angTo = Math.atan2(ey, ex) - this.angle;
          while(angTo < 0) angTo += Math.PI*2;
          while(angTo >= Math.PI*2) angTo -= Math.PI*2;
          
          // Rough sector check
          const secIdx = Math.floor(angTo/angleStep) % CFG.sectors;
          if (secIdx !== i) continue;
          
          const val = 1 - (Math.sqrt(d2)/currentVision);
          
          if(this.type === 0) { // Herbivore
             if(e.type===1) dDist = Math.max(dDist, val);
             else frDist = Math.max(frDist, val);
          } else { // Carnivore
             if(e.type===0) fDist = Math.max(fDist, val);
             else frDist = Math.max(frDist, val);
          }
        }
        
        // Food items (Global list, optimized if grid implemented for items, iterating all for simplicity here < 100 items)
        if (this.type===0) {
           for(let f of foods) {
              const fx = f.x-this.x, fy = f.y-this.y;
              if (fx*fx+fy*fy < currentVision*currentVision) {
                 let angTo = Math.atan2(fy, fx) - this.angle;
                 while(angTo < 0) angTo += Math.PI*2;
                 while(angTo >= Math.PI*2) angTo -= Math.PI*2;
                 if ((Math.floor(angTo/angleStep)%CFG.sectors) === i) {
                    fDist = Math.max(fDist, 1 - Math.sqrt(fx*fx+fy*fy)/currentVision);
                 }
              }
           }
        }
        
        sensors[i*4 + 1] = fDist;
        sensors[i*4 + 2] = dDist;
        sensors[i*4 + 3] = frDist;
      }
      
      // Pheromones (Smell)
      const gx=Math.floor(this.x/CFG.pGrid), gy=Math.floor(this.y/CFG.pGrid);
      let smF=0, smD=0;
      if(gx>=0 && gx<pW && gy>=0 && gy<pH) {
        const idx = (gy*pW+gx)*2;
        smF = pData[idx]; smD = pData[idx+1];
      }
      sensors[32] = clamp(smF/5,0,1);
      sensors[33] = clamp(smD/5,0,1);
      sensors[34] = this.energy/100;
      sensors[35] = Math.sin(envData.time);

      // 2. INFERENCE
      const output = tf.tidy(() => {
         return this.brain.predict(tf.tensor2d([sensors]));
      });
      const data = await output.data();
      output.dispose();
      
      return { turn: data[0], speed: data[1], sensors };
    }

    applyPhysics(turn, speed, env) {
      this.angle += turn * 0.4;
      const baseSpd = (this.genes.speed * 2.5) * env.tempMod;
      const fwd = clamp(speed, 0, 1) * baseSpd;
      
      this.vx = Math.cos(this.angle)*fwd;
      this.vy = Math.sin(this.angle)*fwd;
      
      this.x += this.vx; this.y += this.vy;
      
      // Bounce
      if(this.x<0||this.x>cvs.width) { this.x=clamp(this.x,0,cvs.width); this.angle = Math.PI - this.angle; }
      if(this.y<0||this.y>cvs.height) { this.y=clamp(this.y,0,cvs.height); this.angle = -this.angle; }
      
      // Curiosity Reward (Novelty)
      const ck = Math.floor(this.x/CFG.noveltyCell)+','+Math.floor(this.y/CFG.noveltyCell);
      if (!visitMap.has(ck)) visitMap.set(ck, 0);
      const visits = visitMap.get(ck);
      if (visits < 5) {
         this.curiosityScore += 1;
         this.energy += 0.5; // Small energy boost for exploration
         visitMap.set(ck, visits+1);
      }
    }
  }

  /* ================= SIMULATION LOOP ================= */
  let agents = [], foods = [];
  let frame = 0, timeOfDay = 0; // 0..24
  let selectedId = null;
  let chart;

  function initSim() {
    agents.forEach(a=>a.brain.dispose());
    agents = []; foods = [];
    policyBank.forEach(p=>p.weights.forEach(w=>w.dispose()));
    policyBank = [];
    initGrids();
    
    // Initial Spawn
    for(let i=0; i<40; i++) agents.push(new Agent(rand(50,cvs.width-50), rand(50,cvs.height-50), Math.random()>0.8?1:0));
    for(let i=0; i<80; i++) foods.push({x:rand(0,cvs.width), y:rand(0,cvs.height)});
    
    // Chart
    if(chart) chart.destroy();
    chart = new Chart(document.getElementById('chart'), {
      type:'line', data:{labels:[], datasets:[{label:'Pop', data:[], borderColor:'#00d2ff', tension:0.1, pointRadius:0}]},
      options:{plugins:{legend:{display:false}}, scales:{x:{display:false}, y:{display:false}}, animation:false}
    });
  }

  async function step() {
    // Environment Cycle
    timeOfDay = (timeOfDay + 0.05) % 24;
    const isNight = timeOfDay > 20 || timeOfDay < 5;
    const lightLevel = isNight ? 0.4 : 1.0;
    const temp = 20 + Math.sin((timeOfDay-6)/24 * Math.PI*2) * 15; // 5C to 35C
    const tempMod = temp > 15 ? 1.0 : 0.7; // Cold slows down
    
    // Update UI Env
    const min = Math.floor((timeOfDay%1)*60).toString().padStart(2,'0');
    document.getElementById('clock').innerText = Math.floor(timeOfDay).toString().padStart(2,'0') + ":" + min;
    document.getElementById('weather').innerText = isNight ? "Night" : "Day";
    document.getElementById('temp').innerText = temp.toFixed(1) + "°C";

    // Spatial Rebuild
    spatial.clear();
    agents.forEach(a => { if(a.energy>0) spatial.add(a); });

    // Agent Logic
    for (const a of agents) {
      if (a.energy <= 0) continue;
      
      // Decay
      a.energy -= 0.2 + (a.genes.speed*0.1); 
      a.age++;

      // Think
      const decision = await a.think({lightLevel, tempMod, time: timeOfDay});
      a.applyPhysics(decision.turn, decision.speed, {tempMod});
      
      // Visualize Inspector
      if (a.id === selectedId) drawInspector(a, decision);

      // Interactions (Spatial)
      const near = spatial.query(a.x, a.y);
      
      // Eating / Fighting
      if (a.type === 0) { // Herbivore
         for(let i=foods.length-1; i>=0; i--) {
           const f = foods[i];
           if ((a.x-f.x)**2 + (a.y-f.y)**2 < (a.radius+5)**2) {
             a.energy = Math.min(100, a.energy+30);
             foods.splice(i,1);
             addScent(a.x, a.y, 0, 2.0); // Food Scent
           }
         }
      } else { // Carnivore
         for(const n of near) {
           if(n !== a && n.type === 0 && n.energy>0) {
             if ((a.x-n.x)**2 + (a.y-n.y)**2 < (a.radius+n.radius)**2) {
                // Fight
                n.health -= 20 * (1+a.genes.aggr);
                a.energy += 10;
                addScent(a.x, a.y, 1, 3.0); // Danger Scent
                if (n.health <= 0) {
                   n.energy = 0; // Kill
                   a.energy += 60;
                   addToBank(a.brain, a.age + a.curiosityScore); // Save killer instinct
                }
             }
           }
         }
      }
      
      // Reproduction (PBT)
      const popCap = parseInt(document.getElementById('popCap').value);
      if (a.energy > 90 && agents.length < popCap && Math.random() < 0.05) {
         a.energy -= 40;
         const child = new Agent(a.x, a.y, a.type, a.brain.getWeights());
         // Morphology Mutation
         child.genes.speed = clamp(a.genes.speed + randn()*0.1, 0.2, 1.5);
         child.genes.aggr = clamp(a.genes.aggr + randn()*0.1, 0, 1);
         child.genes.size = clamp(a.genes.size + randn()*0.1, 0.3, 1.5);
         agents.push(child);
         
         // If old enough, save policy to bank
         if (a.age > 500) addToBank(a.brain, a.age + a.curiosityScore);
      }
    }
    
    // Cleanup
    agents = agents.filter(a => {
       if (a.energy <= 0) { a.brain.dispose(); return false; }
       return true;
    });
    
    // Food Respawn
    if (foods.length < 80 && Math.random()<0.1) foods.push({x:rand(0,cvs.width), y:rand(0,cvs.height)});

    // Render
    draw();
    updatePhero();
    
    frame++;
    if(frame%60===0) updateStats();
  }

  function draw() {
    ctx.clearRect(0,0,cvs.width,cvs.height);
    
    // Food
    ctx.fillStyle = '#6f6';
    for(const f of foods) { ctx.beginPath(); ctx.arc(f.x,f.y,3,0,7); ctx.fill(); }
    
    // Agents
    for(const a of agents) {
      ctx.save();
      ctx.translate(a.x, a.y);
      ctx.rotate(a.angle);
      
      // Selection Glow
      if(a.id === selectedId) {
        ctx.shadowBlur=20; ctx.shadowColor='#fff';
        ctx.strokeStyle='rgba(255,255,255,0.5)';
        ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(0,0,CFG.fov, -0.5, 0.5); ctx.stroke(); // Cone
      }
      
      // Body
      const c = a.genes.color;
      ctx.fillStyle = `hsl(${c.h}, ${c.s}%, 50%)`;
      ctx.beginPath();
      
      // Morphology Draw
      if (a.genes.aggr > 0.6) { // Spikes
         for(let i=0; i<5; i++) {
           const ang = (Math.PI*2*i)/5;
           ctx.lineTo(Math.cos(ang)*(a.radius+4), Math.sin(ang)*(a.radius+4));
         }
      } else {
         ctx.arc(0,0, a.radius, 0, 7);
      }
      ctx.fill();
      
      // Tail (Speed)
      if (a.genes.speed > 0.8) {
         ctx.beginPath(); ctx.moveTo(-a.radius,0); ctx.lineTo(-a.radius-10, 0); 
         ctx.strokeStyle=ctx.fillStyle; ctx.lineWidth=3; ctx.stroke();
      }

      ctx.restore();
    }
  }

  function drawInspector(agent, dec) {
    const bCv = document.getElementById('brainView');
    const bCtx = bCv.getContext('2d');
    bCtx.clearRect(0,0,240,120);
    
    document.getElementById('inspector').style.display='flex';
    document.getElementById('inspId').innerText = `${agent.id} (${agent.type===0?'Herb':'Carn'})`;
    document.getElementById('inspState').innerText = `E:${agent.energy.toFixed(0)} H:${agent.health.toFixed(0)}`;
    document.getElementById('inspCuriosity').innerText = agent.curiosityScore;
    
    // Draw Inputs (Lidar)
    const cx=50, cy=60, r=30;
    bCtx.strokeStyle='#444'; bCtx.beginPath(); bCtx.arc(cx,cy,r,0,7); bCtx.stroke();
    
    const sens = dec.sensors;
    const arc = (Math.PI*2)/CFG.sectors;
    
    for(let i=0; i<CFG.sectors; i++) {
       const wall = sens[i*4], food = sens[i*4+1], dang = sens[i*4+2];
       if (Math.max(wall,food,dang) > 0.1) {
          bCtx.beginPath();
          bCtx.moveTo(cx,cy);
          bCtx.arc(cx,cy, r, i*arc, (i+1)*arc);
          if (dang>food) bCtx.fillStyle = `rgba(255,0,0,${dang})`;
          else if (food>wall) bCtx.fillStyle = `rgba(0,255,0,${food})`;
          else bCtx.fillStyle = `rgba(255,255,255,${wall})`;
          bCtx.fill();
       }
    }
    
    // Bars
    bCtx.fillStyle='#fff'; bCtx.fillText("Turn", 120, 40);
    bCtx.fillStyle='#333'; bCtx.fillRect(160, 30, 60, 10);
    bCtx.fillStyle='#0ff'; bCtx.fillRect(190, 30, dec.turn*30, 10);

    bCtx.fillStyle='#fff'; bCtx.fillText("Speed", 120, 60);
    bCtx.fillStyle='#333'; bCtx.fillRect(160, 50, 60, 10);
    bCtx.fillStyle='#0f0'; bCtx.fillRect(160, 50, clamp(dec.speed,0,1)*60, 10);
  }

  function updateStats() {
    document.getElementById('stCount').innerText = agents.length;
    document.getElementById('stHerb').innerText = agents.filter(a=>a.type===0).length;
    document.getElementById('stCarn').innerText = agents.filter(a=>a.type===1).length;
    const avgAge = agents.reduce((a,b)=>a+b.age,0)/ (agents.length||1);
    document.getElementById('stAge').innerText = avgAge.toFixed(0);
    document.getElementById('stBest').innerText = policyBank.length + " saved";
    
    chart.data.labels.push(frame);
    chart.data.datasets[0].data.push(agents.length);
    if(chart.data.labels.length>50) { chart.data.labels.shift(); chart.data.datasets[0].data.shift(); }
    chart.update();
  }

  cvs.addEventListener('mousedown', e => {
     const r = cvs.getBoundingClientRect();
     const x = e.clientX-r.left, y=e.clientY-r.top;
     let hit = false;
     for(let a of agents) {
        if ((a.x-x)**2+(a.y-y)**2 < 400) { selectedId=a.id; hit=true; break; }
     }
     if(!hit) { selectedId=null; document.getElementById('inspector').style.display='none'; }
  });

  window.resetSim = initSim;

  // Boot
  await tf.ready();
  initSim();
  
  const loop = () => {
     const times = parseInt(document.getElementById('timeScale').value);
     for(let i=0; i<times; i++) step();
     requestAnimationFrame(loop);
  };
  loop();

})();
</script>
</body>
</html>
