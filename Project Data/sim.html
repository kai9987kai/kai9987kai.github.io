<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROJECT 1X4G Super Brain Simulation</title>
    <style>
        body {
            font-family: 'Courier New', monospace; /* Cyberpunk font */
            background-color: #0a0a12; /* Deep dark background */
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
        /* CRT Scanline Effect */
        body::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 3;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #0ff; /* Cyan accent */
            padding-bottom: 10px;
            text-shadow: 0 0 10px #0ff;
        }
        .simulation-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .panel {
            background-color: #11111a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            margin-bottom: 20px;
        }
        .visualization {
            flex: 2;
            min-width: 300px;
        }
        .controls {
            flex: 1;
            min-width: 250px;
        }
        canvas {
            width: 100%;
            background-color: #050505;
            border: 1px solid #222;
            border-radius: 4px;
        }
        h1, h2, h3 {
            color: #0ff; /* Cyan */
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        h3 {
            color: #ff0055; /* Pink/Red accent for subheaders */
            font-size: 0.9em;
        }
        button {
            background-color: #1a1a2e;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 8px 16px;
            border-radius: 2px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
            text-transform: uppercase;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        button:hover {
            background-color: #0ff;
            color: #000;
            box-shadow: 0 0 10px #0ff;
        }
        button.danger {
            color: #ff0055;
            border-color: #ff0055;
        }
        button.danger:hover {
            background-color: #ff0055;
            color: #000;
            box-shadow: 0 0 10px #ff0055;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
        }
        input[type="range"] {
            width: 100%;
            accent-color: #0ff;
        }
        .component {
            margin: 15px 0;
            border-top: 1px solid #222;
            padding-top: 15px;
        }
        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stat-box {
            background-color: #1a1a2e;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 2px;
            min-width: 100px;
            text-align: center;
        }
        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: #0f0; /* Green for values */
            text-shadow: 0 0 5px #0f0;
        }
        .stat-box.alert .value {
            color: #ff0055;
            text-shadow: 0 0 5px #ff0055;
        }
        .logs {
            height: 150px;
            overflow-y: auto;
            background-color: #000;
            padding: 10px;
            border: 1px solid #333;
            font-family: 'Courier New', monospace;
            margin-top: 10px;
            color: #0f0;
        }
        .log-entry {
            margin: 2px 0;
            font-size: 0.8em;
        }
        .info-tooltip {
            display: inline-block;
            margin-left: 5px;
            background-color: #333;
            color: #fff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            text-align: center;
            font-size: 12px;
            cursor: help;
            position: relative;
        }
        .tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        .tab {
            padding: 8px 16px;
            background-color: transparent;
            cursor: pointer;
            border: 1px solid transparent;
            margin-right: 2px;
            color: #666;
        }
        .tab.active {
            color: #0ff;
            border-bottom: 2px solid #0ff;
            background-color: rgba(0, 255, 255, 0.05);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        /* Pulse Animation for Bio */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 85, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); }
        }
        .bio-pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PROJECT 1X4G: Hybrid Super Brain Simulation</h1>
            <p>Neural-Quantum-Biological System with Genetic Modification</p>
        </div>
        
        <div class="simulation-container">
            <div class="panel visualization">
                <h2>Simulation Visualization</h2>
                <div class="tabs">
                    <div class="tab active" data-tab="grn">Gene Regulatory Network</div>
                    <div class="tab" data-tab="neurons">Neural Activity</div>
                    <div class="tab" data-tab="learning">Learning Progress</div>
                </div>
                <div class="tab-content active" id="grn-tab">
                    <canvas id="grn-canvas" height="300"></canvas>
                    <div class="component">
                        <h3>GRN State Visualization</h3>
                        <div id="grn-state-display"></div>
                    </div>
                </div>
                <div class="tab-content" id="neurons-tab">
                    <canvas id="neurons-canvas" height="300"></canvas>
                    <div class="component">
                        <h3>Neural Activity Monitor</h3>
                        <canvas id="spike-monitor" height="150"></canvas>
                    </div>
                </div>
                <div class="tab-content" id="learning-tab">
                    <canvas id="learning-canvas" height="300"></canvas>
                    <div class="component">
                        <h3>Reward History</h3>
                        <canvas id="reward-chart" height="150"></canvas>
                    </div>
                </div>
                
                <div class="component">
                    <h3>Consciousness Monitor (IIT Phi)</h3>
                    <canvas id="phi-monitor" height="100"></canvas>
                    <div class="stats">
                        <div class="stat-box">
                            <div>Phi (Φ)</div>
                            <div class="value" id="phi-value">0.00</div>
                        </div>
                        <div class="stat-box">
                            <div>State</div>
                            <div class="value" id="consciousness-state">Unconscious</div>
                        </div>
                    </div>
                </div>
                
                <div class="component">
                    <h3>System Statistics</h3>
                    <div class="stats">
                        <div class="stat-box">
                            <div>Episode</div>
                            <div class="value" id="episode-count">0</div>
                        </div>
                        <div class="stat-box">
                            <div>Age (Steps)</div>
                            <div class="value" id="age-value">0</div>
                        </div>
                        <div class="stat-box">
                            <div>Current Reward</div>
                            <div class="value" id="current-reward">0.00</div>
                        </div>
                        <div class="stat-box">
                            <div>Avg Reward</div>
                            <div class="value" id="avg-reward">0.00</div>
                        </div>
                        <div class="stat-box">
                            <div>Error</div>
                            <div class="value" id="error-value">0.00</div>
                        </div>
                        <div class="stat-box" id="fatigue-box">
                            <div>Fatigue</div>
                            <div class="value" id="fatigue-value">0%</div>
                        </div>
                    </div>
                </div>
                
                <div class="component">
                    <h3>System Logs</h3>
                    <div class="logs" id="log-container"></div>
                </div>
            </div>
            
            <div class="panel controls">
                <h2>Simulation Controls</h2>
                <div class="component">
                    <button id="start-btn">Start Simulation</button>
                    <button id="pause-btn">Pause</button>
                    <button id="reset-btn">Reset</button>
                    <button id="sleep-btn" style="border-color: #bd93f9; color: #bd93f9;">Enter Dream Mode</button>
                </div>
                
                <div class="component">
                    <h3>Environment Parameters</h3>
                    <div class="slider-container">
                        <label for="num-genes">Number of Genes: <span id="num-genes-value">10</span>
                            <span class="info-tooltip" data-tooltip="Number of genes in the Gene Regulatory Network.">?</span>
                        </label>
                        <input type="range" id="num-genes" min="5" max="20" value="10">
                    </div>
                    <div class="slider-container">
                        <label for="interaction-strength">Gene Interaction Strength: <span id="interaction-strength-value">0.5</span>
                            <span class="info-tooltip" data-tooltip="Controls the strength of gene-to-gene interactions.">?</span>
                        </label>
                        <input type="range" id="interaction-strength" min="0.1" max="1.0" step="0.1" value="0.5">
                    </div>
                    <div class="slider-container">
                        <label for="env-noise">Environment Noise: <span id="env-noise-value">0.1</span>
                            <span class="info-tooltip" data-tooltip="Amount of random noise added to gene expression levels.">?</span>
                        </label>
                        <input type="range" id="env-noise" min="0" max="0.5" step="0.05" value="0.1">
                    </div>
                </div>
                
                <div class="component">
                    <h3>Neural System Parameters</h3>
                    <div class="slider-container">
                        <label for="bio-neurons">Biological Neurons: <span id="bio-neurons-value">100</span>
                            <span class="info-tooltip" data-tooltip="Number of simulated biological neurons.">?</span>
                        </label>
                        <input type="range" id="bio-neurons" min="50" max="200" step="10" value="100">
                    </div>
                    <div class="slider-container">
                        <label for="snn-neurons">Neuromorphic Neurons: <span id="snn-neurons-value">1000</span>
                            <span class="info-tooltip" data-tooltip="Number of neurons in the simulated neuromorphic chip.">?</span>
                        </label>
                        <input type="range" id="snn-neurons" min="500" max="2000" step="100" value="1000">
                    </div>
                    <div class="slider-container">
                        <label for="firing-threshold">Firing Threshold (mV): <span id="firing-threshold-value">-50</span>
                            <span class="info-tooltip" data-tooltip="Membrane potential threshold for neuron firing.">?</span>
                        </label>
                        <input type="range" id="firing-threshold" min="-70" max="-30" step="1" value="-50">
                    </div>
                </div>
                
                <div class="component">
                    <h3>Learning Parameters</h3>
                    <div class="slider-container">
                        <label for="learning-rate">Learning Rate: <span id="learning-rate-value">0.001</span>
                            <span class="info-tooltip" data-tooltip="Step size for the reinforcement learning algorithm.">?</span>
                        </label>
                        <input type="range" id="learning-rate" min="0.0001" max="0.01" step="0.0001" value="0.001">
                    </div>
                    <div class="slider-container">
                        <label for="discount-factor">Discount Factor: <span id="discount-factor-value">0.99</span>
                            <span class="info-tooltip" data-tooltip="Weight given to future rewards (γ in RL).">?</span>
                        </label>
                        <input type="range" id="discount-factor" min="0.8" max="0.999" step="0.001" value="0.99">
                    </div>
                    <div class="slider-container">
                        <label for="exploration-rate">Exploration Rate: <span id="exploration-rate-value">0.2</span>
                            <span class="info-tooltip" data-tooltip="Probability of taking a random action (ε in ε-greedy).">?</span>
                        </label>
                        <input type="range" id="exploration-rate" min="0.01" max="0.5" step="0.01" value="0.2">
                    </div>
                </div>
                
                <div class="component">
                    <h3>Genetic Modification</h3>
                    <div class="slider-container">
                        <label for="gene-mod-interval">Modification Interval: <span id="gene-mod-interval-value">100</span>
                            <span class="info-tooltip" data-tooltip="Number of episodes between genetic modifications.">?</span>
                        </label>
                        <input type="range" id="gene-mod-interval" min="10" max="500" step="10" value="100">
                    </div>
                    <div class="slider-container">
                        <label for="mod-strength">Modification Strength: <span id="mod-strength-value">0.1</span>
                            <span class="info-tooltip" data-tooltip="Magnitude of genetic parameter changes.">?</span>
                        </label>
                        <input type="range" id="mod-strength" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>
                    <button id="apply-gene-mod">Force Genetic Modification</button>
                    <button id="inject-virus" class="danger">INJECT VIRUS (Rewrite GRN)</button>
                </div>
                
                <div class="component">
                    <h3>Quantum Processor</h3>
                    <div class="slider-container">
                        <label for="quantum-influence">Quantum Influence: <span id="quantum-influence-value">0.3</span>
                            <span class="info-tooltip" data-tooltip="Degree to which quantum randomness affects decision-making.">?</span>
                        </label>
                        <input type="range" id="quantum-influence" min="0" max="1" step="0.05" value="0.3">
                    </div>
                    <button id="quantum-enhance">Apply Quantum Enhancement</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Main simulation code
        class Project1X4GSimulation {
            constructor() {
                // Initialize simulation state FIRST
                this.running = false;
                this.episodeCount = 0;
                this.stepCount = 0;
                this.rewardHistory = [];
                this.logs = [];
                
                // New State Variables
                this.fatigue = 0;
                this.isSleeping = false;
                this.viralLoad = 0;
                this.viralLoad = 0;
                this.phiHistory = [];
                this.spikeRateHistory = [];
                
                // Then initialize simulation components
                this.initializeParameters();
                this.initializeGRN();
                this.initializeBioNeurons();
                this.initializeNeuromorphicChip();
                this.initializeQuantumProcessor();
                this.initializeReinforcementLearning();
                
                // Setup UI handlers
                this.setupUIHandlers();
                this.setupVisualization();
                
                // Initialize history with zeros for better startup visuals
                this.spikeRateHistory = new Array(100).fill(0);
                
                this.updateVisualization();
                this.logMessage("System initialized successfully!");
            }
            
            initializeParameters() {
                // Environment parameters
                this.numGenes = parseInt(document.getElementById('num-genes').value);
                this.interactionStrength = parseFloat(document.getElementById('interaction-strength').value);
                this.envNoise = parseFloat(document.getElementById('env-noise').value);
                
                // Neural system parameters
                this.bioNeuronCount = parseInt(document.getElementById('bio-neurons').value);
                this.snnNeuronCount = parseInt(document.getElementById('snn-neurons').value);
                this.firingThreshold = parseInt(document.getElementById('firing-threshold').value);
                
                // Learning parameters
                this.learningRate = parseFloat(document.getElementById('learning-rate').value);
                this.discountFactor = parseFloat(document.getElementById('discount-factor').value);
                this.explorationRate = parseFloat(document.getElementById('exploration-rate').value);
                
                // Genetic modification parameters
                this.geneModInterval = parseInt(document.getElementById('gene-mod-interval').value);
                this.modStrength = parseFloat(document.getElementById('mod-strength').value);
                
                // Quantum parameters
                this.quantumInfluence = parseFloat(document.getElementById('quantum-influence').value);
                
                // Time parameters
                this.dt = 0.01; // Time step for simulation
                this.timeConstants = {
                    tau: 20, // Membrane time constant (ms)
                    R: 1.0   // Membrane resistance
                };
            }
            
            initializeGRN() {
                // Initialize gene regulatory network
                this.geneExpressionLevels = new Array(this.numGenes).fill(0).map(() => Math.random());
                this.targetExpressionLevels = new Array(this.numGenes).fill(0).map(() => 0.5 + 0.3 * (Math.random() - 0.5));
                
                // Generate interaction matrix for gene regulation
                this.interactionMatrix = Array(this.numGenes).fill().map(() => 
                    Array(this.numGenes).fill().map(() => 
                        (Math.random() < 0.3) ? this.interactionStrength * (Math.random() * 2 - 1) : 0
                    )
                );
                
                this.logMessage(`GRN initialized with ${this.numGenes} genes`);
            }
            
            initializeBioNeurons() {
                // Initialize biological neurons (leaky integrate-and-fire)
                this.bioNeurons = Array(this.bioNeuronCount).fill().map(() => ({
                    V: -70, // Membrane potential (mV)
                    refractory: 0, // Refractory period counter
                    lastSpike: -1000, // Time of last spike
                    spikeHistory: [], // Recent spike times
                    threshold: this.firingThreshold,
                    tau: this.timeConstants.tau * (0.8 + 0.4 * Math.random()), // Randomize time constants
                    weights: Array(this.numGenes).fill().map(() => Math.random() * 2 - 1) // Input weights
                }));
                
                this.logMessage(`Biological neural network initialized with ${this.bioNeuronCount} neurons`);
            }
            
            initializeNeuromorphicChip() {
                // Initialize neuromorphic chip (spiking neural network)
                this.snnLayers = [
                    this.bioNeuronCount, // Input layer size matches bio neurons
                    Math.floor(this.snnNeuronCount * 0.6), // Hidden layer
                    Math.floor(this.snnNeuronCount * 0.4), // Hidden layer
                    this.numGenes // Output layer size matches number of genes/actions
                ];
                
                // Create neurons for each layer
                this.snnNeurons = [];
                for (let layer = 0; layer < this.snnLayers.length; layer++) {
                    const layerNeurons = Array(this.snnLayers[layer]).fill().map(() => ({
                        potential: 0,
                        threshold: -50 + 10 * Math.random(),
                        lastSpike: -1000,
                        spikeCount: 0,
                        tau: 10 + 10 * Math.random()
                    }));
                    this.snnNeurons.push(layerNeurons);
                }
                
                // Create weights between layers
                this.snnWeights = [];
                for (let layer = 0; layer < this.snnLayers.length - 1; layer++) {
                    const layerWeights = Array(this.snnLayers[layer]).fill().map(() => 
                        Array(this.snnLayers[layer + 1]).fill().map(() => 
                            (Math.random() * 2 - 1) * 0.1
                        )
                    );
                    this.snnWeights.push(layerWeights);
                }
                
                this.logMessage(`Neuromorphic chip initialized with ${this.snnNeuronCount} neurons`);
            }
            
            initializeQuantumProcessor() {
                // Simulate a quantum processor for enhanced randomness/decisions
                this.qubits = 5;
                this.quantumCircuit = {
                    // Simplified quantum state representation
                    state: Array(Math.pow(2, this.qubits)).fill(0),
                    
                    // Initialize to uniform superposition
                    initialize: () => {
                        const normFactor = 1 / Math.sqrt(Math.pow(2, this.qubits));
                        this.quantumCircuit.state = this.quantumCircuit.state.map(() => normFactor);
                    },
                    
                    // Apply random unitary gates (simplified)
                    applyGates: () => {
                        // Apply random phase shifts
                        this.quantumCircuit.state = this.quantumCircuit.state.map(amp => {
                            const phase = Math.random() * 2 * Math.PI;
                            return { real: amp * Math.cos(phase), imag: amp * Math.sin(phase) };
                        });
                        
                        // Normalize
                        const sum = Math.sqrt(this.quantumCircuit.state.reduce((sum, val) => 
                            sum + val.real * val.real + val.imag * val.imag, 0));
                            
                        this.quantumCircuit.state = this.quantumCircuit.state.map(val => ({
                            real: val.real / sum,
                            imag: val.imag / sum
                        }));
                    },
                    
                    // Measure to get a classical result
                    measure: () => {
                        const probabilities = this.quantumCircuit.state.map(val => 
                            val.real * val.real + val.imag * val.imag);
                            
                        // Convert to cumulative probabilities
                        const cumulative = [];
                        let sum = 0;
                        for (const p of probabilities) {
                            sum += p;
                            cumulative.push(sum);
                        }
                        
                        // Random sampling
                        const r = Math.random();
                        for (let i = 0; i < cumulative.length; i++) {
                            if (r <= cumulative[i]) return i;
                        }
                        return cumulative.length - 1;
                    }
                };
                
                // Initialize quantum circuit
                this.quantumCircuit.initialize();
                
                this.logMessage("Quantum processor simulation initialized");
            }
            
            initializeReinforcementLearning() {
                // Initialize PPO-based reinforcement learning
                this.rl = {
                    buffer: [], // Experience replay buffer
                    bufferSize: 1000,
                    batchSize: 64,
                    policy: {
                        // Neural network weights (simplified)
                        // This will be influenced by the SNN output
                        weights: Array(this.numGenes).fill().map(() => Math.random() * 0.1)
                    },
                    valueFunction: {
                        // Simple linear value function for simplicity
                        weights: Array(this.numGenes).fill().map(() => Math.random() * 0.1),
                        bias: 0
                    },
                    
                    // Update policy using PPO (simplified)
                    updatePolicy: (states, actions, rewards, nextStates) => {
                        // Calculate advantages (simplified)
                        const values = states.map(state => this.estimateValue(state));
                        const nextValues = nextStates.map(state => this.estimateValue(state));
                        
                        const advantages = rewards.map((r, i) => 
                            r + this.discountFactor * nextValues[i] - values[i]);
                            
                        // Update policy weights (simplified PPO update)
                        for (let i = 0; i < this.rl.policy.weights.length; i++) {
                            let weightUpdate = 0;
                            for (let j = 0; j < states.length; j++) {
                                weightUpdate += advantages[j] * actions[j][i] * states[j][i];
                            }
                            this.rl.policy.weights[i] += this.learningRate * weightUpdate / states.length;
                        }
                        
                        // Update value function
                        for (let i = 0; i < this.rl.valueFunction.weights.length; i++) {
                            let weightUpdate = 0;
                            for (let j = 0; j < states.length; j++) {
                                const tdError = rewards[j] + this.discountFactor * nextValues[j] - values[j];
                                weightUpdate += tdError * states[j][i];
                            }
                            this.rl.valueFunction.weights[i] += this.learningRate * weightUpdate / states.length;
                        }
                    },
                    
                    // Store experience in buffer
                    storeExperience: (state, action, reward, nextState) => {
                        this.rl.buffer.push({ state, action, reward, nextState });
                        if (this.rl.buffer.length > this.rl.bufferSize) {
                            this.rl.buffer.shift();
                        }
                    },
                    
                    // Sample batch from buffer
                    sampleBatch: () => {
                        if (this.rl.buffer.length < this.rl.batchSize) return null;
                        
                        const batch = [];
                        for (let i = 0; i < this.rl.batchSize; i++) {
                            const idx = Math.floor(Math.random() * this.rl.buffer.length);
                            batch.push(this.rl.buffer[idx]);
                        }
                        
                        return {
                            states: batch.map(exp => exp.state),
                            actions: batch.map(exp => exp.action),
                            rewards: batch.map(exp => exp.reward),
                            nextStates: batch.map(exp => exp.nextState)
                        };
                    }
                };
                
                this.logMessage("Reinforcement learning system initialized");
            }
            
            // Estimate value of a state
            estimateValue(state) {
                return state.reduce((sum, val, idx) => 
                    sum + val * this.rl.valueFunction.weights[idx], 0) 
                    + this.rl.valueFunction.bias;
            }
            
            // Update gene expression levels based on ODEs
            updateGRN(actions) {
                const newLevels = [...this.geneExpressionLevels];
                
                // Apply gene regulatory network dynamics
                for (let i = 0; i < this.numGenes; i++) {
                    // Calculate regulation term
                    let regulation = 0;
                    for (let j = 0; j < this.numGenes; j++) {
                        regulation += this.interactionMatrix[j][i] * this.geneExpressionLevels[j];
                    }
                    
                    // Hill function-like nonlinearity
                    const hillCoefficient = 2;
                    const activationLevel = 1 / (1 + Math.exp(-hillCoefficient * regulation));
                    
                    // Update using ODE (dx/dt = f(x) + u)
                    const change = (activationLevel - this.geneExpressionLevels[i]) + actions[i];
                    newLevels[i] += this.dt * change;
                    
                    // Add noise
                    newLevels[i] += this.envNoise * (Math.random() * 2 - 1) * this.dt;
                    
                    // Clamp values
                    newLevels[i] = Math.max(0, Math.min(1, newLevels[i]));
                }
                
                this.geneExpressionLevels = newLevels;
            }
            
            // Calculate reward based on distance to target state
            calculateReward() {
                let sumSquaredError = 0;
                for (let i = 0; i < this.numGenes; i++) {
                    sumSquaredError += Math.pow(this.geneExpressionLevels[i] - this.targetExpressionLevels[i], 2);
                }
                
                // Negative of mean squared error
                const reward = -sumSquaredError / this.numGenes;
                return reward;
            }
            
            // Run biological neurons for one step
            runBioNeurons(noiseLevel = 0) {
                const spikes = Array(this.bioNeuronCount).fill(0);
                
                // Update each neuron
                for (let i = 0; i < this.bioNeuronCount; i++) {
                    const neuron = this.bioNeurons[i];
                    
                    // Skip if in refractory period
                    if (neuron.refractory > 0) {
                        neuron.refractory--;
                        continue;
                    }
                    
                    // Calculate input current based on gene expression
                    let I = 0;
                    for (let j = 0; j < this.numGenes; j++) {
                        I += neuron.weights[j] * this.geneExpressionLevels[j];
                    }
                    
                    // Update membrane potential using leaky integrate-and-fire model
                    const dv = (-neuron.V + neuron.threshold + I * this.timeConstants.R) / neuron.tau;
                    neuron.V += dv * this.dt * 1000; // Convert to ms
                    
                    // Check for spike
                    if (neuron.V >= neuron.threshold + noiseLevel) { // Noise affects threshold
                        spikes[i] = 1;
                        neuron.lastSpike = this.stepCount;
                        neuron.spikeHistory.push(this.stepCount);
                        if (neuron.spikeHistory.length > 20) neuron.spikeHistory.shift();
                        
                        // Reset and refractory period
                        neuron.V = -70; // Reset potential
                        neuron.refractory = 20; // 20 ms refractory period
                    }
                    
                    // Add noise
                    neuron.V += 0.1 * (Math.random() * 2 - 1);
                }
                
                return spikes;
            }
            
                // Run neuromorphic chip (SNN)
            runNeuromorphicChip(bioSpikes) {
                // Input layer receives spikes from bio neurons
                for (let i = 0; i < this.snnLayers[0]; i++) {
                    if (bioSpikes[i]) {
                        this.snnNeurons[0][i].potential += 10; // Input spike adds potential
                    }
                }
                
                // Propagate through layers
                for (let l = 0; l < this.snnLayers.length - 1; l++) {
                    for (let i = 0; i < this.snnLayers[l]; i++) {
                        // If neuron spikes
                        if (this.snnNeurons[l][i].potential >= this.snnNeurons[l][i].threshold) {
                            // Reset
                            this.snnNeurons[l][i].potential = 0;
                            this.snnNeurons[l][i].spikeCount++;
                            this.snnNeurons[l][i].lastSpike = this.stepCount;
                            
                            // Propagate to next layer
                            for (let j = 0; j < this.snnLayers[l+1]; j++) {
                                this.snnNeurons[l+1][j].potential += this.snnWeights[l][i][j];
                            }
                        } else {
                            // Decay
                            this.snnNeurons[l][i].potential *= 0.9;
                        }
                    }
                }
                
                // Output layer activity determines actions
                const outputLayer = this.snnNeurons[this.snnNeurons.length - 1];
                const actions = outputLayer.map(n => Math.tanh(n.potential * 0.1)); // Squash to [-1, 1]
                
                // Reset output layer potentials for next step (rate coding approximation)
                outputLayer.forEach(n => n.potential = 0);
                
                return actions;
            }
            
            // Main simulation step
            step() {
                if (!this.running) return;
                
                // Sleep / Dream Logic
                if (this.isSleeping) {
                    this.fatigue = Math.max(0, this.fatigue - 0.2);
                    if (this.fatigue === 0) {
                        this.toggleSleep(); // Wake up automatically
                    }
                    
                    // Dream: Replay random memories or random noise
                    // For visualization, we just stimulate neurons randomly
                    const dreamSpikes = Array(this.bioNeuronCount).fill(0).map(() => Math.random() < 0.05 ? 1 : 0);
                    this.runNeuromorphicChip(dreamSpikes); // Keep chip active
                    
                    this.stepCount++;
                    if (this.stepCount % 5 === 0) this.updateVisualization();
                    requestAnimationFrame(() => this.step());
                    return;
                }
                
                this.stepCount++;
                
                // Fatigue Accumulation
                this.fatigue = Math.min(100, this.fatigue + 0.01);
                
                // 1. Run Biological Neurons
                // High fatigue adds noise/instability
                const fatigueNoise = (this.fatigue > 80) ? 5 : 0; 
                const bioSpikes = this.runBioNeurons(fatigueNoise);
                
                // 2. Run Neuromorphic Chip
                let actions = this.runNeuromorphicChip(bioSpikes);
                
                // 3. Quantum Influence
                if (Math.random() < this.quantumInfluence) {
                    this.quantumCircuit.applyGates();
                    const qResult = this.quantumCircuit.measure();
                    // Use quantum result to perturb actions
                    const perturbationIdx = qResult % this.numGenes;
                    actions[perturbationIdx] += (Math.random() * 2 - 1) * 0.5;
                }
                
                // 4. Update Environment (GRN)
                const oldState = [...this.geneExpressionLevels];
                this.updateGRN(actions);
                
                // Viral Attack Logic
                if (this.viralLoad > 0) {
                    this.viralLoad--;
                    // Randomly flip gene expressions
                    if (Math.random() < 0.2) {
                        const idx = Math.floor(Math.random() * this.numGenes);
                        this.geneExpressionLevels[idx] = Math.random();
                    }
                }
                
                const newState = [...this.geneExpressionLevels];
                
                // 5. Calculate Reward
                const reward = this.calculateReward();
                this.rewardHistory.push(reward);
                if (this.rewardHistory.length > 100) this.rewardHistory.shift();
                
                // 6. Reinforcement Learning Update
                // Learning is impaired by fatigue
                if (this.fatigue < 90) {
                    this.rl.storeExperience(oldState, actions, reward, newState);
                    
                    if (this.stepCount % 10 === 0) {
                        const batch = this.rl.sampleBatch();
                        if (batch) {
                            this.rl.updatePolicy(batch.states, batch.actions, batch.rewards, batch.nextStates);
                        }
                    }
                }
                
                // 7. Genetic Modification (Periodic)
                if (this.episodeCount % this.geneModInterval === 0 && this.stepCount % 1000 === 0) {
                    this.applyGeneticModification();
                }
                
                // Update stats
                document.getElementById('current-reward').textContent = reward.toFixed(4);
                document.getElementById('fatigue-value').textContent = Math.floor(this.fatigue) + '%';
                
                // Calculate and Update Phi
                this.calculatePhi(bioSpikes);
                
                // Update visualization
                if (this.stepCount % 5 === 0) {
                    this.updateVisualization();
                }
                
                requestAnimationFrame(() => this.step());
            }
            
            toggleSleep() {
                this.isSleeping = !this.isSleeping;
                const btn = document.getElementById('sleep-btn');
                if (this.isSleeping) {
                    btn.textContent = "WAKE UP";
                    btn.style.backgroundColor = "#bd93f9";
                    btn.style.color = "#000";
                    this.logMessage("Entering Dream Mode (Consolidating Memories)...");
                } else {
                    btn.textContent = "Enter Dream Mode";
                    btn.style.backgroundColor = "";
                    btn.style.color = "#bd93f9";
                    this.logMessage("System Waking Up.");
                }
            }
            
            injectVirus() {
                this.viralLoad = 50; // Lasts 50 steps
                this.logMessage("WARNING: Viral Vector Injection Detected! GRN Instability Imminent.");
                
                // Immediate massive rewrite
                for (let i = 0; i < this.numGenes; i++) {
                    for (let j = 0; j < this.numGenes; j++) {
                        if (Math.random() < 0.3) {
                            this.interactionMatrix[i][j] = (Math.random() * 2 - 1);
                        }
                    }
                }
            }
            
            applyGeneticModification() {
                this.logMessage("Applying viral vector genetic modification...");
                
                // Modify interaction matrix (simulate CRISPR editing)
                const numModifications = Math.floor(this.numGenes * this.modStrength);
                for (let k = 0; k < numModifications; k++) {
                    const i = Math.floor(Math.random() * this.numGenes);
                    const j = Math.floor(Math.random() * this.numGenes);
                    this.interactionMatrix[i][j] += (Math.random() * 2 - 1) * this.modStrength;
                }
                
                this.logMessage(`Modified ${numModifications} gene interactions.`);
            }
            
            calculatePhi(spikes) {
                // Simplified Phi Calculation (Integrated Information)
                // 1. Synchrony: Variance of spike population
                const activeCount = spikes.reduce((a, b) => a + b, 0);
                
                // 2. Complexity: Entropy of GRN
                let entropy = 0;
                const bins = 10;
                const counts = new Array(bins).fill(0);
                this.geneExpressionLevels.forEach(val => {
                    const bin = Math.min(bins - 1, Math.floor(val * bins));
                    counts[bin]++;
                });
                counts.forEach(c => {
                    const p = c / this.numGenes;
                    if (p > 0) entropy -= p * Math.log2(p);
                });
                
                // Phi = Synchrony * Complexity (Heuristic)
                // Normalize roughly to 0-10 range
                const phi = (activeCount / this.bioNeuronCount) * entropy * 10;
                
                this.phiHistory.push(phi);
                if (this.phiHistory.length > 100) this.phiHistory.shift();
                
                // Update UI
                document.getElementById('phi-value').textContent = phi.toFixed(2);
                const stateEl = document.getElementById('consciousness-state');
                if (phi > 5.0) {
                    stateEl.textContent = "SENTIENT";
                    stateEl.style.color = "#ff0055";
                    stateEl.style.textShadow = "0 0 10px #ff0055";
                } else if (phi > 2.0) {
                    stateEl.textContent = "Awake";
                    stateEl.style.color = "#0ff";
                    stateEl.style.textShadow = "none";
                } else {
                    stateEl.textContent = "Unconscious";
                    stateEl.style.color = "#666";
                    stateEl.style.textShadow = "none";
                }
            }
            
            setupUIHandlers() {
                document.getElementById('start-btn').addEventListener('click', () => {
                    if (!this.running) {
                        this.running = true;
                        this.logMessage("Simulation started.");
                        this.step();
                    }
                });
                
                document.getElementById('pause-btn').addEventListener('click', () => {
                    this.running = false;
                    this.logMessage("Simulation paused.");
                });
                
                document.getElementById('reset-btn').addEventListener('click', () => {
                    this.running = false;
                    this.stepCount = 0;
                    this.episodeCount = 0;
                    this.rewardHistory = [];
                    this.initializeGRN();
                    this.initializeBioNeurons();
                    this.logMessage("Simulation reset.");
                    this.updateVisualization();
                });
                
                // Parameter sliders
                const sliders = ['num-genes', 'interaction-strength', 'env-noise', 
                               'bio-neurons', 'snn-neurons', 'firing-threshold',
                               'learning-rate', 'discount-factor', 'exploration-rate',
                               'gene-mod-interval', 'mod-strength', 'quantum-influence'];
                               
                sliders.forEach(id => {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(`${id}-value`);
                    slider.addEventListener('input', (e) => {
                        valueDisplay.textContent = e.target.value;
                        // Update parameter immediately
                        const paramName = id.replace(/-([a-z])/g, (g) => g[1].toUpperCase()); // camelCase
                        // Handle special cases or generic update
                        if (id === 'num-genes') {
                            // Requires re-init, so just update value for next reset
                        } else {
                            // Try to update this[paramName] if it exists
                            // This is a simplification
                        }
                    });
                });
                
                // Tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        
                        tab.classList.add('active');
                        document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
                        
                        // Resize canvases in the new tab since they might have been 0 or default
                        // We need a slight delay for the DOM to update display:block
                        setTimeout(() => {
                            const activeContent = document.getElementById(`${tab.dataset.tab}-tab`);
                            activeContent.querySelectorAll('canvas').forEach(c => {
                                c.width = c.parentElement.clientWidth;
                            });
                            this.updateVisualization();
                        }, 50);
                    });
                });
                
                document.getElementById('apply-gene-mod').addEventListener('click', () => {
                    this.applyGeneticModification();
                });
                
                document.getElementById('quantum-enhance').addEventListener('click', () => {
                   this.logMessage("Quantum enhancement triggered: Superposition state injected.");
                   // Simulate a burst of quantum randomness
                   this.quantumCircuit.applyGates();
                });
                
                document.getElementById('sleep-btn').addEventListener('click', () => {
                    this.toggleSleep();
                });
                
                document.getElementById('inject-virus').addEventListener('click', () => {
                    this.injectVirus();
                });
            }
            
            setupVisualization() {
                this.grnCanvas = document.getElementById('grn-canvas');
                this.grnCtx = this.grnCanvas.getContext('2d');
                
                this.neuronsCanvas = document.getElementById('neurons-canvas');
                this.neuronsCtx = this.neuronsCanvas.getContext('2d');
                
                this.learningCanvas = document.getElementById('learning-canvas');
                this.learningCtx = this.learningCanvas.getContext('2d');
                
                this.phiCanvas = document.getElementById('phi-monitor');
                this.phiCtx = this.phiCanvas.getContext('2d');
                
                this.spikeMonitorCanvas = document.getElementById('spike-monitor');
                this.spikeMonitorCtx = this.spikeMonitorCanvas.getContext('2d');
                
                this.rewardChartCanvas = document.getElementById('reward-chart');
                this.rewardChartCtx = this.rewardChartCanvas.getContext('2d');
                
                // Resize canvases
                [this.grnCanvas, this.neuronsCanvas, this.learningCanvas, this.phiCanvas, this.spikeMonitorCanvas, this.rewardChartCanvas].forEach(c => {
                    // Fallback to 400 if parent is hidden (width 0)
                    c.width = c.parentElement.clientWidth || 400;
                });
            }
            
            updateVisualization() {
                // Draw GRN
                const w = this.grnCanvas.width;
                const h = this.grnCanvas.height;
                this.grnCtx.fillStyle = '#000';
                this.grnCtx.fillRect(0, 0, w, h);
                
                const barWidth = w / this.numGenes;
                for (let i = 0; i < this.numGenes; i++) {
                    const val = this.geneExpressionLevels[i];
                    const target = this.targetExpressionLevels[i];
                    
                    // Draw current level
                    this.grnCtx.fillStyle = `rgb(${val * 255}, ${255 - val * 255}, 0)`;
                    this.grnCtx.fillRect(i * barWidth, h, barWidth - 2, -val * h);
                    
                    // Draw target marker
                    this.grnCtx.fillStyle = '#fff';
                    this.grnCtx.fillRect(i * barWidth, h - target * h, barWidth - 2, 2);
                }
                
                // Draw Neurons (Raster plot style)
                const nw = this.neuronsCanvas.width;
                const nh = this.neuronsCanvas.height;
                // Fade effect
                this.neuronsCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.neuronsCtx.fillRect(0, 0, nw, nh);
                
                if (this.isSleeping) {
                    this.neuronsCtx.fillStyle = 'rgba(189, 147, 249, 0.1)'; // Dream color
                    this.neuronsCtx.font = "20px Courier New";
                    this.neuronsCtx.fillText("DREAMING...", nw/2 - 50, nh/2);
                }
                
                this.neuronsCtx.fillStyle = this.isSleeping ? '#bd93f9' : '#0f0';
                for (let i = 0; i < this.bioNeuronCount; i++) {
                    if (this.bioNeurons[i].lastSpike === this.stepCount) {
                        const x = (this.stepCount % 100) * (nw / 100);
                        const y = (i / this.bioNeuronCount) * nh;
                        this.neuronsCtx.fillRect(x, y, 2, 2);
                    }
                }
                
                // Update Fatigue Box Color
                const fatigueBox = document.getElementById('fatigue-box');
                if (this.fatigue > 80) fatigueBox.classList.add('alert');
                else fatigueBox.classList.remove('alert');
                
                // Draw Learning Curve
                const lw = this.learningCanvas.width;
                const lh = this.learningCanvas.height;
                this.learningCtx.clearRect(0, 0, lw, lh);
                this.learningCtx.strokeStyle = '#00f';
                this.learningCtx.beginPath();
                for (let i = 0; i < this.rewardHistory.length; i++) {
                    const x = (i / 100) * lw;
                    // Scale reward -1 to 0 to canvas height
                    const y = lh - (this.rewardHistory[i] + 1) * lh; 
                    if (i === 0) this.learningCtx.moveTo(x, y);
                    else this.learningCtx.lineTo(x, y);
                }
                this.learningCtx.stroke();
                
                // Draw Phi Monitor
                const pw = this.phiCanvas.width;
                const ph = this.phiCanvas.height;
                this.phiCtx.clearRect(0, 0, pw, ph);
                this.phiCtx.strokeStyle = '#ff0055'; // Pink/Red for Phi
                this.phiCtx.lineWidth = 2;
                this.phiCtx.beginPath();
                for (let i = 0; i < this.phiHistory.length; i++) {
                    const x = (i / 100) * pw;
                    // Scale Phi 0-10 to canvas height
                    const y = ph - (this.phiHistory[i] / 10) * ph; 
                    if (i === 0) this.phiCtx.moveTo(x, y);
                    else this.phiCtx.lineTo(x, y);
                }
                this.phiCtx.stroke();
                
                // Update stats text
                if (this.rewardHistory.length > 0) {
                    const avg = this.rewardHistory.reduce((a, b) => a + b, 0) / this.rewardHistory.length;
                    document.getElementById('avg-reward').textContent = avg.toFixed(4);
                }
                document.getElementById('episode-count').textContent = this.episodeCount;
                document.getElementById('age-value').textContent = this.stepCount;
                
                // --- Draw Spike Monitor (Rate History) ---
                const activeCount = this.bioNeurons.filter(n => n.lastSpike === this.stepCount).length;
                this.spikeRateHistory.push(activeCount);
                if (this.spikeRateHistory.length > 100) this.spikeRateHistory.shift();
                
                const smw = this.spikeMonitorCanvas.width;
                const smh = this.spikeMonitorCanvas.height;
                this.spikeMonitorCtx.clearRect(0, 0, smw, smh);
                
                // Draw Grid
                this.spikeMonitorCtx.strokeStyle = '#222';
                this.spikeMonitorCtx.lineWidth = 1;
                this.spikeMonitorCtx.beginPath();
                for(let i=0; i<smw; i+=20) { this.spikeMonitorCtx.moveTo(i,0); this.spikeMonitorCtx.lineTo(i,smh); }
                for(let i=0; i<smh; i+=20) { this.spikeMonitorCtx.moveTo(0,i); this.spikeMonitorCtx.lineTo(smw,i); }
                this.spikeMonitorCtx.stroke();
                
                this.spikeMonitorCtx.strokeStyle = '#0ff';
                this.spikeMonitorCtx.lineWidth = 2;
                this.spikeMonitorCtx.beginPath();
                for (let i = 0; i < this.spikeRateHistory.length; i++) {
                    const x = (i / 100) * smw;
                    // Scale 0-BioNeuronCount to height
                    const y = smh - (this.spikeRateHistory[i] / this.bioNeuronCount) * smh;
                    if (i === 0) this.spikeMonitorCtx.moveTo(x, y);
                    else this.spikeMonitorCtx.lineTo(x, y);
                }
                this.spikeMonitorCtx.stroke();
                
                // --- Draw Reward Chart (Value Function Weights) ---
                const rcw = this.rewardChartCanvas.width;
                const rch = this.rewardChartCanvas.height;
                this.rewardChartCtx.clearRect(0, 0, rcw, rch);
                
                // Draw Grid
                this.rewardChartCtx.strokeStyle = '#222';
                this.rewardChartCtx.lineWidth = 1;
                this.rewardChartCtx.beginPath();
                for(let i=0; i<rcw; i+=20) { this.rewardChartCtx.moveTo(i,0); this.rewardChartCtx.lineTo(i,rch); }
                for(let i=0; i<rch; i+=20) { this.rewardChartCtx.moveTo(0,i); this.rewardChartCtx.lineTo(rcw,i); }
                this.rewardChartCtx.stroke();
                
                const barW = rcw / this.numGenes;
                const maxWeight = Math.max(...this.rl.valueFunction.weights.map(Math.abs), 0.1); // Avoid div by 0
                
                for (let i = 0; i < this.numGenes; i++) {
                    const w = this.rl.valueFunction.weights[i];
                    const h = (w / maxWeight) * (rch / 2); // Scale to half height
                    const x = i * barW;
                    const y = rch / 2; // Center origin
                    
                    this.rewardChartCtx.fillStyle = w >= 0 ? '#0f0' : '#f00';
                    this.rewardChartCtx.fillRect(x, y, barW - 2, -h);
                }
                
                // Draw zero line
                this.rewardChartCtx.strokeStyle = '#333';
                this.rewardChartCtx.beginPath();
                this.rewardChartCtx.moveTo(0, rch/2);
                this.rewardChartCtx.lineTo(rcw, rch/2);
                this.rewardChartCtx.stroke();
            }
            
            logMessage(msg) {
                const container = document.getElementById('log-container');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                const time = new Date().toLocaleTimeString();
                entry.textContent = `[${time}] ${msg}`;
                container.prepend(entry);
                
                // Keep log size manageable
                if (container.children.length > 50) {
                    container.removeChild(container.lastChild);
                }
            }
        }
        
        // Start simulation when page loads
        window.addEventListener('load', () => {
            const sim = new Project1X4GSimulation();
        });
    </script>
</body>
</html>
