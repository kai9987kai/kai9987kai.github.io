<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NeuroFold â€” AI-Driven Protein Folding Simulator</title>
<style>
  :root {
    --bg-primary: #0a0e17;
    --bg-secondary: #111827;
    --bg-card: #1a2235;
    --accent: #06d6a0;
    --accent2: #118ab2;
    --accent3: #ef476f;
    --text: #e0e7ff;
    --text-dim: #6b7fa3;
    --border: #2a3a55;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg-primary);
    color: var(--text);
    overflow-x: hidden;
    min-height: 100vh;
  }

  /* Header */
  header {
    background: linear-gradient(135deg, var(--bg-secondary), var(--bg-primary));
    border-bottom: 1px solid var(--border);
    padding: 1rem 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: blur(10px);
  }

  .logo {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 1.5rem;
    font-weight: 700;
  }

  .logo svg { width: 36px; height: 36px; }

  .logo span.neuro { color: var(--accent); }
  .logo span.fold { color: var(--text); }

  nav { display: flex; gap: 1.5rem; }
  nav a {
    color: var(--text-dim);
    text-decoration: none;
    font-size: 0.9rem;
    transition: color 0.3s;
    cursor: pointer;
  }
  nav a:hover, nav a.active { color: var(--accent); }

  /* Main Layout */
  .main-container {
    display: grid;
    grid-template-columns: 340px 1fr 320px;
    gap: 0;
    height: calc(100vh - 60px);
  }

  /* Panels */
  .panel {
    background: var(--bg-secondary);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    padding: 1.25rem;
  }

  .panel:last-child { border-right: none; border-left: 1px solid var(--border); }

  .panel-title {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-dim);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .panel-title .dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--accent);
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* Sequence Input */
  .input-group { margin-bottom: 1rem; }

  .input-group label {
    display: block;
    font-size: 0.85rem;
    color: var(--text-dim);
    margin-bottom: 6px;
  }

  textarea, input[type="text"], select {
    width: 100%;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    padding: 10px 12px;
    font-family: 'Courier New', monospace;
    font-size: 0.85rem;
    resize: vertical;
    outline: none;
    transition: border-color 0.3s;
  }

  textarea:focus, input:focus, select:focus {
    border-color: var(--accent);
  }

  textarea { min-height: 100px; }

  select {
    font-family: 'Segoe UI', system-ui, sans-serif;
    cursor: pointer;
  }

  /* Buttons */
  .btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    width: 100%;
    justify-content: center;
  }

  .btn-primary {
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    color: #000;
  }

  .btn-primary:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 20px rgba(6, 214, 160, 0.3);
  }

  .btn-secondary {
    background: var(--bg-card);
    color: var(--text);
    border: 1px solid var(--border);
  }

  .btn-danger {
    background: rgba(239, 71, 111, 0.2);
    color: var(--accent3);
    border: 1px solid rgba(239, 71, 111, 0.3);
  }

  .btn-sm {
    padding: 6px 12px;
    font-size: 0.8rem;
    width: auto;
  }

  .btn-group {
    display: flex;
    gap: 8px;
    margin-top: 0.75rem;
  }

  /* Preset Proteins */
  .presets {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-bottom: 1rem;
  }

  .preset-chip {
    padding: 4px 10px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 20px;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.3s;
    color: var(--text-dim);
  }

  .preset-chip:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(6, 214, 160, 0.1);
  }

  /* Queue */
  .queue-item {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }

  .queue-item:hover {
    border-color: var(--accent2);
    transform: translateX(3px);
  }

  .queue-item.active {
    border-color: var(--accent);
    background: rgba(6, 214, 160, 0.05);
  }

  .queue-item .q-name {
    font-weight: 600;
    font-size: 0.9rem;
    margin-bottom: 4px;
  }

  .queue-item .q-meta {
    font-size: 0.75rem;
    color: var(--text-dim);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .priority-badge {
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.7rem;
    font-weight: 600;
  }

  .priority-high {
    background: rgba(239, 71, 111, 0.2);
    color: var(--accent3);
  }

  .priority-medium {
    background: rgba(255, 209, 102, 0.2);
    color: #ffd166;
  }

  .priority-low {
    background: rgba(6, 214, 160, 0.2);
    color: var(--accent);
  }

  .q-progress {
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    margin-top: 8px;
    overflow: hidden;
  }

  .q-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    border-radius: 2px;
    transition: width 0.5s;
  }

  /* 3D Viewer */
  .viewer-container {
    position: relative;
    background: var(--bg-primary);
    display: flex;
    flex-direction: column;
  }

  #viewer3d {
    flex: 1;
    cursor: grab;
  }

  #viewer3d:active { cursor: grabbing; }

  .viewer-controls {
    position: absolute;
    bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    background: rgba(17, 24, 39, 0.9);
    padding: 8px 16px;
    border-radius: 12px;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
  }

  .viewer-controls button {
    background: none;
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.3s;
  }

  .viewer-controls button:hover {
    border-color: var(--accent);
    color: var(--accent);
  }

  .viewer-controls button.active {
    background: rgba(6, 214, 160, 0.2);
    border-color: var(--accent);
    color: var(--accent);
  }

  .viewer-overlay {
    position: absolute;
    top: 1rem;
    left: 1rem;
    right: 1rem;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
  }

  .viewer-info {
    background: rgba(17, 24, 39, 0.85);
    padding: 10px 16px;
    border-radius: 10px;
    border: 1px solid var(--border);
    font-size: 0.8rem;
    pointer-events: auto;
    backdrop-filter: blur(10px);
  }

  .viewer-info h3 {
    color: var(--accent);
    margin-bottom: 4px;
    font-size: 0.9rem;
  }

  .stat-row {
    display: flex;
    justify-content: space-between;
    gap: 1.5rem;
    margin: 3px 0;
  }

  .stat-label { color: var(--text-dim); }
  .stat-value { color: var(--text); font-weight: 600; font-variant-numeric: tabular-nums; }

  .energy-display {
    text-align: right;
  }

  .energy-value {
    font-size: 1.8rem;
    font-weight: 700;
    color: var(--accent);
    font-variant-numeric: tabular-nums;
  }

  .energy-label {
    font-size: 0.75rem;
    color: var(--text-dim);
  }

  /* Right Panel - NN Info */
  .nn-section {
    margin-bottom: 1.5rem;
  }

  .nn-section h4 {
    font-size: 0.85rem;
    margin-bottom: 0.75rem;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .nn-layer {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 6px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .nn-layer-name {
    font-size: 0.8rem;
  }

  .nn-layer-info {
    font-size: 0.75rem;
    color: var(--text-dim);
  }

  .nn-nodes {
    display: flex;
    gap: 3px;
  }

  .nn-node {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--accent2);
    opacity: 0.3;
    transition: opacity 0.5s;
  }

  .nn-node.active { opacity: 1; }

  /* Feature Bars */
  .feature-bar {
    margin-bottom: 10px;
  }

  .feature-bar-header {
    display: flex;
    justify-content: space-between;
    font-size: 0.78rem;
    margin-bottom: 4px;
  }

  .feature-bar-track {
    height: 6px;
    background: var(--border);
    border-radius: 3px;
    overflow: hidden;
  }

  .feature-bar-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.8s ease;
  }

  .fill-green { background: linear-gradient(90deg, #06d6a0, #0ec27a); }
  .fill-blue { background: linear-gradient(90deg, #118ab2, #0694d4); }
  .fill-red { background: linear-gradient(90deg, #ef476f, #d63455); }
  .fill-yellow { background: linear-gradient(90deg, #ffd166, #e6b84d); }
  .fill-purple { background: linear-gradient(90deg, #8338ec, #a55eea); }

  /* Energy Chart */
  .chart-container {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 1rem;
  }

  #energyChart {
    width: 100%;
    height: 120px;
  }

  /* Ramachandran */
  #ramaChart {
    width: 100%;
    height: 150px;
  }

  /* Amino Acid Legend */
  .aa-legend {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 3px;
    font-size: 0.65rem;
    margin-top: 0.5rem;
  }

  .aa-item {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 2px 4px;
    border-radius: 3px;
    background: rgba(255,255,255,0.03);
  }

  .aa-color {
    width: 10px;
    height: 10px;
    border-radius: 2px;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--bg-secondary); }
  ::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 3px;
  }
  ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

  /* Loading animation */
  .folding-status {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: rgba(6, 214, 160, 0.1);
    border: 1px solid rgba(6, 214, 160, 0.2);
    border-radius: 8px;
    font-size: 0.8rem;
    margin-bottom: 1rem;
  }

  .spinner {
    width: 16px; height: 16px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .hidden { display: none !important; }

  /* Separator */
  .sep {
    height: 1px;
    background: var(--border);
    margin: 1rem 0;
  }

  /* Confidence */
  .confidence-meter {
    display: flex;
    height: 20px;
    border-radius: 4px;
    overflow: hidden;
    margin-top: 6px;
  }

  .conf-segment {
    transition: width 0.8s ease;
    position: relative;
  }

  .conf-very-high { background: #0652DD; }
  .conf-high { background: #06d6a0; }
  .conf-medium { background: #ffd166; }
  .conf-low { background: #ef476f; }

  .conf-legend {
    display: flex;
    justify-content: space-between;
    margin-top: 6px;
    font-size: 0.7rem;
    color: var(--text-dim);
  }

  .conf-legend span {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .conf-legend .dot-leg {
    width: 8px; height: 8px;
    border-radius: 2px;
  }

  /* Responsive */
  @media (max-width: 1200px) {
    .main-container {
      grid-template-columns: 1fr;
      height: auto;
    }
    .panel { border-right: none; border-bottom: 1px solid var(--border); }
    .viewer-container { min-height: 500px; }
  }

  /* Toast */
  .toast {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    background: var(--bg-card);
    border: 1px solid var(--accent);
    border-radius: 10px;
    padding: 12px 20px;
    font-size: 0.85rem;
    z-index: 1000;
    animation: slideUp 0.3s ease;
    box-shadow: 0 8px 30px rgba(0,0,0,0.3);
  }

  @keyframes slideUp {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  /* NN Visualization Canvas */
  #nnVis {
    width: 100%;
    height: 160px;
    border-radius: 8px;
    background: var(--bg-card);
    border: 1px solid var(--border);
  }

  /* Secondary Structure Bar */
  .ss-bar {
    display: flex;
    height: 14px;
    border-radius: 3px;
    overflow: hidden;
    margin: 6px 0;
  }

  .ss-helix { background: #ef476f; }
  .ss-sheet { background: #118ab2; }
  .ss-coil { background: #6b7fa3; }
  .ss-turn { background: #ffd166; }

  .ss-legend {
    display: flex;
    gap: 12px;
    font-size: 0.72rem;
    color: var(--text-dim);
    margin-bottom: 6px;
  }

  .ss-legend span {
    display: flex;
    align-items: center;
    gap: 4px;
  }
</style>
</head>
<body>

<header>
  <div class="logo">
    <svg viewBox="0 0 36 36" fill="none">
      <circle cx="18" cy="18" r="16" stroke="#06d6a0" stroke-width="2"/>
      <path d="M10 22 C12 14, 16 10, 18 18 C20 26, 24 22, 26 14" stroke="#118ab2" stroke-width="2.5" fill="none" stroke-linecap="round"/>
      <circle cx="10" cy="22" r="3" fill="#06d6a0"/>
      <circle cx="18" cy="18" r="3" fill="#ef476f"/>
      <circle cx="26" cy="14" r="3" fill="#ffd166"/>
    </svg>
    <div><span class="neuro">Neuro</span><span class="fold">Fold</span></div>
  </div>
  <nav>
    <a class="active" onclick="showTab('simulate')">Simulate</a>
    <a onclick="showTab('about')">About</a>
    <a onclick="showTab('help')">Help</a>
  </nav>
</header>

<div class="main-container">
  <!-- LEFT PANEL: Input & Queue -->
  <div class="panel" id="leftPanel">
    <div class="panel-title"><div class="dot"></div> PROTEIN INPUT</div>

    <div class="input-group">
      <label>Protein Name</label>
      <input type="text" id="proteinName" placeholder="e.g., Insulin B-chain" value="Myoglobin Fragment">
    </div>

    <div class="input-group">
      <label>Amino Acid Sequence (1-letter code)</label>
      <textarea id="sequenceInput" placeholder="Enter amino acid sequence... e.g., MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSH">MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSH</textarea>
    </div>

    <div class="input-group">
      <label>Quick Presets</label>
      <div class="presets">
        <span class="preset-chip" onclick="loadPreset('insulin')">Insulin</span>
        <span class="preset-chip" onclick="loadPreset('myoglobin')">Myoglobin</span>
        <span class="preset-chip" onclick="loadPreset('lysozyme')">Lysozyme</span>
        <span class="preset-chip" onclick="loadPreset('ubiquitin')">Ubiquitin</span>
        <span class="preset-chip" onclick="loadPreset('gfp')">GFP</span>
        <span class="preset-chip" onclick="loadPreset('hemoglobin')">Hemoglobin</span>
        <span class="preset-chip" onclick="loadPreset('collagen')">Collagen</span>
        <span class="preset-chip" onclick="loadPreset('random')">ðŸŽ² Random</span>
      </div>
    </div>

    <div class="input-group">
      <label>Simulation Parameters</label>
      <select id="forceField">
        <option value="amber">AMBER ff14SB</option>
        <option value="charmm">CHARMM36m</option>
        <option value="opls">OPLS-AA</option>
      </select>
    </div>

    <div class="btn-group">
      <button class="btn btn-primary" onclick="submitProtein()">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 1v14M1 8h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/></svg>
        Analyze & Fold
      </button>
    </div>

    <div class="sep"></div>

    <div class="panel-title"><div class="dot" style="background:var(--accent2)"></div> FOLDING QUEUE</div>

    <div id="foldingStatus" class="folding-status hidden">
      <div class="spinner"></div>
      <span id="statusText">Folding in progress...</span>
    </div>

    <div id="queueContainer"></div>
  </div>

  <!-- CENTER: 3D Viewer -->
  <div class="viewer-container">
    <canvas id="viewer3d"></canvas>

    <div class="viewer-overlay">
      <div class="viewer-info">
        <h3 id="viewerProteinName">Myoglobin Fragment</h3>
        <div class="stat-row">
          <span class="stat-label">Residues:</span>
          <span class="stat-value" id="residueCount">50</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Step:</span>
          <span class="stat-value" id="foldStep">0 / 1000</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">RMSD:</span>
          <span class="stat-value" id="rmsdValue">--</span>
        </div>
      </div>
      <div class="viewer-info energy-display">
        <div class="energy-value" id="energyValue">0.00</div>
        <div class="energy-label">Free Energy (kcal/mol)</div>
        <div class="stat-row" style="margin-top:6px">
          <span class="stat-label">Temperature:</span>
          <span class="stat-value" id="tempValue">300 K</span>
        </div>
      </div>
    </div>

    <div class="viewer-controls">
      <button onclick="toggleSpin()" id="btnSpin" class="active">âŸ³ Spin</button>
      <button onclick="setViewMode('backbone')" id="btnBackbone" class="active">Backbone</button>
      <button onclick="setViewMode('ribbon')" id="btnRibbon">Ribbon</button>
      <button onclick="setViewMode('spacefill')" id="btnSpacefill">Space-fill</button>
      <button onclick="resetCamera()">âŒ– Reset</button>
      <button onclick="toggleFolding()" id="btnFold">â–¶ Fold</button>
    </div>
  </div>

  <!-- RIGHT PANEL: NN Analysis -->
  <div class="panel" id="rightPanel">
    <div class="panel-title"><div class="dot" style="background:var(--accent3)"></div> NEURAL NETWORK ANALYSIS</div>

    <div class="nn-section">
      <h4>ðŸ§  Priority Network Architecture</h4>
      <canvas id="nnVis"></canvas>
    </div>

    <div class="nn-section">
      <h4>ðŸ“Š Sequence Feature Extraction</h4>
      <div id="featureBars">
        <div class="feature-bar">
          <div class="feature-bar-header">
            <span>Hydrophobicity Index</span>
            <span id="feat-hydro">0.0</span>
          </div>
          <div class="feature-bar-track">
            <div class="feature-bar-fill fill-blue" id="bar-hydro" style="width:0%"></div>
          </div>
        </div>
        <div class="feature-bar">
          <div class="feature-bar-header">
            <span>Charge Distribution</span>
            <span id="feat-charge">0.0</span>
          </div>
          <div class="feature-bar-track">
            <div class="feature-bar-fill fill-red" id="bar-charge" style="width:0%"></div>
          </div>
        </div>
        <div class="feature-bar">
          <div class="feature-bar-header">
            <span>Complexity Score</span>
            <span id="feat-complex">0.0</span>
          </div>
          <div class="feature-bar-track">
            <div class="feature-bar-fill fill-purple" id="bar-complex" style="width:0%"></div>
          </div>
        </div>
        <div class="feature-bar">
          <div class="feature-bar-header">
            <span>Disorder Propensity</span>
            <span id="feat-disorder">0.0</span>
          </div>
          <div class="feature-bar-track">
            <div class="feature-bar-fill fill-yellow" id="bar-disorder" style="width:0%"></div>
          </div>
        </div>
        <div class="feature-bar">
          <div class="feature-bar-header">
            <span>Medical Relevance</span>
            <span id="feat-medical">0.0</span>
          </div>
          <div class="feature-bar-track">
            <div class="feature-bar-fill fill-green" id="bar-medical" style="width:0%"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="nn-section">
      <h4>ðŸŽ¯ NN Priority Score</h4>
      <div style="text-align:center;padding:10px 0">
        <div id="priorityScore" style="font-size:2.5rem;font-weight:800;color:var(--accent)">--</div>
        <div style="font-size:0.75rem;color:var(--text-dim)">Higher = More Needed for Simulation</div>
      </div>
    </div>

    <div class="nn-section">
      <h4>ðŸ”¬ Predicted Secondary Structure</h4>
      <div class="ss-legend">
        <span><div class="dot-leg" style="background:#ef476f;width:8px;height:8px;border-radius:2px"></div> Î±-Helix</span>
        <span><div class="dot-leg" style="background:#118ab2;width:8px;height:8px;border-radius:2px"></div> Î²-Sheet</span>
        <span><div class="dot-leg" style="background:#ffd166;width:8px;height:8px;border-radius:2px"></div> Turn</span>
        <span><div class="dot-leg" style="background:#6b7fa3;width:8px;height:8px;border-radius:2px"></div> Coil</span>
      </div>
      <div class="ss-bar" id="ssBar"></div>
      <div id="ssPercentages" style="font-size:0.75rem;color:var(--text-dim)"></div>
    </div>

    <div class="nn-section">
      <h4>ðŸ“‰ Energy Trajectory</h4>
      <div class="chart-container">
        <canvas id="energyChart"></canvas>
      </div>
    </div>

    <div class="nn-section">
      <h4>ðŸŽ¯ Confidence Map</h4>
      <div style="font-size:0.78rem;color:var(--text-dim);margin-bottom:4px">Per-residue folding confidence (pLDDT)</div>
      <div class="confidence-meter" id="confMeter"></div>
      <div class="conf-legend">
        <span><div class="dot-leg conf-very-high"></div> Very High</span>
        <span><div class="dot-leg conf-high"></div> High</span>
        <span><div class="dot-leg conf-medium"></div> Medium</span>
        <span><div class="dot-leg conf-low"></div> Low</span>
      </div>
    </div>

    <div class="nn-section">
      <h4>ðŸ§¬ Ramachandran Plot</h4>
      <div class="chart-container">
        <canvas id="ramaChart"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
// ============================
// NEURAL NETWORK IMPLEMENTATION
// ============================

class NeuralNetwork {
  constructor(layerSizes) {
    this.layers = [];
    this.layerSizes = layerSizes;
    for (let i = 1; i < layerSizes.length; i++) {
      this.layers.push({
        weights: this.randomMatrix(layerSizes[i], layerSizes[i-1]),
        biases: this.randomArray(layerSizes[i]),
        activations: new Array(layerSizes[i]).fill(0)
      });
    }
  }

  randomMatrix(rows, cols) {
    const m = [];
    for (let i = 0; i < rows; i++) {
      m.push([]);
      for (let j = 0; j < cols; j++) {
        m[i].push((Math.random() - 0.5) * 2 / Math.sqrt(cols));
      }
    }
    return m;
  }

  randomArray(n) {
    return Array.from({length: n}, () => (Math.random() - 0.5) * 0.1);
  }

  relu(x) { return Math.max(0, x); }
  sigmoid(x) { return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x)))); }

  forward(input) {
    let current = input;
    for (let l = 0; l < this.layers.length; l++) {
      const layer = this.layers[l];
      const next = [];
      for (let i = 0; i < layer.weights.length; i++) {
        let sum = layer.biases[i];
        for (let j = 0; j < current.length; j++) {
          sum += layer.weights[i][j] * current[j];
        }
        const activated = l === this.layers.length - 1 ? this.sigmoid(sum) : this.relu(sum);
        next.push(activated);
        layer.activations[i] = activated;
      }
      current = next;
    }
    return current;
  }
}

// ============================
// AMINO ACID DATA
// ============================

const AA_PROPERTIES = {
  'A': { hydro: 1.8,  charge: 0, mw: 89,  helix: 1.42, sheet: 0.83, color: '#E74C3C', name: 'Ala' },
  'R': { hydro: -4.5, charge: 1, mw: 174, helix: 0.98, sheet: 0.93, color: '#3498DB', name: 'Arg' },
  'N': { hydro: -3.5, charge: 0, mw: 132, helix: 0.67, sheet: 0.89, color: '#2ECC71', name: 'Asn' },
  'D': { hydro: -3.5, charge:-1, mw: 133, helix: 1.01, sheet: 0.54, color: '#E74C3C', name: 'Asp' },
  'C': { hydro: 2.5,  charge: 0, mw: 121, helix: 0.70, sheet: 1.19, color: '#F1C40F', name: 'Cys' },
  'E': { hydro: -3.5, charge:-1, mw: 147, helix: 1.51, sheet: 0.37, color: '#E74C3C', name: 'Glu' },
  'Q': { hydro: -3.5, charge: 0, mw: 146, helix: 1.11, sheet: 1.10, color: '#2ECC71', name: 'Gln' },
  'G': { hydro: -0.4, charge: 0, mw: 75,  helix: 0.57, sheet: 0.75, color: '#ECF0F1', name: 'Gly' },
  'H': { hydro: -3.2, charge: 0, mw: 155, helix: 1.00, sheet: 0.87, color: '#3498DB', name: 'His' },
  'I': { hydro: 4.5,  charge: 0, mw: 131, helix: 1.08, sheet: 1.60, color: '#27AE60', name: 'Ile' },
  'L': { hydro: 3.8,  charge: 0, mw: 131, helix: 1.21, sheet: 1.30, color: '#27AE60', name: 'Leu' },
  'K': { hydro: -3.9, charge: 1, mw: 146, helix: 1.16, sheet: 0.74, color: '#3498DB', name: 'Lys' },
  'M': { hydro: 1.9,  charge: 0, mw: 149, helix: 1.45, sheet: 1.05, color: '#F1C40F', name: 'Met' },
  'F': { hydro: 2.8,  charge: 0, mw: 165, helix: 1.13, sheet: 1.38, color: '#9B59B6', name: 'Phe' },
  'P': { hydro: -1.6, charge: 0, mw: 115, helix: 0.57, sheet: 0.55, color: '#E67E22', name: 'Pro' },
  'S': { hydro: -0.8, charge: 0, mw: 105, helix: 0.77, sheet: 0.75, color: '#1ABC9C', name: 'Ser' },
  'T': { hydro: -0.7, charge: 0, mw: 119, helix: 0.83, sheet: 1.19, color: '#1ABC9C', name: 'Thr' },
  'W': { hydro: -0.9, charge: 0, mw: 204, helix: 1.08, sheet: 1.37, color: '#9B59B6', name: 'Trp' },
  'Y': { hydro: -1.3, charge: 0, mw: 181, helix: 0.69, sheet: 1.47, color: '#9B59B6', name: 'Tyr' },
  'V': { hydro: 4.2,  charge: 0, mw: 117, helix: 1.06, sheet: 1.70, color: '#27AE60', name: 'Val' }
};

const PRESETS = {
  insulin: { name: 'Insulin B-chain', seq: 'FVNQHLCGSHLVEALYLVCGERGFFYTPKT' },
  myoglobin: { name: 'Myoglobin Fragment', seq: 'MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSH' },
  lysozyme: { name: 'Lysozyme Fragment', seq: 'KVFGRCELAAAMKRHGLDNYRGYSLGNWVCAAKFESNFNTQATNRNTDGSTDYGILQINSRWWCNDGRTPGSRNLCNIPCSALLSSDITASVNCAKKIVSDGNG' },
  ubiquitin: { name: 'Ubiquitin', seq: 'MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG' },
  gfp: { name: 'GFP Fragment', seq: 'MSKGEELFTGVVPILVELDGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVTTFSYGVQCFSRYPDHMKQ' },
  hemoglobin: { name: 'Hemoglobin Î±', seq: 'VLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSHGSAQVKGHGKKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFK' },
  collagen: { name: 'Collagen Fragment', seq: 'GPPGPPGPPGPPGPPGPPGPPGPPGPPGPPGPPGPPGPPGPPGPP' }
};

// ============================
// FEATURE EXTRACTION
// ============================

function extractFeatures(sequence) {
  const seq = sequence.toUpperCase().replace(/[^ACDEFGHIKLMNPQRSTVWY]/g, '');
  const len = seq.length;
  if (len === 0) return new Array(12).fill(0);

  // Hydrophobicity
  let totalHydro = 0;
  let totalCharge = 0;
  let charged = 0;
  let aromatic = 0;
  let polar = 0;
  const aaCounts = {};

  for (const aa of seq) {
    const props = AA_PROPERTIES[aa];
    if (!props) continue;
    totalHydro += props.hydro;
    totalCharge += Math.abs(props.charge);
    if (props.charge !== 0) charged++;
    if ('FWYH'.includes(aa)) aromatic++;
    if ('STNQCY'.includes(aa)) polar++;
    aaCounts[aa] = (aaCounts[aa] || 0) + 1;
  }

  const avgHydro = totalHydro / len;
  const chargeRatio = charged / len;
  const aromaticRatio = aromatic / len;
  const polarRatio = polar / len;

  // Complexity (Shannon entropy)
  let entropy = 0;
  for (const aa of Object.keys(aaCounts)) {
    const p = aaCounts[aa] / len;
    if (p > 0) entropy -= p * Math.log2(p);
  }
  const maxEntropy = Math.log2(20);
  const complexity = entropy / maxEntropy;

  // Disorder propensity (simplified)
  let disorder = 0;
  const disorderAA = 'DEKRSQNGTAH';
  for (const aa of seq) {
    if (disorderAA.includes(aa)) disorder++;
  }
  const disorderRatio = disorder / len;

  // Length feature (normalized)
  const lengthNorm = Math.min(len / 500, 1);

  // Hydrophobic patterns
  let maxHydroRun = 0, currentRun = 0;
  for (const aa of seq) {
    if (AA_PROPERTIES[aa] && AA_PROPERTIES[aa].hydro > 1.5) {
      currentRun++;
      maxHydroRun = Math.max(maxHydroRun, currentRun);
    } else {
      currentRun = 0;
    }
  }
  const hydroRunNorm = Math.min(maxHydroRun / 10, 1);

  // Proline content (affects folding)
  const prolineRatio = (aaCounts['P'] || 0) / len;

  // Cysteine content (disulfide bonds)
  const cysteineRatio = (aaCounts['C'] || 0) / len;

  // Medical relevance (heuristic)
  const medicalScore = (chargeRatio * 0.3 + aromaticRatio * 0.3 + cysteineRatio * 0.2 + complexity * 0.2);

  return [
    (avgHydro + 4.5) / 9,        // 0: normalized hydrophobicity [0,1]
    chargeRatio,                   // 1
    complexity,                    // 2
    disorderRatio,                 // 3
    lengthNorm,                    // 4
    aromaticRatio,                 // 5
    polarRatio,                    // 6
    hydroRunNorm,                  // 7
    prolineRatio,                  // 8
    cysteineRatio * 5,            // 9
    medicalScore,                  // 10
    Math.min(len / 200, 1)        // 11
  ];
}

function predictSecondaryStructure(sequence) {
  const seq = sequence.toUpperCase();
  const ss = [];
  for (let i = 0; i < seq.length; i++) {
    const aa = seq[i];
    const props = AA_PROPERTIES[aa];
    if (!props) { ss.push('C'); continue; }

    // Window-based prediction
    let helixScore = props.helix;
    let sheetScore = props.sheet;

    for (let w = -2; w <= 2; w++) {
      const idx = i + w;
      if (idx >= 0 && idx < seq.length && w !== 0) {
        const p = AA_PROPERTIES[seq[idx]];
        if (p) {
          helixScore += p.helix * 0.3;
          sheetScore += p.sheet * 0.3;
        }
      }
    }

    if (aa === 'P' || (i > 0 && seq[i-1] === 'G')) {
      ss.push('T');
    } else if (helixScore > sheetScore && helixScore > 1.2) {
      ss.push('H');
    } else if (sheetScore > 1.2) {
      ss.push('E');
    } else {
      ss.push('C');
    }
  }
  return ss;
}

// ============================
// NEURAL NETWORK INSTANCE
// ============================

const nn = new NeuralNetwork([12, 24, 16, 8, 1]);

function evaluateProtein(sequence) {
  const features = extractFeatures(sequence);
  const output = nn.forward(features);
  return {
    features,
    priorityScore: output[0],
    layerActivations: nn.layers.map(l => [...l.activations])
  };
}

// ============================
// 3D VISUALIZATION (Canvas-based)
// ============================

let canvas3d, ctx3d;
let proteinAtoms = [];
let bonds = [];
let cameraAngle = 0;
let cameraTilt = 0.3;
let cameraZoom = 1;
let isSpinning = true;
let isFolding = false;
let foldingStep = 0;
let maxFoldSteps = 1000;
let viewMode = 'backbone';
let energyHistory = [];
let currentEnergy = 0;
let dragStart = null;
let isDragging = false;
let currentSequence = '';
let secondaryStructure = [];

function initViewer() {
  canvas3d = document.getElementById('viewer3d');
  ctx3d = canvas3d.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  canvas3d.addEventListener('mousedown', e => {
    dragStart = { x: e.clientX, y: e.clientY, angle: cameraAngle, tilt: cameraTilt };
    isDragging = true;
  });
  canvas3d.addEventListener('mousemove', e => {
    if (!isDragging || !dragStart) return;
    cameraAngle = dragStart.angle + (e.clientX - dragStart.x) * 0.01;
    cameraTilt = Math.max(-1.5, Math.min(1.5, dragStart.tilt + (e.clientY - dragStart.y) * 0.01));
  });
  canvas3d.addEventListener('mouseup', () => isDragging = false);
  canvas3d.addEventListener('mouseleave', () => isDragging = false);
  canvas3d.addEventListener('wheel', e => {
    e.preventDefault();
    cameraZoom = Math.max(0.3, Math.min(3, cameraZoom - e.deltaY * 0.001));
  });

  animate();
}

function resizeCanvas() {
  const rect = canvas3d.parentElement.getBoundingClientRect();
  canvas3d.width = rect.width * window.devicePixelRatio;
  canvas3d.height = rect.height * window.devicePixelRatio;
  canvas3d.style.width = rect.width + 'px';
  canvas3d.style.height = rect.height + 'px';
  ctx3d.scale(window.devicePixelRatio, window.devicePixelRatio);
}

function generateProteinStructure(sequence) {
  const seq = sequence.toUpperCase().replace(/[^ACDEFGHIKLMNPQRSTVWY]/g, '');
  currentSequence = seq;
  secondaryStructure = predictSecondaryStructure(seq);
  proteinAtoms = [];
  bonds = [];
  energyHistory = [];
  foldingStep = 0;
  currentEnergy = 0;

  const n = seq.length;

  // Initial extended chain
  for (let i = 0; i < n; i++) {
    const aa = seq[i];
    const props = AA_PROPERTIES[aa] || AA_PROPERTIES['A'];
    proteinAtoms.push({
      x: (i - n/2) * 3.8,
      y: (Math.random() - 0.5) * 2,
      z: (Math.random() - 0.5) * 2,
      targetX: 0, targetY: 0, targetZ: 0,
      vx: 0, vy: 0, vz: 0,
      aa: aa,
      color: props.color,
      radius: viewMode === 'spacefill' ? (props.mw / 40) : 3,
      ss: secondaryStructure[i],
      index: i
    });
  }

  // Generate target folded structure
  generateFoldedTargets(seq, secondaryStructure);

  // Bonds
  for (let i = 0; i < n - 1; i++) {
    bonds.push([i, i + 1]);
  }

  // Disulfide bonds
  const cysteines = [];
  for (let i = 0; i < n; i++) {
    if (seq[i] === 'C') cysteines.push(i);
  }
  for (let i = 0; i < cysteines.length - 1; i += 2) {
    bonds.push([cysteines[i], cysteines[i+1]]);
  }

  // Calculate initial energy
  currentEnergy = calculateEnergy();
}

function generateFoldedTargets(seq, ss) {
  const n = seq.length;
  let x = 0, y = 0, z = 0;
  let phi = 0, psi = 0;

  for (let i = 0; i < n; i++) {
    const ssType = ss[i];

    if (ssType === 'H') {
      // Alpha helix parameters
      const helixRadius = 5;
      const helixPitch = 1.5;
      const t = i * (100 * Math.PI / 180);
      x = helixRadius * Math.cos(t);
      y = i * helixPitch;
      z = helixRadius * Math.sin(t);
    } else if (ssType === 'E') {
      // Beta sheet - zigzag
      x = i * 3.3;
      y = (i % 2 === 0) ? 3 : -3;
      z = Math.sin(i * 0.3) * 8;
    } else if (ssType === 'T') {
      // Turn
      const angle = i * 0.8;
      x = Math.cos(angle) * 8 + i * 1.5;
      y = Math.sin(angle) * 8;
      z = Math.cos(angle * 0.5) * 5;
    } else {
      // Coil - random walk
      phi += (Math.random() - 0.5) * 1.2;
      psi += (Math.random() - 0.5) * 0.8;
      x += Math.cos(phi) * 3.5;
      y += Math.sin(psi) * 3.5;
      z += Math.sin(phi + psi) * 2.5;
    }

    // Hydrophobic collapse - pull hydrophobic residues toward center
    const hydro = AA_PROPERTIES[seq[i]]?.hydro || 0;
    if (hydro > 1.5) {
      x *= 0.7;
      y *= 0.7;
      z *= 0.7;
    }

    proteinAtoms[i].targetX = x;
    proteinAtoms[i].targetY = y;
    proteinAtoms[i].targetZ = z;
  }

  // Center targets
  let cx = 0, cy = 0, cz = 0;
  for (const a of proteinAtoms) { cx += a.targetX; cy += a.targetY; cz += a.targetZ; }
  cx /= n; cy /= n; cz /= n;
  for (const a of proteinAtoms) {
    a.targetX -= cx; a.targetY -= cy; a.targetZ -= cz;
  }
}

function calculateEnergy() {
  let energy = 0;
  const n = proteinAtoms.length;

  // Bond energy
  for (const [i, j] of bonds) {
    const dx = proteinAtoms[i].x - proteinAtoms[j].x;
    const dy = proteinAtoms[i].y - proteinAtoms[j].y;
    const dz = proteinAtoms[i].z - proteinAtoms[j].z;
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    const idealDist = Math.abs(i - j) === 1 ? 3.8 : 5;
    energy += 0.5 * (dist - idealDist) ** 2;
  }

  // Lennard-Jones (simplified)
  for (let i = 0; i < n; i++) {
    for (let j = i + 2; j < Math.min(i + 8, n); j++) {
      const dx = proteinAtoms[i].x - proteinAtoms[j].x;
      const dy = proteinAtoms[i].y - proteinAtoms[j].y;
      const dz = proteinAtoms[i].z - proteinAtoms[j].z;
      const r2 = dx*dx + dy*dy + dz*dz + 1;
      const sigma6 = 1000 / (r2 * r2 * r2);
      energy += sigma6 * (sigma6 - 1);
    }
  }

  return -Math.abs(energy * 0.01 + foldingStep * 0.05);
}

function foldStep() {
  if (!isFolding || foldingStep >= maxFoldSteps) return;

  const progress = foldingStep / maxFoldSteps;
  const easeProgress = 1 - Math.pow(1 - progress, 3); // ease-out cubic
  const temperature = 300 * (1 - progress * 0.7);

  for (const atom of proteinAtoms) {
    // Interpolate toward target
    const tx = atom.targetX - atom.x;
    const ty = atom.targetY - atom.y;
    const tz = atom.targetZ - atom.z;

    // Spring force toward target
    const springK = 0.02 + easeProgress * 0.08;
    atom.vx += tx * springK;
    atom.vy += ty * springK;
    atom.vz += tz * springK;

    // Thermal noise
    const noise = (1 - easeProgress) * 0.5;
    atom.vx += (Math.random() - 0.5) * noise;
    atom.vy += (Math.random() - 0.5) * noise;
    atom.vz += (Math.random() - 0.5) * noise;

    // Damping
    const damping = 0.85;
    atom.vx *= damping;
    atom.vy *= damping;
    atom.vz *= damping;

    atom.x += atom.vx;
    atom.y += atom.vy;
    atom.z += atom.vz;
  }

  // Bond constraints
  for (const [i, j] of bonds) {
    if (Math.abs(i - j) !== 1) continue;
    const a = proteinAtoms[i], b = proteinAtoms[j];
    const dx = b.x - a.x, dy = b.y - a.y, dz = b.z - a.z;
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;
    const idealDist = 3.8;
    const correction = (dist - idealDist) / dist * 0.5;
    a.x += dx * correction;
    a.y += dy * correction;
    a.z += dz * correction;
    b.x -= dx * correction;
    b.y -= dy * correction;
    b.z -= dz * correction;
  }

  foldingStep++;
  currentEnergy = calculateEnergy();
  energyHistory.push(currentEnergy);

  document.getElementById('foldStep').textContent = `${foldingStep} / ${maxFoldSteps}`;
  document.getElementById('energyValue').textContent = currentEnergy.toFixed(2);
  document.getElementById('tempValue').textContent = `${temperature.toFixed(0)} K`;

  // RMSD
  let rmsd = 0;
  for (const a of proteinAtoms) {
    rmsd += (a.x - a.targetX)**2 + (a.y - a.targetY)**2 + (a.z - a.targetZ)**2;
  }
  rmsd = Math.sqrt(rmsd / proteinAtoms.length).toFixed(2);
  document.getElementById('rmsdValue').textContent = `${rmsd} Ã…`;

  drawEnergyChart();

  if (foldingStep >= maxFoldSteps) {
    isFolding = false;
    document.getElementById('btnFold').textContent = 'âœ“ Done';
    document.getElementById('statusText').textContent = 'Folding complete!';
    setTimeout(() => {
      document.getElementById('foldingStatus').classList.add('hidden');
      updateQueueItemStatus(currentSequence, 'complete');
    }, 2000);
    showToast('Folding simulation complete!');
  }
}

function project3D(x, y, z) {
  const cos = Math.cos(cameraAngle), sin = Math.sin(cameraAngle);
  const cosT = Math.cos(cameraTilt), sinT = Math.sin(cameraTilt);

  let rx = x * cos - z * sin;
  let ry = y;
  let rz = x * sin + z * cos;

  let ry2 = ry * cosT - rz * sinT;
  let rz2 = ry * sinT + rz * cosT;

  const fov = 400 * cameraZoom;
  const perspective = fov / (fov + rz2 + 200);

  const w = canvas3d.width / window.devicePixelRatio;
  const h = canvas3d.height / window.devicePixelRatio;

  return {
    x: w/2 + rx * perspective,
    y: h/2 + ry2 * perspective,
    z: rz2,
    scale: perspective
  };
}

function animate() {
  requestAnimationFrame(animate);

  if (isSpinning && !isDragging) {
    cameraAngle += 0.005;
  }

  if (isFolding) {
    foldStep();
  }

  render3D();
}

function render3D() {
  const w = canvas3d.width / window.devicePixelRatio;
  const h = canvas3d.height / window.devicePixelRatio;

  ctx3d.clearRect(0, 0, w, h);

  // Background
  const grad = ctx3d.createRadialGradient(w/2, h/2, 0, w/2, h/2, w*0.6);
  grad.addColorStop(0, '#111827');
  grad.addColorStop(1, '#0a0e17');
  ctx3d.fillStyle = grad;
  ctx3d.fillRect(0, 0, w, h);

  // Grid floor
  ctx3d.strokeStyle = 'rgba(42, 58, 85, 0.3)';
  ctx3d.lineWidth = 0.5;
  for (let i = -100; i <= 100; i += 20) {
    const p1 = project3D(i, 60, -100);
    const p2 = project3D(i, 60, 100);
    ctx3d.beginPath();
    ctx3d.moveTo(p1.x, p1.y);
    ctx3d.lineTo(p2.x, p2.y);
    ctx3d.stroke();

    const p3 = project3D(-100, 60, i);
    const p4 = project3D(100, 60, i);
    ctx3d.beginPath();
    ctx3d.moveTo(p3.x, p3.y);
    ctx3d.lineTo(p4.x, p4.y);
    ctx3d.stroke();
  }

  if (proteinAtoms.length === 0) {
    ctx3d.fillStyle = 'rgba(107, 127, 163, 0.5)';
    ctx3d.font = '16px system-ui';
    ctx3d.textAlign = 'center';
    ctx3d.fillText('Submit a protein sequence to begin simulation', w/2, h/2);
    return;
  }

  // Project all atoms
  const projected = proteinAtoms.map((atom, i) => ({
    ...project3D(atom.x, atom.y, atom.z),
    atom, index: i
  }));

  // Sort by z for painter's algorithm
  projected.sort((a, b) => a.z - b.z);

  // Draw bonds first
  if (viewMode !== 'spacefill') {
    for (const [i, j] of bonds) {
      const a = project3D(proteinAtoms[i].x, proteinAtoms[i].y, proteinAtoms[i].z);
      const b = project3D(proteinAtoms[j].x, proteinAtoms[j].y, proteinAtoms[j].z);

      const isDisulfide = Math.abs(i - j) !== 1;
      const depth = (a.z + b.z) / 2;
      const alpha = Math.max(0.1, Math.min(0.8, 1 - depth / 400));

      if (viewMode === 'ribbon') {
        const ss = proteinAtoms[i].ss;
        let color;
        if (ss === 'H') color = `rgba(239, 71, 111, ${alpha})`;
        else if (ss === 'E') color = `rgba(17, 138, 178, ${alpha})`;
        else if (ss === 'T') color = `rgba(255, 209, 102, ${alpha})`;
        else color = `rgba(107, 127, 163, ${alpha})`;

        ctx3d.strokeStyle = color;
        ctx3d.lineWidth = isDisulfide ? 1 : (ss === 'H' ? 6 : ss === 'E' ? 5 : 2) * a.scale;
      } else {
        ctx3d.strokeStyle = isDisulfide ?
          `rgba(255, 209, 102, ${alpha})` :
          `rgba(100, 140, 200, ${alpha * 0.8})`;
        ctx3d.lineWidth = isDisulfide ? 1.5 : 2 * a.scale;
      }

      if (isDisulfide) {
        ctx3d.setLineDash([4, 4]);
      } else {
        ctx3d.setLineDash([]);
      }

      ctx3d.beginPath();
      ctx3d.moveTo(a.x, a.y);

      if (viewMode === 'ribbon' && !isDisulfide) {
        // Smooth curves for ribbon
        const midX = (a.x + b.x) / 2;
        const midY = (a.y + b.y) / 2 - 2;
        ctx3d.quadraticCurveTo(midX, midY, b.x, b.y);
      } else {
        ctx3d.lineTo(b.x, b.y);
      }
      ctx3d.stroke();
    }
    ctx3d.setLineDash([]);
  }

  // Draw atoms
  for (const p of projected) {
    const alpha = Math.max(0.3, Math.min(1, 1 - p.z / 400));
    let radius;

    if (viewMode === 'spacefill') {
      radius = Math.max(2, (p.atom.radius || 3) * p.scale);
    } else if (viewMode === 'ribbon') {
      radius = Math.max(1, 2 * p.scale);
    } else {
      radius = Math.max(2, 3.5 * p.scale);
    }

    // Glow effect
    if (viewMode !== 'ribbon') {
      const glow = ctx3d.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 2);
      glow.addColorStop(0, p.atom.color + Math.round(alpha * 30).toString(16).padStart(2, '0'));
      glow.addColorStop(1, 'transparent');
      ctx3d.fillStyle = glow;
      ctx3d.beginPath();
      ctx3d.arc(p.x, p.y, radius * 2, 0, Math.PI * 2);
      ctx3d.fill();
    }

    // Atom sphere
    const gradient = ctx3d.createRadialGradient(
      p.x - radius * 0.3, p.y - radius * 0.3, 0,
      p.x, p.y, radius
    );
    gradient.addColorStop(0, lightenColor(p.atom.color, 40));
    gradient.addColorStop(0.7, p.atom.color);
    gradient.addColorStop(1, darkenColor(p.atom.color, 40));

    ctx3d.globalAlpha = alpha;
    ctx3d.fillStyle = gradient;
    ctx3d.beginPath();
    ctx3d.arc(p.x, p.y, radius, 0, Math.PI * 2);
    ctx3d.fill();
    ctx3d.globalAlpha = 1;
  }
}

function lightenColor(hex, amount) {
  const num = parseInt(hex.replace('#',''), 16);
  const r = Math.min(255, (num >> 16) + amount);
  const g = Math.min(255, ((num >> 8) & 0xff) + amount);
  const b = Math.min(255, (num & 0xff) + amount);
  return `rgb(${r},${g},${b})`;
}

function darkenColor(hex, amount) {
  const num = parseInt(hex.replace('#',''), 16);
  const r = Math.max(0, (num >> 16) - amount);
  const g = Math.max(0, ((num >> 8) & 0xff) - amount);
  const b = Math.max(0, (num & 0xff) - amount);
  return `rgb(${r},${g},${b})`;
}

// ============================
// ENERGY & RAMA CHARTS
// ============================

function drawEnergyChart() {
  const canvas = document.getElementById('energyChart');
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.parentElement.clientWidth - 24;
  const h = canvas.height = 120;

  ctx.clearRect(0, 0, w, h);

  if (energyHistory.length < 2) return;

  const min = Math.min(...energyHistory);
  const max = Math.max(...energyHistory);
  const range = max - min || 1;

  // Grid
  ctx.strokeStyle = 'rgba(42, 58, 85, 0.5)';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 4; i++) {
    const y = (i / 4) * h;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }

  // Line
  const grad = ctx.createLinearGradient(0, 0, w, 0);
  grad.addColorStop(0, '#ef476f');
  grad.addColorStop(0.5, '#ffd166');
  grad.addColorStop(1, '#06d6a0');

  ctx.strokeStyle = grad;
  ctx.lineWidth = 2;
  ctx.beginPath();

  const step = w / Math.max(energyHistory.length - 1, 1);
  for (let i = 0; i < energyHistory.length; i++) {
    const x = i * step;
    const y = h - ((energyHistory[i] - min) / range) * (h - 10) - 5;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Fill under
  ctx.lineTo(w, h);
  ctx.lineTo(0, h);
  ctx.closePath();
  const fillGrad = ctx.createLinearGradient(0, 0, 0, h);
  fillGrad.addColorStop(0, 'rgba(6, 214, 160, 0.2)');
  fillGrad.addColorStop(1, 'rgba(6, 214, 160, 0)');
  ctx.fillStyle = fillGrad;
  ctx.fill();
}

function drawRamachandranPlot() {
  const canvas = document.getElementById('ramaChart');
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.parentElement.clientWidth - 24;
  const h = canvas.height = 150;

  ctx.clearRect(0, 0, w, h);

  // Background
  ctx.fillStyle = 'rgba(26, 34, 53, 0.5)';
  ctx.fillRect(0, 0, w, h);

  // Grid
  ctx.strokeStyle = 'rgba(42, 58, 85, 0.5)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h);
  ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
  ctx.stroke();

  // Labels
  ctx.fillStyle = 'rgba(107, 127, 163, 0.7)';
  ctx.font = '9px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Ï†', w/2, h - 3);
  ctx.fillText('-180Â°', 3, h - 3);
  ctx.fillText('180Â°', w - 3, h - 3);
  ctx.save();
  ctx.translate(10, h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText('Ïˆ', 0, 0);
  ctx.restore();

  // Allowed regions (simplified)
  ctx.fillStyle = 'rgba(6, 214, 160, 0.08)';
  ctx.fillRect(w*0.05, h*0.05, w*0.35, h*0.35); // alpha-helix region
  ctx.fillRect(w*0.5, h*0.05, w*0.35, h*0.25);  // beta-sheet region

  ctx.fillStyle = 'rgba(107, 127, 163, 0.3)';
  ctx.font = '8px system-ui';
  ctx.fillText('Î±', w*0.22, h*0.25);
  ctx.fillText('Î²', w*0.67, h*0.18);

  // Plot points
  for (let i = 0; i < proteinAtoms.length; i++) {
    const ss = proteinAtoms[i].ss;
    let phi, psi;

    if (ss === 'H') {
      phi = -60 + (Math.random() - 0.5) * 30;
      psi = -45 + (Math.random() - 0.5) * 30;
    } else if (ss === 'E') {
      phi = -120 + (Math.random() - 0.5) * 40;
      psi = 130 + (Math.random() - 0.5) * 40;
    } else {
      phi = (Math.random() - 0.5) * 360;
      psi = (Math.random() - 0.5) * 360;
    }

    const px = ((phi + 180) / 360) * w;
    const py = ((psi + 180) / 360) * h;

    let color;
    if (ss === 'H') color = 'rgba(239, 71, 111, 0.7)';
    else if (ss === 'E') color = 'rgba(17, 138, 178, 0.7)';
    else if (ss === 'T') color = 'rgba(255, 209, 102, 0.7)';
    else color = 'rgba(107, 127, 163, 0.5)';

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(px, py, 2.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ============================
// NN VISUALIZATION
// ============================

function drawNNVisualization(activations) {
  const canvas = document.getElementById('nnVis');
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.parentElement.clientWidth - 24;
  const h = canvas.height = 160;

  ctx.clearRect(0, 0, w, h);

  const layers = [12, 24, 16, 8, 1];
  const layerNames = ['Input', 'Hidden 1', 'Hidden 2', 'Hidden 3', 'Output'];
  const layerX = layers.map((_, i) => 40 + (i / (layers.length - 1)) * (w - 80));

  // Draw connections first
  for (let l = 0; l < layers.length - 1; l++) {
    const n1 = Math.min(layers[l], 12);
    const n2 = Math.min(layers[l+1], 12);

    for (let i = 0; i < n1; i++) {
      for (let j = 0; j < n2; j++) {
        const y1 = 20 + (i / Math.max(n1 - 1, 1)) * (h - 45);
        const y2 = 20 + (j / Math.max(n2 - 1, 1)) * (h - 45);

        let act = 0.1;
        if (activations && activations[l]) {
          act = Math.min(1, (activations[l][j % activations[l].length] || 0));
        }

        ctx.strokeStyle = `rgba(6, 214, 160, ${act * 0.3})`;
        ctx.lineWidth = act * 1.5;
        ctx.beginPath();
        ctx.moveTo(layerX[l], y1);
        ctx.lineTo(layerX[l+1], y2);
        ctx.stroke();
      }
    }
  }

  // Draw nodes
  for (let l = 0; l < layers.length; l++) {
    const n = Math.min(layers[l], 12);
    for (let i = 0; i < n; i++) {
      const y = 20 + (i / Math.max(n - 1, 1)) * (h - 45);

      let act = 0.3;
      if (l === 0) {
        act = 0.5;
      } else if (activations && activations[l-1]) {
        act = Math.min(1, (activations[l-1][i % activations[l-1].length] || 0));
      }

      // Glow
      const glow = ctx.createRadialGradient(layerX[l], y, 0, layerX[l], y, 8);
      glow.addColorStop(0, `rgba(6, 214, 160, ${act * 0.3})`);
      glow.addColorStop(1, 'transparent');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(layerX[l], y, 8, 0, Math.PI * 2);
      ctx.fill();

      // Node
      ctx.fillStyle = `rgba(6, 214, 160, ${0.3 + act * 0.7})`;
      ctx.beginPath();
      ctx.arc(layerX[l], y, 3.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = `rgba(6, 214, 160, ${0.5 + act * 0.5})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    if (layers[l] > 12) {
      const y = 20 + (11 / 11) * (h - 45);
      ctx.fillStyle = 'rgba(107, 127, 163, 0.5)';
      ctx.font = '8px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(`+${layers[l] - 12}`, layerX[l], y + 14);
    }

    // Layer label
    ctx.fillStyle = 'rgba(107, 127, 163, 0.7)';
    ctx.font = '8px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(layerNames[l], layerX[l], h - 2);
  }
}

// ============================
// UI FUNCTIONS
// ============================

let queue = [];
let queueIdCounter = 0;

function submitProtein() {
  const name = document.getElementById('proteinName').value.trim() || 'Unnamed Protein';
  const seq = document.getElementById('sequenceInput').value.trim().toUpperCase().replace(/[^ACDEFGHIKLMNPQRSTVWY]/g, '');

  if (seq.length < 5) {
    showToast('Please enter a valid sequence (at least 5 amino acids)');
    return;
  }

  // Run NN analysis
  const result = evaluateProtein(seq);
  const priority = result.priorityScore;

  // Update UI features
  updateFeatureDisplay(result.features);
  updateNNDisplay(result);
  updateSecondaryStructureDisplay(seq);
  updateConfidenceMap(seq);

  // Add to queue
  const item = {
    id: queueIdCounter++,
    name,
    sequence: seq,
    priority,
    status: 'queued',
    progress: 0
  };

  queue.push(item);
  queue.sort((a, b) => b.priority - a.priority);
  renderQueue();

  // Start folding the highest priority
  startFolding(queue[0]);

  showToast(`"${name}" analyzed â€” Priority: ${(priority * 100).toFixed(1)}%`);
}

function updateFeatureDisplay(features) {
  const names = ['hydro', 'charge', 'complex', 'disorder', 'medical'];
  const indices = [0, 1, 2, 3, 10];

  for (let i = 0; i < names.length; i++) {
    const val = features[indices[i]];
    document.getElementById(`feat-${names[i]}`).textContent = val.toFixed(3);
    document.getElementById(`bar-${names[i]}`).style.width = `${Math.min(val * 100, 100)}%`;
  }
}

function updateNNDisplay(result) {
  document.getElementById('priorityScore').textContent = (result.priorityScore * 100).toFixed(1) + '%';
  document.getElementById('priorityScore').style.color =
    result.priorityScore > 0.7 ? '#ef476f' :
    result.priorityScore > 0.4 ? '#ffd166' : '#06d6a0';

  drawNNVisualization(result.layerActivations);
}

function updateSecondaryStructureDisplay(seq) {
  const ss = predictSecondaryStructure(seq);
  const bar = document.getElementById('ssBar');
  bar.innerHTML = '';

  let counts = { H: 0, E: 0, T: 0, C: 0 };
  for (const s of ss) counts[s]++;

  for (const s of ss) {
    const div = document.createElement('div');
    div.style.flex = '1';
    div.className = s === 'H' ? 'ss-helix' : s === 'E' ? 'ss-sheet' : s === 'T' ? 'ss-turn' : 'ss-coil';
    bar.appendChild(div);
  }

  const total = ss.length;
  document.getElementById('ssPercentages').textContent =
    `Helix: ${(counts.H/total*100).toFixed(1)}% | Sheet: ${(counts.E/total*100).toFixed(1)}% | Turn: ${(counts.T/total*100).toFixed(1)}% | Coil: ${(counts.C/total*100).toFixed(1)}%`;
}

function updateConfidenceMap(seq) {
  const meter = document.getElementById('confMeter');
  meter.innerHTML = '';

  // Generate per-residue confidence
  let veryHigh = 0, high = 0, med = 0, low = 0;
  for (let i = 0; i < seq.length; i++) {
    const aa = seq[i];
    const props = AA_PROPERTIES[aa];
    if (!props) continue;

    // Confidence heuristic based on secondary structure propensity
    const conf = (props.helix + props.sheet) / 2;
    if (conf > 1.3) veryHigh++;
    else if (conf > 1.0) high++;
    else if (conf > 0.7) med++;
    else low++;
  }

  const total = seq.length;
  const segments = [
    { cls: 'conf-very-high', pct: veryHigh/total*100 },
    { cls: 'conf-high', pct: high/total*100 },
    { cls: 'conf-medium', pct: med/total*100 },
    { cls: 'conf-low', pct: low/total*100 },
  ];

  for (const seg of segments) {
    if (seg.pct > 0) {
      const div = document.createElement('div');
      div.className = `conf-segment ${seg.cls}`;
      div.style.width = `${seg.pct}%`;
      meter.appendChild(div);
    }
  }
}

function startFolding(item) {
  if (!item) return;

  generateProteinStructure(item.sequence);

  document.getElementById('viewerProteinName').textContent = item.name;
  document.getElementById('residueCount').textContent = item.sequence.length;
  document.getElementById('foldStep').textContent = `0 / ${maxFoldSteps}`;
  document.getElementById('energyValue').textContent = '0.00';
  document.getElementById('rmsdValue').textContent = '--';

  document.getElementById('foldingStatus').classList.remove('hidden');
  document.getElementById('statusText').textContent = `Folding "${item.name}"...`;

  drawRamachandranPlot();

  isFolding = true;
  document.getElementById('btnFold').textContent = 'â¸ Pause';

  item.status = 'folding';
  renderQueue();
}

function renderQueue() {
  const container = document.getElementById('queueContainer');
  container.innerHTML = '';

  for (const item of queue) {
    const div = document.createElement('div');
    div.className = `queue-item ${item.status === 'folding' ? 'active' : ''}`;
    div.onclick = () => {
      if (item.status !== 'folding') startFolding(item);
    };

    const priorityClass = item.priority > 0.7 ? 'priority-high' :
                          item.priority > 0.4 ? 'priority-medium' : 'priority-low';
    const priorityLabel = item.priority > 0.7 ? 'HIGH' :
                          item.priority > 0.4 ? 'MEDIUM' : 'LOW';

    const statusIcon = item.status === 'complete' ? 'âœ“' :
                       item.status === 'folding' ? 'âŸ³' : 'â—‹';

    div.innerHTML = `
      <div class="q-name">${statusIcon} ${item.name}</div>
      <div class="q-meta">
        <span>${item.sequence.length} residues</span>
        <span class="priority-badge ${priorityClass}">${priorityLabel} ${(item.priority * 100).toFixed(0)}%</span>
      </div>
      <div class="q-progress">
        <div class="q-progress-bar" style="width:${item.status === 'complete' ? 100 : item.status === 'folding' ? (foldingStep/maxFoldSteps*100) : 0}%"></div>
      </div>
    `;
    container.appendChild(div);
  }
}

function updateQueueItemStatus(seq, status) {
  for (const item of queue) {
    if (item.sequence === seq || item.status === 'folding') {
      item.status = status;
    }
  }
  renderQueue();
}

// Update queue progress periodically
setInterval(() => {
  if (isFolding) renderQueue();
}, 1000);

function loadPreset(key) {
  if (key === 'random') {
    const aas = 'ACDEFGHIKLMNPQRSTVWY';
    const len = 30 + Math.floor(Math.random() * 70);
    let seq = '';
    for (let i = 0; i < len; i++) seq += aas[Math.floor(Math.random() * aas.length)];
    document.getElementById('proteinName').value = `Random Protein (${len}aa)`;
    document.getElementById('sequenceInput').value = seq;
  } else {
    const preset = PRESETS[key];
    document.getElementById('proteinName').value = preset.name;
    document.getElementById('sequenceInput').value = preset.seq;
  }
}

function toggleSpin() {
  isSpinning = !isSpinning;
  document.getElementById('btnSpin').classList.toggle('active');
}

function setViewMode(mode) {
  viewMode = mode;
  document.getElementById('btnBackbone').classList.toggle('active', mode === 'backbone');
  document.getElementById('btnRibbon').classList.toggle('active', mode === 'ribbon');
  document.getElementById('btnSpacefill').classList.toggle('active', mode === 'spacefill');

  // Update atom radii
  for (const atom of proteinAtoms) {
    const props = AA_PROPERTIES[atom.aa];
    atom.radius = mode === 'spacefill' ? (props?.mw || 100) / 40 : 3;
  }
}

function resetCamera() {
  cameraAngle = 0;
  cameraTilt = 0.3;
  cameraZoom = 1;
}

function toggleFolding() {
  if (proteinAtoms.length === 0) {
    showToast('Submit a protein sequence first');
    return;
  }

  if (foldingStep >= maxFoldSteps) {
    // Reset and refold
    foldingStep = 0;
    energyHistory = [];
    const n = proteinAtoms.length;
    for (let i = 0; i < n; i++) {
      proteinAtoms[i].x = (i - n/2) * 3.8;
      proteinAtoms[i].y = (Math.random() - 0.5) * 2;
      proteinAtoms[i].z = (Math.random() - 0.5) * 2;
      proteinAtoms[i].vx = 0;
      proteinAtoms[i].vy = 0;
      proteinAtoms[i].vz = 0;
    }
    isFolding = true;
    document.getElementById('btnFold').textContent = 'â¸ Pause';
    document.getElementById('foldingStatus').classList.remove('hidden');
    document.getElementById('statusText').textContent = 'Re-folding...';
    return;
  }

  isFolding = !isFolding;
  document.getElementById('btnFold').textContent = isFolding ? 'â¸ Pause' : 'â–¶ Fold';

  if (isFolding) {
    document.getElementById('foldingStatus').classList.remove('hidden');
    document.getElementById('statusText').textContent = 'Folding in progress...';
  }
}

function showToast(message) {
  const existing = document.querySelector('.toast');
  if (existing) existing.remove();

  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), 3000);
}

function showTab(tab) {
  document.querySelectorAll('nav a').forEach(a => a.classList.remove('active'));
  event.target.classList.add('active');
  // In a full app, this would switch views
}

// ============================
// INITIALIZATION
// ============================

window.addEventListener('DOMContentLoaded', () => {
  initViewer();

  // Load default protein
  setTimeout(() => {
    submitProtein();
  }, 500);
});
</script>
</body>
</html>
