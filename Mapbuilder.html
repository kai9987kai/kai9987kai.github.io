<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Creative Canvas</title>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: Arial, sans-serif;
    }
    .sidebar {
      width: 250px;
      background-color: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    .sidebar h2 {
      text-align: center;
      margin-top: 0;
    }
    .tool-button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      background-color: #34495e;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }
    .tool-button.active {
      background-color: #1abc9c;
    }
    .tool-button:hover {
      background-color: #1abc9c;
    }
    .color-picker, .background-color-picker, .stroke-width-picker {
      margin: 10px 0;
    }
    .color-picker label, .background-color-picker label, .stroke-width-picker label {
      display: block;
      margin-bottom: 5px;
    }
    .label-input-container {
      margin: 10px 0;
    }
    .label-input-container label {
      display: block;
      margin-bottom: 5px;
    }
    .label-input-container input {
      width: 100%;
      padding: 5px;
      margin-bottom: 5px;
      box-sizing: border-box;
    }
    .label-input-container button {
      width: 100%;
      padding: 10px;
      background-color: #e74c3c;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
    }
    .label-input-container button:hover {
      background-color: #c0392b;
    }
    .emoji-picker {
      display: flex;
      flex-wrap: wrap;
      margin: 10px 0;
    }
    .emoji-btn {
      font-size: 24px;
      padding: 5px;
      margin: 3px;
      cursor: pointer;
      border: none;
      background: none;
    }
    .emoji-btn:hover {
      background-color: #34495e;
      border-radius: 4px;
    }
    .grid-toggle {
      margin: 10px 0;
    }
    .grid-toggle input {
      margin-right: 5px;
    }
    .action-buttons {
      margin: 10px 0;
    }
    .action-buttons button {
      width: 30%;
      padding: 10px;
      margin: 1%;
      background-color: #16a085;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
    }
    .action-buttons button:hover {
      background-color: #1abc9c;
    }
    .layer-list {
      margin-top: 20px;
    }
    .layer-list h3 {
      margin-bottom: 10px;
    }
    .layer-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #34495e;
      padding: 5px;
      margin-bottom: 5px;
      border-radius: 4px;
    }
    .layer-controls button {
      background: none;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      margin-left: 5px;
      font-size: 16px;
    }
    .layer-controls button:hover {
      color: #1abc9c;
    }
    .canvas-container {
      flex-grow: 1;
      position: relative;
      background-color: #ffffff;
    }
    #mainCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .tooltip {
      position: absolute;
      background-color: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      font-size: 14px;
    }
    .sparkles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 5;
    }
    .sparkle {
      position: absolute;
      width: 5px;
      height: 5px;
      background: yellow;
      border-radius: 50%;
      animation: sparkle 1s forwards;
    }
    @keyframes sparkle {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(2); opacity: 0; }
    }
    /* Alignment Tools Styling */
    .alignment-tools {
      margin: 10px 0;
    }
    .alignment-tools button {
      width: 48%;
      padding: 10px;
      margin: 1%;
      background-color: #2980b9;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 14px;
    }
    .alignment-tools button:hover {
      background-color: #3498db;
    }
    /* "What's New" Popup Styles */
    #whatsNewPopup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }
    #whatsNewPopup .popup-content {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      max-width: 400px;
      text-align: center;
      position: relative;
    }
    #whatsNewPopup .popup-content h2 {
      margin-top: 0;
    }
    #whatsNewPopup .close-popup {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #e74c3c;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 25px;
      height: 25px;
      cursor: pointer;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <div class="sidebar">
    <h2>Tools</h2>
    <button id="freeDrawBtn" class="tool-button">âœï¸ Free Draw</button>
    <button id="contourBtn" class="tool-button">ğŸ–‹ï¸ Contour Maker</button>
    <button id="rectangleBtn" class="tool-button">â–­ Rectangle</button>
    <button id="circleBtn" class="tool-button">âšª Circle</button>
    <button id="lineBtn" class="tool-button">â– Line</button>
    <button id="rulerBtn" class="tool-button">ğŸ“ Ruler</button>
    <button id="roadPenBtn" class="tool-button">ğŸ›£ï¸ Road Pen</button>
    <button id="cornerPenBtn" class="tool-button">ğŸ”² Corner Pen</button>
    <button id="moveBtn" class="tool-button">ğŸšš Move</button>
    <button id="selectBtn" class="tool-button">ğŸ”˜ Select</button>
    <button id="resizeBtn" class="tool-button">â†•ï¸ Resize</button>
    <button id="rotateBtn" class="tool-button">ğŸ”„ Rotate</button>
    <!-- New Tools -->
    <button id="eraserBtn" class="tool-button">ğŸ§½ Eraser</button>
    <button id="textBtn" class="tool-button">ğŸ…°ï¸ Text</button>
    
    <!-- Alignment Tools -->
    <div class="alignment-tools">
      <h3>Align Tools</h3>
      <button id="alignLeftBtn">â¬…ï¸ Align Left</button>
      <button id="alignCenterBtn">â¡ï¸ Align Center</button>
      <button id="alignRightBtn">â¬†ï¸ Align Right</button>
      <button id="alignTopBtn">ğŸ”¼ Align Top</button>
      <button id="alignMiddleBtn">ğŸ”½ Align Middle</button>
      <button id="alignBottomBtn">ğŸ”» Align Bottom</button>
    </div>
    
    <div class="color-picker">
      <label for="strokeColorPicker">Stroke Color:</label>
      <input type="color" id="strokeColorPicker" value="#000000">
    </div>
    <div class="color-picker">
      <label for="fillColorPicker">Fill Color:</label>
      <input type="color" id="fillColorPicker" value="#ffffff">
    </div>
    <div class="background-color-picker">
      <label for="backgroundColorPicker">Background Color:</label>
      <input type="color" id="backgroundColorPicker" value="#ffffff">
    </div>
    <div class="stroke-width-picker">
      <label for="strokeWidth">Stroke Width:</label>
      <input type="range" id="strokeWidth" min="1" max="10" value="2">
    </div>
    
    <div class="label-input-container">
      <label for="labelInput">Add Label:</label>
      <input type="text" id="labelInput" placeholder="Enter text">
      <label for="labelColorPicker">Label Color:</label>
      <input type="color" id="labelColorPicker" value="#000000">
      <button id="addLabelBtn">â• Add Label</button>
      <div class="sparkles" id="sparklesContainer"></div>
    </div>
    
    <div class="emoji-picker">
      <button class="emoji-btn" data-emoji="ğŸš§">ğŸš§</button>
      <button class="emoji-btn" data-emoji="ğŸ›£ï¸">ğŸ›£ï¸</button>
      <button class="emoji-btn" data-emoji="ğŸ…¿ï¸">ğŸ…¿ï¸</button>
      <button class="emoji-btn" data-emoji="ğŸš¦">ğŸš¦</button>
      <button class="emoji-btn" data-emoji="â›½">â›½</button>
      <button class="emoji-btn" data-emoji="ğŸš¸">ğŸš¸</button>
      <button class="emoji-btn" data-emoji="ğŸš">ğŸš</button>
      <button class="emoji-btn" data-emoji="ğŸš—">ğŸš—</button>
      <button class="emoji-btn" data-emoji="ğŸ›‘">ğŸ›‘</button>
      <button class="emoji-btn" data-emoji="ğŸš¨">ğŸš¨</button>
      <button class="emoji-btn" data-emoji="ğŸš¥">ğŸš¥</button>
      <button class="emoji-btn" data-emoji="ğŸ›¤ï¸">ğŸ›¤ï¸</button>
      <button class="emoji-btn" data-emoji="ğŸš€">ğŸš€</button>
      <button class="emoji-btn" data-emoji="ğŸ›©ï¸">ğŸ›©ï¸</button>
    </div>
    
    <div class="grid-toggle">
      <input type="checkbox" id="gridToggle">
      <label for="gridToggle">Toggle Grid</label>
    </div>
    
    <div class="action-buttons">
      <button id="undoBtn">â†©ï¸ Undo</button>
      <button id="redoBtn">â†ªï¸ Redo</button>
      <button id="clearBtn">ğŸ§¹ Clear Canvas</button>
      <button id="exportBtn">ğŸ“¤ Export as PNG</button>
      <button id="saveCanvasBtn">ğŸ’¾ Save Canvas</button>
      <button id="loadCanvasBtn">ğŸ“¥ Load Canvas</button>
    </div>
    
    <div class="layer-list">
      <h3>Layers</h3>
      <div id="layerList">
        <!-- Layer items will be appended here -->
      </div>
    </div>
  </div>
  
  <!-- Canvas Container -->
  <div class="canvas-container">
    <canvas id="mainCanvas"></canvas>
    <div id="tooltip" class="tooltip"></div>
    <div class="sparkles" id="sparklesContainer"></div>
  </div>
  
  <!-- What's New Popup -->
  <div id="whatsNewPopup">
    <div class="popup-content">
      <button class="close-popup">&times;</button>
      <h2>What's New</h2>
      <p>Welcome to the latest version of Advanced Creative Canvas!<br>
      - Save and load your canvas using local storage.<br>
      - Improved draggable handles for rotate and resize.<br>
      - New "What's New" popup feature! Enjoy your creative session!</p>
    </div>
  </div>
  
  <script>
    // Helper: Rotate a point around a center by angle (radians)
    function rotatePoint(point, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: center.x + (point.x - center.x) * cos - (point.y - center.y) * sin,
        y: center.y + (point.x - center.x) * sin + (point.y - center.y) * cos
      };
    }
    
    function getRotatedCorners(shape) {
      const center = { x: shape.x + shape.width/2, y: shape.y + shape.height/2 };
      return {
        topLeft: rotatePoint({ x: shape.x, y: shape.y }, center, shape.rotation),
        topRight: rotatePoint({ x: shape.x + shape.width, y: shape.y }, center, shape.rotation),
        bottomLeft: rotatePoint({ x: shape.x, y: shape.y + shape.height }, center, shape.rotation),
        bottomRight: rotatePoint({ x: shape.x + shape.width, y: shape.y + shape.height }, center, shape.rotation)
      };
    }
    
    class AdvancedDrawingTool {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.shapes = [];
        this.history = [];
        this.historyIndex = -1;
        this.currentTool = 'freeDraw';
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.currentShape = null;
        this.moveOffsetX = 0;
        this.moveOffsetY = 0;
        this.selectedShape = null;
        this.isMoving = false;
        this.isResizing = false;
        this.isRotating = false;
        this.labelColor = '#000000';
        this.shiftPressed = false;
        this.tooltip = document.getElementById('tooltip');
        this.sparklesContainer = document.getElementById('sparklesContainer');
        this.gridEnabled = false;
        // For rotated shapes
        this.initialMouseAngle = 0;
        this.initialRotation = 0;
        this.resizeFixedCorner = null;
        this.resizeHandle = null;
        
        this.setupCanvas();
        this.saveState();
        this.initializeListeners();
        this.checkWhatsNewPopup();
      }
      
      setupCanvas() {
        this.resizeCanvas();
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.strokeStyle = document.getElementById('strokeColorPicker').value;
        this.ctx.fillStyle = document.getElementById('fillColorPicker').value;
        this.ctx.lineWidth = document.getElementById('strokeWidth').value;
        this.canvas.style.backgroundColor = document.getElementById('backgroundColorPicker').value;
      }
      
      initializeListeners() {
        // Tool Buttons
        document.getElementById('freeDrawBtn').addEventListener('click', () => this.setTool('freeDraw'));
        document.getElementById('contourBtn').addEventListener('click', () => this.setTool('contour'));
        document.getElementById('rectangleBtn').addEventListener('click', () => this.setTool('rectangle'));
        document.getElementById('circleBtn').addEventListener('click', () => this.setTool('circle'));
        document.getElementById('lineBtn').addEventListener('click', () => this.setTool('line'));
        document.getElementById('rulerBtn').addEventListener('click', () => this.setTool('ruler'));
        document.getElementById('roadPenBtn').addEventListener('click', () => this.setTool('roadPen'));
        document.getElementById('cornerPenBtn').addEventListener('click', () => this.setTool('cornerPen'));
        document.getElementById('moveBtn').addEventListener('click', () => this.setTool('move'));
        document.getElementById('selectBtn').addEventListener('click', () => this.setTool('select'));
        document.getElementById('resizeBtn').addEventListener('click', () => this.setTool('resize'));
        document.getElementById('rotateBtn').addEventListener('click', () => this.setTool('rotate'));
        document.getElementById('eraserBtn').addEventListener('click', () => this.setTool('eraser'));
        document.getElementById('textBtn').addEventListener('click', () => this.setTool('text'));
        
        // Alignment Tools
        document.getElementById('alignLeftBtn').addEventListener('click', () => this.alignShape('left'));
        document.getElementById('alignCenterBtn').addEventListener('click', () => this.alignShape('center'));
        document.getElementById('alignRightBtn').addEventListener('click', () => this.alignShape('right'));
        document.getElementById('alignTopBtn').addEventListener('click', () => this.alignShape('top'));
        document.getElementById('alignMiddleBtn').addEventListener('click', () => this.alignShape('middle'));
        document.getElementById('alignBottomBtn').addEventListener('click', () => this.alignShape('bottom'));
        
        // Color and Stroke
        document.getElementById('strokeColorPicker').addEventListener('change', (e) => {
          this.ctx.strokeStyle = e.target.value;
          if(this.selectedShape) { this.selectedShape.strokeColor = e.target.value; this.saveState(); this.render(); }
        });
        document.getElementById('fillColorPicker').addEventListener('change', (e) => {
          this.ctx.fillStyle = e.target.value;
          if(this.selectedShape && ['rectangle','circle','contour'].includes(this.selectedShape.type)) {
            this.selectedShape.fillColor = e.target.value; this.saveState(); this.render();
          }
        });
        document.getElementById('backgroundColorPicker').addEventListener('change', (e) => {
          this.canvas.style.backgroundColor = e.target.value; this.saveState(); this.render();
        });
        document.getElementById('strokeWidth').addEventListener('input', (e) => {
          this.ctx.lineWidth = e.target.value;
          if(this.selectedShape) { this.selectedShape.lineWidth = e.target.value; this.saveState(); this.render(); }
        });
        
        // Emoji Picker
        document.querySelector('.emoji-picker').addEventListener('click', (e) => {
          if(e.target.classList.contains('emoji-btn')) { this.selectEmoji(e.target.getAttribute('data-emoji')); }
        });
        
        // Label Handling
        document.getElementById('addLabelBtn').addEventListener('click', () => this.addLabel());
        document.getElementById('labelColorPicker').addEventListener('change', (e) => { this.labelColor = e.target.value; });
        
        // Canvas Mouse Events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('mouseout', (e) => this.onMouseUp(e));
        
        // Action Buttons
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('redoBtn').addEventListener('click', () => this.redo());
        document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas());
        document.getElementById('exportBtn').addEventListener('click', () => this.exportCanvas());
        document.getElementById('saveCanvasBtn').addEventListener('click', () => this.saveCanvasToLocalStorage());
        document.getElementById('loadCanvasBtn').addEventListener('click', () => this.loadCanvasFromLocalStorage());
        
        // Grid Toggle
        document.getElementById('gridToggle').addEventListener('change', (e) => { this.gridEnabled = e.target.checked; this.render(); });
        
        // Window Resize
        window.addEventListener('resize', () => this.resizeCanvas());
        
        // Keyboard for Shift
        window.addEventListener('keydown', (e) => { if(e.key === 'Shift') this.shiftPressed = true; });
        window.addEventListener('keyup', (e) => { if(e.key === 'Shift') this.shiftPressed = false; });
        
        // Tooltip Handling
        this.canvas.addEventListener('mousemove', (e) => this.handleTooltip(e));
        this.canvas.addEventListener('mouseleave', () => this.hideTooltip());
        
        // Sparkles for label input
        document.getElementById('labelInput').addEventListener('input', () => this.showSparkles());
        document.getElementById('labelInput').addEventListener('focus', () => this.showSparkles());
        document.getElementById('labelInput').addEventListener('blur', () => this.hideSparkles());
        
        // "What's New" Popup Close Button
        document.querySelector('#whatsNewPopup .close-popup').addEventListener('click', () => {
          document.getElementById('whatsNewPopup').style.display = 'none';
          localStorage.setItem('whatsNewSeen', 'true');
        });
      }
      
      resizeCanvas() {
        const parentWidth = this.canvas.parentElement.clientWidth;
        const parentHeight = this.canvas.parentElement.clientHeight;
        if(parentWidth === 0 || parentHeight === 0) return;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;
        tempCtx.drawImage(this.canvas, 0, 0);
        this.canvas.width = parentWidth;
        this.canvas.height = parentHeight;
        this.ctx.drawImage(tempCanvas, 0, 0);
        this.render();
      }
      
      setTool(tool) {
        this.currentTool = tool;
        this.selectedShape = null;
        this.moveOffsetX = 0;
        this.moveOffsetY = 0;
        this.isMoving = false;
        this.isResizing = false;
        this.isRotating = false;
        this.resizeHandle = null;
        this.resizeFixedCorner = null;
        document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`${tool}Btn`)?.classList.add('active');
        this.render();
        console.log(`Tool set to: ${tool}`);
      }
      
      alignShape(alignment) {
        if(!this.selectedShape) { alert('Please select a shape to align.'); return; }
        const canvasWidth = this.canvas.width;
        const canvasHeight = this.canvas.height;
        const bbox = this.getBoundingBox(this.selectedShape);
        switch(alignment) {
          case 'left': this.selectedShape.x = 0; break;
          case 'center': this.selectedShape.x = (canvasWidth - bbox.width)/2; break;
          case 'right': this.selectedShape.x = canvasWidth - bbox.width; break;
          case 'top': this.selectedShape.y = 0; break;
          case 'middle': this.selectedShape.y = (canvasHeight - bbox.height)/2; break;
          case 'bottom': this.selectedShape.y = canvasHeight - bbox.height; break;
        }
        this.saveState();
        this.render();
      }
      
      selectEmoji(emoji) {
        this.setTool('emoji');
        this.selectedShape = { type: 'emoji', emoji: emoji, x: 0, y: 0, size: 24, rotation: 0 };
      }
      
      addLabel() {
        const labelText = document.getElementById('labelInput').value.trim();
        if(labelText) {
          const label = { type: 'label', text: labelText, x: 50, y: 50, color: this.labelColor, rotation: 0 };
          this.shapes.push(label);
          this.saveState();
          this.render();
          document.getElementById('labelInput').value = '';
        }
      }
      
      onMouseDown(e) {
        const { offsetX, offsetY } = e;
        // Auto-select shape when in resize/rotate mode if none selected
        if((this.currentTool === 'resize' || this.currentTool === 'rotate') && !this.selectedShape) {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) { this.selectedShape = shape; this.render(); }
        }
        // Check if handle is clicked in resize/rotate mode
        if(this.selectedShape && (this.currentTool === 'resize' || this.currentTool === 'rotate')) {
          let handle = this.getHandleAtPosition(offsetX, offsetY, this.selectedShape);
          if(handle) {
            if(handle === 'rotate') {
              this.isRotating = true;
              const center = { x: this.selectedShape.x + this.selectedShape.width/2, y: this.selectedShape.y + this.selectedShape.height/2 };
              this.initialMouseAngle = Math.atan2(offsetY - center.y, offsetX - center.x);
              this.initialRotation = this.selectedShape.rotation;
            } else {
              this.isResizing = true;
              this.resizeHandle = handle;
              if(this.selectedShape.rotation) {
                const corners = getRotatedCorners(this.selectedShape);
                switch(handle) {
                  case 'top-left': this.resizeFixedCorner = corners.bottomRight; break;
                  case 'top-right': this.resizeFixedCorner = corners.bottomLeft; break;
                  case 'bottom-left': this.resizeFixedCorner = corners.topRight; break;
                  case 'bottom-right': this.resizeFixedCorner = corners.topLeft; break;
                  case 'top-mid': this.resizeFixedCorner = { x: (corners.bottomLeft.x + corners.bottomRight.x)/2, y: (corners.bottomLeft.y + corners.bottomRight.y)/2 }; break;
                  case 'bottom-mid': this.resizeFixedCorner = { x: (corners.topLeft.x + corners.topRight.x)/2, y: (corners.topLeft.y + corners.topRight.y)/2 }; break;
                  case 'mid-left': this.resizeFixedCorner = { x: (corners.topRight.x + corners.bottomRight.x)/2, y: (corners.topRight.y + corners.bottomRight.y)/2 }; break;
                  case 'mid-right': this.resizeFixedCorner = { x: (corners.topLeft.x + corners.bottomLeft.x)/2, y: (corners.topLeft.y + corners.bottomLeft.y)/2 }; break;
                }
              }
            }
            return;
          }
        }
        // Move & Select Tools
        if(this.currentTool === 'move') {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) { this.selectedShape = shape; this.isMoving = true; this.moveOffsetX = offsetX - shape.x; this.moveOffsetY = offsetY - shape.y; this.render(); return; }
        }
        if(this.currentTool === 'select') {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) { this.selectedShape = shape; this.render(); return; }
          else { this.selectedShape = null; this.render(); }
        }
        // Drawing Tools
        if(['freeDraw','contour','rectangle','circle','line','ruler','roadPen','cornerPen','emoji','eraser','text'].includes(this.currentTool)) {
          this.isDrawing = true;
          this.startX = offsetX;
          this.startY = offsetY;
          if(this.currentTool === 'freeDraw' || this.currentTool === 'contour') {
            this.currentShape = { type: this.currentTool, path: [{x: offsetX, y: offsetY}], strokeColor: document.getElementById('strokeColorPicker').value, fillColor: document.getElementById('fillColorPicker').value, lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'rectangle') {
            this.currentShape = { type: 'rectangle', x: offsetX, y: offsetY, width: 0, height: 0, strokeColor: document.getElementById('strokeColorPicker').value, fillColor: document.getElementById('fillColorPicker').value, lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'circle') {
            this.currentShape = { type: 'circle', x: offsetX, y: offsetY, radius: 0, strokeColor: document.getElementById('strokeColorPicker').value, fillColor: document.getElementById('fillColorPicker').value, lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'line') {
            this.currentShape = { type: 'line', startX: offsetX, startY: offsetY, endX: offsetX, endY: offsetY, strokeColor: document.getElementById('strokeColorPicker').value, lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'ruler') {
            this.currentShape = { type: 'ruler', startX: offsetX, startY: offsetY, endX: offsetX, endY: offsetY, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'roadPen') {
            this.currentShape = { type: 'road', x: offsetX, y: offsetY, width: 200, height: 20, rotation: 0 };
            this.shapes.push(this.currentShape);
            this.isDrawing = false; this.saveState(); this.render();
          } else if(this.currentTool === 'cornerPen') {
            this.currentShape = { type: 'corner', x: offsetX, y: offsetY, width: 50, height: 50, radius: 25, rotation: 0 };
            this.shapes.push(this.currentShape);
            this.isDrawing = false; this.saveState(); this.render();
          } else if(this.currentTool === 'eraser') {
            this.currentShape = { type: 'eraser', path: [{x: offsetX, y: offsetY}], lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'text') {
            const text = prompt("Enter text:");
            if(text) {
              const textColor = document.getElementById('labelColorPicker').value;
              const newText = { type: 'label', text: text, x: offsetX, y: offsetY, color: textColor, rotation: 0 };
              this.shapes.push(newText);
              this.saveState();
              this.render();
            }
            this.isDrawing = false;
          }
        }
      }
      
      onMouseMove(e) {
        const { offsetX, offsetY } = e;
        this.handleTooltip(e);
        if(this.selectedShape && (this.currentTool === 'resize' || this.currentTool === 'rotate')) {
          const handle = this.getHandleAtPosition(offsetX, offsetY, this.selectedShape);
          this.canvas.style.cursor = handle ? (handle === 'rotate' ? 'grab' : 'nwse-resize') : 'default';
        }
        if(this.isDrawing && this.currentShape) {
          if(this.currentTool === 'freeDraw' || this.currentTool === 'contour') {
            this.currentShape.path.push({x: offsetX, y: offsetY});
            this.render();
          } else if(this.currentTool === 'rectangle') {
            this.currentShape.width = offsetX - this.startX;
            this.currentShape.height = offsetY - this.startY;
            this.render();
          } else if(this.currentTool === 'circle') {
            const radius = Math.sqrt(Math.pow(offsetX - this.startX,2) + Math.pow(offsetY - this.startY,2));
            this.currentShape.radius = radius;
            this.render();
          } else if(this.currentTool === 'line' || this.currentTool === 'ruler') {
            this.currentShape.endX = offsetX;
            this.currentShape.endY = offsetY;
            this.render();
          } else if(this.currentTool === 'eraser') {
            this.currentShape.path.push({x: offsetX, y: offsetY});
            this.render();
          }
        }
        if(this.isMoving && this.selectedShape) {
          this.selectedShape.x = offsetX - this.moveOffsetX;
          this.selectedShape.y = offsetY - this.moveOffsetY;
          this.render();
        }
        if(this.isRotating && this.selectedShape) {
          const center = { x: this.selectedShape.x + this.selectedShape.width/2, y: this.selectedShape.y + this.selectedShape.height/2 };
          const currentAngle = Math.atan2(offsetY - center.y, offsetX - center.x);
          this.selectedShape.rotation = this.initialRotation + (currentAngle - this.initialMouseAngle);
          this.render();
        }
        if(this.isResizing && this.selectedShape && this.resizeHandle) {
          if(this.selectedShape.rotation) {
            const centerNew = { x: (this.resizeFixedCorner.x + offsetX)/2, y: (this.resizeFixedCorner.y + offsetY)/2 };
            const cos = Math.cos(-this.selectedShape.rotation);
            const sin = Math.sin(-this.selectedShape.rotation);
            const localFixed = { x: cos*(this.resizeFixedCorner.x - centerNew.x) - sin*(this.resizeFixedCorner.y - centerNew.y),
                                 y: sin*(this.resizeFixedCorner.x - centerNew.x) + cos*(this.resizeFixedCorner.y - centerNew.y) };
            const localCurrent = { x: cos*(offsetX - centerNew.x) - sin*(offsetY - centerNew.y),
                                   y: sin*(offsetX - centerNew.x) + cos*(offsetY - centerNew.y) };
            const newWidth = Math.abs(localCurrent.x - localFixed.x);
            const newHeight = Math.abs(localCurrent.y - localFixed.y);
            const newCenterLocal = { x: (localFixed.x + localCurrent.x)/2, y: (localFixed.y + localCurrent.y)/2 };
            const newCenterCanvas = {
              x: centerNew.x + newCenterLocal.x*Math.cos(this.selectedShape.rotation) - newCenterLocal.y*Math.sin(this.selectedShape.rotation),
              y: centerNew.y + newCenterLocal.x*Math.sin(this.selectedShape.rotation) + newCenterLocal.y*Math.cos(this.selectedShape.rotation)
            };
            this.selectedShape.width = newWidth;
            this.selectedShape.height = newHeight;
            this.selectedShape.x = newCenterCanvas.x - newWidth/2;
            this.selectedShape.y = newCenterCanvas.y - newHeight/2;
          } else {
            const bbox = this.getBoundingBox(this.selectedShape);
            let newWidth = bbox.width, newHeight = bbox.height, newX = bbox.x, newY = bbox.y;
            switch(this.resizeHandle) {
              case 'top-left': newWidth = bbox.width + (bbox.x - offsetX); newHeight = bbox.height + (bbox.y - offsetY); newX = offsetX; newY = offsetY; break;
              case 'top-right': newWidth = offsetX - bbox.x; newHeight = bbox.height + (bbox.y - offsetY); newY = offsetY; break;
              case 'bottom-left': newWidth = bbox.width + (bbox.x - offsetX); newHeight = offsetY - bbox.y; newX = offsetX; break;
              case 'bottom-right': newWidth = offsetX - bbox.x; newHeight = offsetY - bbox.y; break;
              case 'top-mid': newHeight = bbox.height + (bbox.y - offsetY); newY = offsetY; break;
              case 'bottom-mid': newHeight = offsetY - bbox.y; break;
              case 'mid-left': newWidth = bbox.width + (bbox.x - offsetX); newX = offsetX; break;
              case 'mid-right': newWidth = offsetX - bbox.x; break;
            }
            if(this.shiftPressed) {
              const aspectRatio = bbox.width / bbox.height;
              if(newWidth / newHeight > aspectRatio) { newWidth = newHeight * aspectRatio; }
              else { newHeight = newWidth / aspectRatio; }
            }
            this.selectedShape.x = newX;
            this.selectedShape.y = newY;
            this.selectedShape.width = newWidth;
            this.selectedShape.height = newHeight;
          }
          this.render();
        }
      }
      
      onMouseUp(e) {
        if(this.isDrawing) { this.isDrawing = false; this.currentShape = null; this.saveState(); }
        if(this.isMoving) { this.isMoving = false; this.saveState(); }
        if(this.isResizing) { this.isResizing = false; this.resizeHandle = null; this.resizeFixedCorner = null; this.saveState(); }
        if(this.isRotating) { this.isRotating = false; this.saveState(); }
        if(this.currentTool === 'emoji' && this.selectedShape) {
          this.selectedShape.x = e.offsetX;
          this.selectedShape.y = e.offsetY;
          this.shapes.push({...this.selectedShape});
          this.selectedShape = null;
          this.saveState();
          this.render();
          this.setTool('freeDraw');
        }
      }
      
      getBoundingBox(shape) {
        if(shape.type === 'circle') {
          return { x: shape.x - shape.radius, y: shape.y - shape.radius, width: shape.radius*2, height: shape.radius*2 };
        } else if(['rectangle','road','corner','label','emoji','line','ruler','freeDraw','contour','eraser'].includes(shape.type)) {
          if(shape.type === 'emoji') {
            const emojiWidth = this.ctx.measureText(shape.emoji).width;
            return { x: shape.x - emojiWidth/2, y: shape.y - shape.size, width: emojiWidth, height: shape.size };
          } else if(shape.type === 'label') {
            this.ctx.font = "16px Arial";
            const textWidth = this.ctx.measureText(shape.text).width;
            return { x: shape.x, y: shape.y, width: textWidth, height: 16 };
          } else if(shape.type === 'line' || shape.type === 'ruler') {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return { x: minX, y: minY, width: maxX-minX, height: maxY-minY };
          } else if(shape.type === 'eraser') {
            const xs = shape.path.map(p => p.x), ys = shape.path.map(p => p.y);
            return { x: Math.min(...xs)-shape.lineWidth, y: Math.min(...ys)-shape.lineWidth, width: Math.max(...xs)-Math.min(...xs)+shape.lineWidth*2, height: Math.max(...ys)-Math.min(...ys)+shape.lineWidth*2 };
          } else {
            if(shape.rotation) {
              const corners = getRotatedCorners(shape);
              const xs = [corners.topLeft.x, corners.topRight.x, corners.bottomLeft.x, corners.bottomRight.x];
              const ys = [corners.topLeft.y, corners.topRight.y, corners.bottomLeft.y, corners.bottomRight.y];
              return { x: Math.min(...xs), y: Math.min(...ys), width: Math.max(...xs)-Math.min(...xs), height: Math.max(...ys)-Math.min(...ys) };
            } else {
              return { x: shape.x, y: shape.y, width: shape.width, height: shape.height };
            }
          }
        }
        return { x:0, y:0, width:0, height:0 };
      }
      
      renderSelectionBox(shape) {
        this.ctx.save();
        if(shape.rotation) {
          const corners = getRotatedCorners(shape);
          this.ctx.beginPath();
          this.ctx.moveTo(corners.topLeft.x, corners.topLeft.y);
          this.ctx.lineTo(corners.topRight.x, corners.topRight.y);
          this.ctx.lineTo(corners.bottomRight.x, corners.bottomRight.y);
          this.ctx.lineTo(corners.bottomLeft.x, corners.bottomLeft.y);
          this.ctx.closePath();
          this.ctx.strokeStyle = '#1abc9c';
          this.ctx.lineWidth = 1;
          this.ctx.setLineDash([5,3]);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
          const handles = [
            { position: 'top-left', x: corners.topLeft.x, y: corners.topLeft.y },
            { position: 'top-right', x: corners.topRight.x, y: corners.topRight.y },
            { position: 'bottom-left', x: corners.bottomLeft.x, y: corners.bottomLeft.y },
            { position: 'bottom-right', x: corners.bottomRight.x, y: corners.bottomRight.y },
            { position: 'top-mid', x: (corners.topLeft.x+corners.topRight.x)/2, y: (corners.topLeft.y+corners.topRight.y)/2 },
            { position: 'bottom-mid', x: (corners.bottomLeft.x+corners.bottomRight.x)/2, y: (corners.bottomLeft.y+corners.bottomRight.y)/2 },
            { position: 'mid-left', x: (corners.topLeft.x+corners.bottomLeft.x)/2, y: (corners.topLeft.y+corners.bottomLeft.y)/2 },
            { position: 'mid-right', x: (corners.topRight.x+corners.bottomRight.x)/2, y: (corners.topRight.y+corners.bottomRight.y)/2 }
          ];
          handles.forEach(handle => {
            this.ctx.fillStyle = '#1abc9c';
            this.ctx.fillRect(handle.x-4, handle.y-4, 8, 8);
          });
          const topMid = handles.find(h => h.position === 'top-mid');
          const rotateHandle = { x: topMid.x, y: topMid.y - 30 };
          this.ctx.fillStyle = '#1abc9c';
          this.ctx.fillRect(rotateHandle.x-4, rotateHandle.y-4, 8, 8);
        } else {
          const bbox = this.getBoundingBox(shape);
          this.ctx.strokeStyle = '#1abc9c';
          this.ctx.lineWidth = 1;
          this.ctx.setLineDash([5,3]);
          this.ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
          this.ctx.setLineDash([]);
          const handles = this.getHandles(bbox);
          handles.forEach(handle => {
            this.ctx.fillStyle = '#1abc9c';
            this.ctx.fillRect(handle.x, handle.y, handle.width, handle.height);
          });
          const rotateHandle = { x: bbox.x + bbox.width/2 - 4, y: bbox.y - 30 - 4, width: 8, height: 8 };
          this.ctx.fillStyle = '#1abc9c';
          this.ctx.fillRect(rotateHandle.x, rotateHandle.y, rotateHandle.width, rotateHandle.height);
        }
        this.ctx.restore();
      }
      
      getHandles(bbox) {
        const size = 8;
        return [
          { x: bbox.x - size/2, y: bbox.y - size/2, width: size, height: size, position: 'top-left' },
          { x: bbox.x + bbox.width - size/2, y: bbox.y - size/2, width: size, height: size, position: 'top-right' },
          { x: bbox.x - size/2, y: bbox.y + bbox.height - size/2, width: size, height: size, position: 'bottom-left' },
          { x: bbox.x + bbox.width - size/2, y: bbox.y + bbox.height - size/2, width: size, height: size, position: 'bottom-right' },
          { x: bbox.x + bbox.width/2 - size/2, y: bbox.y - size/2, width: size, height: size, position: 'top-mid' },
          { x: bbox.x + bbox.width/2 - size/2, y: bbox.y + bbox.height - size/2, width: size, height: size, position: 'bottom-mid' },
          { x: bbox.x - size/2, y: bbox.y + bbox.height/2 - size/2, width: size, height: size, position: 'mid-left' },
          { x: bbox.x + bbox.width - size/2, y: bbox.y + bbox.height/2 - size/2, width: size, height: size, position: 'mid-right' }
        ];
      }
      
      getHandleAtPosition(x, y, shape) {
        if(shape.rotation) {
          const corners = getRotatedCorners(shape);
          const handles = [
            { position: 'top-left', x: corners.topLeft.x, y: corners.topLeft.y },
            { position: 'top-right', x: corners.topRight.x, y: corners.topRight.y },
            { position: 'bottom-left', x: corners.bottomLeft.x, y: corners.bottomLeft.y },
            { position: 'bottom-right', x: corners.bottomRight.x, y: corners.bottomRight.y },
            { position: 'top-mid', x: (corners.topLeft.x+corners.topRight.x)/2, y: (corners.topLeft.y+corners.topRight.y)/2 },
            { position: 'bottom-mid', x: (corners.bottomLeft.x+corners.bottomRight.x)/2, y: (corners.bottomLeft.y+corners.bottomRight.y)/2 },
            { position: 'mid-left', x: (corners.topLeft.x+corners.bottomLeft.x)/2, y: (corners.topLeft.y+corners.bottomLeft.y)/2 },
            { position: 'mid-right', x: (corners.topRight.x+corners.bottomRight.x)/2, y: (corners.topRight.y+corners.bottomRight.y)/2 }
          ];
          const topMid = handles.find(h => h.position==='top-mid');
          handles.push({ position: 'rotate', x: topMid.x, y: topMid.y - 30 });
          for(let handle of handles) {
            if(x >= handle.x-8 && x <= handle.x+8 && y >= handle.y-8 && y <= handle.y+8) { return handle.position; }
          }
          return null;
        } else {
          const bbox = this.getBoundingBox(shape);
          const handles = this.getHandles(bbox);
          const rotateHandle = { x: bbox.x + bbox.width/2 - 4, y: bbox.y - 30 - 4, width: 8, height: 8, position: 'rotate' };
          handles.push(rotateHandle);
          for(let handle of handles) {
            if(x >= handle.x && x <= handle.x + handle.width && y >= handle.y && y <= handle.y + handle.height) { return handle.position; }
          }
          return null;
        }
      }
      
      render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if(this.gridEnabled) this.drawGrid();
        this.shapes.forEach(shape => this.drawShape(shape));
        if(this.selectedShape && ['select','resize','rotate','move'].includes(this.currentTool)) {
          this.renderSelectionBox(this.selectedShape);
        }
      }
      
      drawGrid() {
        const gridSize = 50;
        this.ctx.save();
        this.ctx.strokeStyle = '#bdc3c7';
        this.ctx.lineWidth = 0.5;
        for(let x = 0; x <= this.canvas.width; x += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }
        for(let y = 0; y <= this.canvas.height; y += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(this.canvas.width, y);
          this.ctx.stroke();
        }
        this.ctx.restore();
      }
      
      drawShape(shape) {
        this.ctx.save();
        if(shape.rotation) {
          const centerX = shape.x + shape.width/2;
          const centerY = shape.y + shape.height/2;
          this.ctx.translate(centerX, centerY);
          this.ctx.rotate(shape.rotation);
          this.ctx.translate(-centerX, -centerY);
        }
        switch(shape.type) {
          case 'freeDraw':
          case 'contour':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.path[0].x, shape.path[0].y);
            for(let i = 1; i < shape.path.length; i++) {
              this.ctx.lineTo(shape.path[i].x, shape.path[i].y);
            }
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.lineWidth = shape.lineWidth;
            if(shape.fillColor && shape.type==='contour') { this.ctx.fillStyle = shape.fillColor; this.ctx.fill(); }
            this.ctx.stroke();
            break;
          case 'rectangle':
            this.ctx.beginPath();
            this.ctx.rect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.fillStyle = shape.fillColor;
            this.ctx.fill();
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'circle':
            this.ctx.beginPath();
            this.ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI*2);
            this.ctx.fillStyle = shape.fillColor;
            this.ctx.fill();
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'line':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.startX, shape.startY);
            this.ctx.lineTo(shape.endX, shape.endY);
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'ruler':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.startX, shape.startY);
            this.ctx.lineTo(shape.endX, shape.endY);
            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = '#FFD700';
            this.ctx.stroke();
            const deltaX = shape.endX - shape.startX, deltaY = shape.endY - shape.startY;
            const length = Math.round(Math.sqrt(deltaX*deltaX + deltaY*deltaY));
            const midX = (shape.startX + shape.endX)/2, midY = (shape.startY + shape.endY)/2;
            this.ctx.fillStyle = '#FFD700';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`${length} px`, midX, midY - 10);
            break;
          case 'road':
            this.ctx.save();
            const cx = shape.x + shape.width/2, cy = shape.y + shape.height/2;
            this.ctx.translate(cx, cy);
            this.ctx.rotate(shape.rotation);
            this.ctx.translate(-cx, -cy);
            this.ctx.fillStyle = '#555';
            this.ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 2;
            const laneSpacing = shape.width/4;
            for(let i = 1; i < 4; i++){
              this.ctx.beginPath();
              this.ctx.moveTo(shape.x + laneSpacing*i, shape.y + shape.height/4);
              this.ctx.lineTo(shape.x + laneSpacing*i, shape.y + (3*shape.height)/4);
              this.ctx.stroke();
            }
            this.ctx.restore();
            break;
          case 'corner':
            this.ctx.save();
            const ccx = shape.x + shape.width/2, ccy = shape.y + shape.height/2;
            this.ctx.translate(ccx, ccy);
            this.ctx.rotate(shape.rotation);
            this.ctx.translate(-ccx, -ccy);
            this.ctx.fillStyle = '#555';
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(shape.x + shape.radius, shape.y);
            this.ctx.lineTo(shape.x + shape.width - shape.radius, shape.y);
            this.ctx.quadraticCurveTo(shape.x + shape.width, shape.y, shape.x + shape.width, shape.y + shape.radius);
            this.ctx.lineTo(shape.x + shape.width, shape.y + shape.height - shape.radius);
            this.ctx.quadraticCurveTo(shape.x + shape.width, shape.y + shape.height, shape.x + shape.width - shape.radius, shape.y + shape.height);
            this.ctx.lineTo(shape.x + shape.radius, shape.y + shape.height);
            this.ctx.quadraticCurveTo(shape.x, shape.y + shape.height, shape.x, shape.y + shape.height - shape.radius);
            this.ctx.lineTo(shape.x, shape.y + shape.radius);
            this.ctx.quadraticCurveTo(shape.x, shape.y, shape.x + shape.radius, shape.y);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
            this.ctx.restore();
            break;
          case 'emoji':
            this.ctx.font = `${shape.size}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(shape.emoji, shape.x, shape.y);
            break;
          case 'label':
            this.ctx.font = "16px Arial";
            this.ctx.fillStyle = shape.color || '#000';
            this.ctx.textAlign = 'left';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(shape.text, shape.x, shape.y);
            break;
          case 'eraser':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.path[0].x, shape.path[0].y);
            for(let i = 1; i < shape.path.length; i++){
              this.ctx.lineTo(shape.path[i].x, shape.path[i].y);
            }
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = shape.lineWidth * 5;
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.stroke();
            this.ctx.globalCompositeOperation = 'source-over';
            break;
          default:
            break;
        }
        this.ctx.restore();
      }
      
      handleTooltip(e) {
        const { offsetX, offsetY } = e;
        const shape = this.getShapeAtPosition(offsetX, offsetY);
        if(shape) {
          this.showTooltip(shape.type.charAt(0).toUpperCase() + shape.type.slice(1), e.clientX, e.clientY);
        } else {
          this.hideTooltip();
        }
      }
      
      showTooltip(text, x, y) {
        this.tooltip.textContent = text;
        this.tooltip.style.left = `${x+10}px`;
        this.tooltip.style.top = `${y+10}px`;
        this.tooltip.style.opacity = 1;
      }
      
      hideTooltip() { this.tooltip.style.opacity = 0; }
      
      showSparkles() {
        const sparkleCount = 20;
        for(let i = 0; i < sparkleCount; i++){
          const sparkle = document.createElement('div');
          sparkle.classList.add('sparkle');
          sparkle.style.left = `${Math.random()*this.sparklesContainer.clientWidth}px`;
          sparkle.style.top = `${Math.random()*this.sparklesContainer.clientHeight}px`;
          sparkle.style.opacity = Math.random();
          this.sparklesContainer.appendChild(sparkle);
          sparkle.addEventListener('animationend', () => sparkle.remove());
        }
      }
      
      hideSparkles() { this.sparklesContainer.innerHTML = ''; }
      
      restoreLastState() {
        if(this.historyIndex >= 0) {
          const lastState = this.history[this.historyIndex].shapes;
          this.shapes = JSON.parse(JSON.stringify(lastState));
          this.render();
        }
      }
      
      saveState() {
        if(this.historyIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyIndex+1);
        }
        const shapesCopy = JSON.parse(JSON.stringify(this.shapes));
        this.history.push({ shapes: shapesCopy });
        this.historyIndex++;
        this.updateLayerList();
      }
      
      undo() { if(this.historyIndex > 0) { this.historyIndex--; this.restoreLastState(); } }
      redo() { if(this.historyIndex < this.history.length - 1) { this.historyIndex++; this.restoreLastState(); } }
      clearCanvas() { this.shapes = []; this.saveState(); this.render(); }
      
      exportCanvas() {
        const dataURL = this.canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'creative-canvas.png';
        link.href = dataURL;
        link.click();
      }
      
      updateLayerList() {
        const layerList = document.getElementById('layerList');
        layerList.innerHTML = '';
        this.history.forEach((state, index) => {
          const layerItem = document.createElement('div');
          layerItem.classList.add('layer-item');
          layerItem.innerHTML = `<span>Layer ${index+1}</span>`;
          const controls = document.createElement('div');
          controls.classList.add('layer-controls');
          const viewBtn = document.createElement('button');
          viewBtn.innerHTML = 'ğŸ‘ï¸';
          viewBtn.title = 'View Layer';
          viewBtn.addEventListener('click', () => { this.historyIndex = index; this.restoreLastState(); });
          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = 'âŒ';
          deleteBtn.title = 'Delete Layer';
          deleteBtn.addEventListener('click', () => {
            this.history.splice(index, 1);
            if(this.historyIndex >= this.history.length) { this.historyIndex = this.history.length - 1; }
            this.restoreLastState();
            this.updateLayerList();
          });
          controls.appendChild(viewBtn);
          controls.appendChild(deleteBtn);
          layerItem.appendChild(controls);
          layerList.appendChild(layerItem);
        });
      }
      
      getShapeAtPosition(x, y) {
        for(let i = this.shapes.length - 1; i >= 0; i--){
          const shape = this.shapes[i];
          if(shape.type === 'emoji') {
            const emojiWidth = this.ctx.measureText(shape.emoji).width;
            if(x >= shape.x - emojiWidth/2 && x <= shape.x + emojiWidth/2 &&
               y >= shape.y - shape.size && y <= shape.y) return shape;
          } else if(shape.type === 'label') {
            this.ctx.font = "16px Arial";
            const textWidth = this.ctx.measureText(shape.text).width;
            if(x >= shape.x && x <= shape.x + textWidth &&
               y >= shape.y && y <= shape.y + 16) return shape;
          } else if(shape.type === 'ruler') {
            const dist = this.pointToLineDistance(x, y, shape.startX, shape.startY, shape.endX, shape.endY);
            if(dist <= 5) return shape;
          } else if(shape.type === 'road' || shape.type === 'corner') {
            if(x >= shape.x && x <= shape.x+shape.width &&
               y >= shape.y && y <= shape.y+shape.height) return shape;
          } else if(['freeDraw','contour','rectangle','circle','line','eraser'].includes(shape.type)) {
            const bbox = this.getBoundingBox(shape);
            if(x >= bbox.x && x <= bbox.x+bbox.width &&
               y >= bbox.y && y <= bbox.y+bbox.height) return shape;
          }
        }
        return null;
      }
      
      pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D, lenSq = C * C + D * D;
        let param = (lenSq !== 0) ? dot/lenSq : -1;
        let xx, yy;
        if(param < 0) { xx = x1; yy = y1; }
        else if(param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }
        return Math.sqrt((px-xx)**2 + (py-yy)**2);
      }
      
      // Save canvas state to localStorage
      saveCanvasToLocalStorage() {
        localStorage.setItem("canvasState", JSON.stringify(this.shapes));
        alert("Canvas saved to local storage!");
      }
      
      // Load canvas state from localStorage
      loadCanvasFromLocalStorage() {
        const state = localStorage.getItem("canvasState");
        if(state) {
          this.shapes = JSON.parse(state);
          this.saveState();
          this.render();
          alert("Canvas loaded from local storage!");
        } else {
          alert("No saved canvas found in local storage.");
        }
      }
      
      // Check if "What's New" popup should be shown (only if not seen before)
      checkWhatsNewPopup() {
        if(localStorage.getItem("whatsNewSeen") !== "true") {
          document.getElementById("whatsNewPopup").style.display = "flex";
        }
      }
    }
    
    // DALLÂ·E prompt (as comment): "A futuristic digital canvas interface with interactive draggable rotate and resize handles, neon UI elements, and a creative workspace background."
    console.log("Advanced Creative Canvas loaded. Ready to draw, save, and innovate!");
    
    window.addEventListener('load', () => {
      new AdvancedDrawingTool('mainCanvas');
    });
  </script>
</body>
</html>
