<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Rotary Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: linear-gradient(135deg, #f0f2f5, #e0e5ec);
    }
    h1, h2, h3 {
      color: #222;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }
    label {
      display: block;
      margin-top: 10px;
      font-weight: bold;
      color: #444;
    }
    input, select {
      width: 100%;
      padding: 10px;
      margin-top: 5px;
      box-sizing: border-box;
      border: 1px solid #bbb;
      border-radius: 6px;
      background-color: #fff;
      transition: border-color 0.3s, box-shadow 0.3s;
    }
    input:focus, select:focus {
      border-color: #007BFF;
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
      outline: none;
    }
    button {
      margin-top: 15px;
      padding: 12px 20px;
      background-color: #007BFF;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
    }
    button:hover {
      background-color: #0056b3;
      transform: translateY(-2px);
    }
    .output {
      margin-top: 20px;
      padding: 20px;
      border: 1px solid #ddd;
      background-color: #ffffff;
      border-radius: 6px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    #rotaSVG, #threeCanvas {
      width: 100%;
      max-width: 1000px;
      height: 500px;
      margin: 20px auto;
      border: 1px solid #ddd;
      background-color: #fff;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #controlPanel, #simulationOptions, #environmentalControls {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      padding: 15px;
      background-color: #fff;
      border-radius: 6px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    #controlPanel > div, #simulationOptions > div, #environmentalControls > div {
      flex: 1;
      min-width: 220px;
    }
    #exportButtons {
      margin-top: 20px;
      display: flex;
      justify-content: flex-start;
      gap: 15px;
      flex-wrap: wrap;
    }
    #exportButtons button {
      padding: 10px 15px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
    }
    #exportButtons button:hover {
      background-color: #1e7e34;
      transform: translateY(-2px);
    }
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #loadingSpinner {
      border: 10px solid #f3f3f3;
      border-top: 10px solid #3498db;
      border-radius: 50%;
      width: 80px;
      height: 80px;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #debugPanel, #gearDetails, .cadDetails, #performanceMetrics {
      margin-top: 20px;
      padding: 20px;
      border: 1px solid #ddd;
      background-color: #ffffff;
      border-radius: 6px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      display: none;
    }
    .cadDetails h3, #performanceMetrics h3 {
      margin-bottom: 10px;
      color: #007BFF;
    }
    .cadDetails ul, #performanceMetrics ul {
      margin-top: 5px;
      padding-left: 25px;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .tooltip .tooltiptext::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #555 transparent transparent transparent;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
  </style>
</head>
<body>
  <h1>Advanced Rotary Generator</h1>
  <form id="generatorForm">
    <div class="tooltip">
      <label>Power Output (W):</label>
      <span class="tooltiptext">Specify the desired electrical power output of the generator.</span>
    </div>
    <input type="number" id="powerOutput" step="0.1" required placeholder="e.g., 100.5">
    <div class="tooltip">
      <label>Dimensions (L×W×H mm):</label>
      <span class="tooltiptext">Enter the physical dimensions of the generator in millimeters (Length×Width×Height).</span>
    </div>
    <input type="text" id="dimensions" placeholder="e.g., 50×30×20" pattern="^\d+(\.\d+)?\×\d+(\.\d+)?\×\d+(\.\d+)?$" required>
    <div class="tooltip">
      <label>Operating Speed (RPM):</label>
      <span class="tooltiptext">Set the rotational speed of the generator's input shaft in revolutions per minute.</span>
    </div>
    <input type="number" id="rpm" step="0.1" required placeholder="e.g., 1500.5">
    <div class="tooltip">
      <label>Efficiency (%):</label>
      <span class="tooltiptext">Define the efficiency of the generator in percentage, representing energy conversion effectiveness.</span>
    </div>
    <input type="number" id="efficiency" step="0.1" max="100" required placeholder="e.g., 85.5">
    <div class="tooltip">
      <label>Material:</label>
      <span class="tooltiptext">Choose the primary material for the generator's structural components.</span>
    </div>
    <select id="material" required>
      <option value="Aluminum">Aluminum</option>
      <option value="Steel">Steel</option>
      <option value="Titanium">Titanium</option>
      <option value="Composite">Composite</option>
      <option value="CarbonFiber">Carbon Fiber</option>
    </select>
    <div class="tooltip">
      <label>Gear Type:</label>
      <span class="tooltiptext">Select the type of gear system to be used in the generator.</span>
    </div>
    <select id="gearType" required>
      <option value="Spur">Spur</option>
      <option value="Bevel">Bevel</option>
      <option value="Helical">Helical</option>
      <option value="Worm">Worm</option>
      <option value="Rack">Rack</option>
      <option value="Planetary">Planetary</option>
    </select>
    <div class="tooltip">
      <label>Number of Gears:</label>
      <span class="tooltiptext">Specify the number of gears in the gear system. Can be fractional for complex systems.</span>
    </div>
    <input type="number" id="gears" step="0.1" required placeholder="e.g., 2.5">
    <div class="tooltip">
      <label>Axial Offset (mm):</label>
      <span class="tooltiptext">Define the axial displacement between gear stages, relevant for helical or bevel gears.</span>
    </div>
    <input type="number" id="axialOffset" step="0.1" value="0" required>
    <div class="tooltip">
      <label>Gear Ratio:</label>
      <span class="tooltiptext">Set the ratio of input to output speed in the gear system.</span>
    </div>
    <input type="number" id="gearRatio" step="0.01" value="1" required>
    <div class="tooltip">
      <label>Tooth Count Per Gear:</label>
      <span class="tooltiptext">Enter the number of teeth for each gear. Adjusts gear size and meshing.</span>
    </div>
    <input type="number" id="toothCount" step="0.1" required placeholder="e.g., 20.5">
    <div class="tooltip">
      <label>Shaft Diameter (mm):</label>
      <span class="tooltiptext">Specify the diameter of the shafts supporting the gears, influencing structural integrity.</span>
    </div>
    <input type="number" id="shaftDiameter" step="0.1" value="2" required>
    <div class="tooltip">
      <label>Use Involute Profile:</label>
      <span class="tooltiptext">Check to use an involute profile for gear teeth, improving meshing accuracy and reducing backlash.</span>
    </div>
    <input type="checkbox" id="involuteProfile">
    <div class="tooltip">
      <label>Color Scheme:</label>
      <span class="tooltiptext">Choose a color scheme for the visual representation of the generator.</span>
    </div>
    <select id="colorScheme">
      <option value="default">Default (Blue)</option>
      <option value="grayscale">Grayscale</option>
      <option value="neon">Neon</option>
      <option value="custom">Custom</option>
    </select>
    <div class="tooltip">
      <label>Custom Color (if selected):</label>
      <span class="tooltiptext">If 'Custom' color scheme is selected, pick a custom color for the generator.</span>
    </div>
    <input type="color" id="customColor" value="#007BFF">
    <div class="tooltip">
      <label>Add Mesh Details:</label>
      <span class="tooltiptext">Enable detailed mesh rendering in the 3D view for a more realistic appearance.</span>
    </div>
    <input type="checkbox" id="meshDetails">
    <div class="tooltip">
      <label>Show Stress Analysis:</label>
      <span class="tooltiptext">Enable a visual stress analysis overlay on the 2D diagram, simulating stress distribution.</span>
    </div>
    <input type="checkbox" id="showStress">
    <div class="tooltip">
      <label>Show CAD Details:</label>
      <span class="tooltiptext">Display detailed CAD parameters and calculations for each gear.</span>
    </div>
    <input type="checkbox" id="showCad">
    <div class="tooltip">
      <label>Enable Physics Simulation:</label>
      <span class="tooltiptext">Turn on physics simulation in the 3D view, allowing for dynamic interaction and movement.</span>
    </div>
    <input type="checkbox" id="physicsSim">
    <button type="button" id="generateButton">Generate Design</button>
    <button type="reset">Reset Form</button>
  </form>

  <div id="output" class="output" style="display:none;">
    <h2>Generated Specifications:</h2>
    <p id="specs"></p>
  </div>

  <div id="rotaSVG"></div>
  <div id="threeCanvas"></div>

  <div id="controlPanel" style="display: none;">
    <div>
      <label>Zoom:</label>
      <input type="range" id="zoomControl" min="0.1" max="5" step="0.1" value="1">
    </div>
    <div>
      <label>Camera Angle X:</label>
      <input type="range" id="angleXControl" min="-360" max="360" step="1" value="0">
    </div>
    <div>
      <label>Camera Angle Y:</label>
      <input type="range" id="angleYControl" min="-360" max="360" step="1" value="0">
    </div>
    <div>
      <label>Camera Angle Z:</label>
      <input type="range" id="angleZControl" min="-360" max="360" step="1" value="0">
    </div>
  </div>

  <div id="simulationOptions" style="display: none;">
    <div>
      <label>Simulation Speed:</label>
      <input type="range" id="simSpeedControl" min="0.01" max="10" step="0.01" value="1">
    </div>
    <div>
      <label>Show Trail:</label>
      <input type="checkbox" id="showTrailCheckbox" checked>
    </div>
    <div>
      <label>Trail Length:</label>
      <input type="range" id="trailLengthControl" min="1" max="1000" step="1" value="100">
    </div>
    <div>
      <label>Gravity (m/s²):</label>
      <input type="number" id="gravityControl" step="0.1" value="9.81">
    </div>
  </div>

  <div id="environmentalControls" style="display: none;">
    <div>
      <label>Temperature (°C):</label>
      <input type="number" id="temperatureControl" step="0.1" value="25">
    </div>
    <div>
      <label>Pressure (kPa):</label>
      <input type="number" id="pressureControl" step="0.1" value="101.3">
    </div>
    <div>
      <label>Vibration Frequency (Hz):</label>
      <input type="number" id="vibrationControl" step="0.1" value="0">
    </div>
  </div>

  <div id="exportButtons" style="display: none;">
    <button id="export2DPNGButton">Export 2D PNG</button>
    <button id="export2DSVGButton">Export 2D SVG</button>
    <button id="export3DSTLButton">Export 3D STL</button>
    <button id="exportGIFButton">Export Animated GIF</button>
    <button id="exportGLBButton">Export Animated GLB</button>
    <button id="exportJSONButton">Export Specs JSON</button>
    <button id="exportDXFButton">Export CAD DXF</button>
    <button id="exportCSVButton">Export Performance CSV</button>
  </div>

  <div id="loadingOverlay">
    <div id="loadingSpinner"></div>
  </div>

  <div id="debugPanel"></div>
  <div id="gearDetails"></div>
  <div id="cadDetails" class="cadDetails"></div>
  <div id="performanceMetrics"></div>

  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dxf/1.0.1/dxf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const svgCanvas = SVG().addTo('#rotaSVG').size('100%', '100%').viewbox(0, 0, 1000, 500); // Initialize with viewbox for centering
      const debugPanel = document.getElementById('debugPanel');
      const gearDetails = document.getElementById('gearDetails');
      const cadDetails = document.getElementById('cadDetails');
      const performanceMetrics = document.getElementById('performanceMetrics');
      const simplex = new SimplexNoise();
      let trailPoints = [], currentColor = '#007BFF', rotationSpeed = 0, animateFrame;
      let scene, camera, renderer, gearGroup, mixers = [], clock, world;
      let currentSpecs = null;

      // Helper function to create gear path string
      const createGearPathString = (radius, teeth, involute) => {
        const points = [];
        const angleIncrement = (Math.PI * 2) / teeth;
        if (involute) {
          const toothDepth = radius / 10;
          for (let i = 0; i < teeth; i++) {
            const angle = i * angleIncrement;
            points.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
            points.push({ x: Math.cos(angle + angleIncrement / 2) * (radius - toothDepth), y: Math.sin(angle + angleIncrement / 2) * (radius - toothDepth) });
            points.push({ x: Math.cos(angle + angleIncrement) * radius, y: Math.sin(angle + angleIncrement) * radius });
          }
        } else {
          for (let i = 0; i < teeth; i++) {
            const angle = i * angleIncrement;
            points.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
            points.push({ x: Math.cos(angle + angleIncrement / 2) * (radius - 10), y: Math.sin(angle + angleIncrement / 2) * (radius - 10) });
          }
        }
        return points.map((p, i) => (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y).join(' ') + ' Z';
      };

      // Draw a single gear using SVG.js
      const drawGear = (x, y, radius, teeth, rotation, connectedTo, involute, color, stress, gearType, group) => { // Pass group to drawGear
        const gearGroup = group.group().translate(x, y).rotate(rotation); // Draw in the passed group
        if (gearType === "Rack") {
          const toothWidth = radius / 5;
          const toothHeight = radius / 3;
          const rackLength = teeth * toothWidth;
          const points = [];
          for (let i = 0; i < Math.ceil(teeth); i++) {
            const startX = -rackLength / 2 + i * toothWidth;
            const startY = -toothHeight / 2;
            points.push([startX, startY], [startX, startY + toothHeight], [startX + toothWidth, startY + toothHeight], [startX + toothWidth, startY]);
          }
          const pathString = points.map((p, i) => (i === 0 ? 'M' : 'L') + p[0] + ' ' + p[1]).join(' ');
          gearGroup.path(pathString).stroke({ color, width: 2 }).fill('none');
        } else if (gearType === "Planetary") {
          const sunRadius = radius / 2;
          const planetRadius = radius / 4;
          gearGroup.path(createGearPathString(sunRadius, Math.round(teeth / 2), involute)).stroke({ color, width: 2 }).fill('none');
          for (let i = 0; i < 3; i++) {
            const angle = i * (2 * Math.PI / 3);
            const px = Math.cos(angle) * (sunRadius + planetRadius);
            const py = Math.sin(angle) * (sunRadius + planetRadius);
            gearGroup.path(createGearPathString(planetRadius, Math.round(teeth / 4), involute)).translate(px, py).stroke({ color, width: 2 }).fill('none');
          }
        } else {
          const pathString = createGearPathString(radius, teeth, involute);
          gearGroup.path(pathString).stroke({ color, width: 2 }).fill('none');
        }
        if (connectedTo && gearType !== "Planetary") {
          gearGroup.line(0, 0, connectedTo.x - x, connectedTo.y - y).stroke({ color: '#FF0000', width: 1 });
        }
        if (stress && stress > 0 && gearType !== "Rack" && gearType !== "Planetary") {
          gearGroup.circle(radius * (stress / 500 + 0.1) * 2).center(0, 0).fill('rgba(255, 0, 0, 0.5)');
        }
        return gearGroup;
      };

      // Calculate stress with environmental factors
      const calculateStress = (gearIndex, rotation, temperature, pressure, vibration) => {
        let baseStress = Math.abs(simplex.noise2D(gearIndex, rotation / 1000)) * 500;
        baseStress *= (1 + (temperature - 25) * 0.005); // Temperature effect
        baseStress *= (1 + (pressure - 101.3) * 0.002); // Pressure effect
        baseStress *= (1 + vibration * 0.01); // Vibration effect
        return baseStress;
      };

      // Calculate performance metrics
      const calculatePerformance = (specs) => {
        const { powerOutput, rpm, efficiency, gears, gearRatio, toothCount, material } = specs;
        const torque = (powerOutput * 60) / (2 * Math.PI * rpm); // Nm
        const angularVelocity = (rpm * 2 * Math.PI) / 60; // rad/s
        const massFactor = { Aluminum: 2.7, Steel: 7.8, Titanium: 4.5, Composite: 1.5, CarbonFiber: 1.8 };
        const mass = gears * toothCount * 0.001 * massFactor[material]; // Rough mass in kg
        const powerLoss = powerOutput * (1 - efficiency / 100);
        return { torque, angularVelocity, mass, powerLoss };
      };

      // Display CAD details
      const calculateCadDetails = (specs, gearIndex, radius, x, y) => {
        const { toothCount, gearType, gearRatio } = specs;
        const pitchDiameter = 2 * radius;
        const diametralPitch = toothCount / pitchDiameter;
        const pressureAngle = gearType === 'Helical' ? 25 : gearType === 'Planetary' ? 22 : 20;
        const module = pitchDiameter / toothCount;
        return `
          <h3>Gear ${gearIndex + 1} CAD Details:</h3>
          <ul>
            <li><strong>Type:</strong> ${gearType}</li>
            <li><strong>Teeth:</strong> ${toothCount.toFixed(2)}</li>
            <li><strong>Pitch Diameter:</strong> ${pitchDiameter.toFixed(2)} mm</li>
            <li><strong>Diametral Pitch:</strong> ${diametralPitch.toFixed(2)}</li>
            <li><strong>Pressure Angle:</strong> ${pressureAngle}°</li>
            <li><strong>Module:</strong> ${module.toFixed(2)}</li>
            <li><strong>Position X:</strong> ${x.toFixed(2)}</li>
            <li><strong>Position Y:</strong> ${y.toFixed(2)}</li>
          </ul>`;
      };

      // Display gear details on hover
      const displayGearDetails = (gearIndex, x, y) => {
        gearDetails.style.display = 'block';
        const { gears, gearType, gearRatio, toothCount, showStress } = currentSpecs;
        const speed = parseFloat(document.getElementById('simSpeedControl').value);
        const temperature = parseFloat(document.getElementById('temperatureControl').value);
        const pressure = parseFloat(document.getElementById('pressureControl').value);
        const vibration = parseFloat(document.getElementById('vibrationControl').value);
        const gearRotation = speed * (gearIndex + 1) / gearRatio;
        const stress = showStress ? calculateStress(gearIndex, rotationSpeed, temperature, pressure, vibration) : 0;
        gearDetails.innerHTML = `
          <h2>Gear ${gearIndex + 1} Details:</h2>
          <ul>
            <li><strong>Type:</strong> ${gearType}</li>
            <li><strong>Rotation Speed:</strong> ${gearRotation.toFixed(2)} rad/s</li>
            <li><strong>Stress:</strong> ${stress.toFixed(2)}</li>
            <li><strong>Position X:</strong> ${x.toFixed(2)}</li>
            <li><strong>Position Y:</strong> ${y.toFixed(2)}</li>
          </ul>`;
        if (document.getElementById('showCad').checked) {
          cadDetails.style.display = 'block';
          cadDetails.innerHTML = calculateCadDetails(currentSpecs, gearIndex, 40 + gearIndex * 10, x, y);
        } else {
          cadDetails.style.display = 'none';
        }
      };

      // Draw the entire gear system
      const drawSystem = (rotationSpeed, specs) => {
        svgCanvas.clear();
        const centerX = 0; // Center of the SVG viewbox is now 0,0
        const centerY = 0;
        const { gears, gearType, gearRatio, toothCount, involuteProfile, showStress } = specs;
        const temperature = parseFloat(document.getElementById('temperatureControl').value);
        const pressure = parseFloat(document.getElementById('pressureControl').value);
        const vibration = parseFloat(document.getElementById('vibrationControl').value);
        const radiusIncrement = 20;
        let connections = [];
        currentColor = document.getElementById('colorScheme').value === 'custom' ? document.getElementById('customColor').value :
                       document.getElementById('colorScheme').value === 'grayscale' ? '#808080' :
                       document.getElementById('colorScheme').value === 'neon' ? '#00FF00' : '#007BFF';

        const systemGroup = svgCanvas.group(); // Create a group to hold all gears for centering
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; // Track bounding box

        for (let i = 0; i < Math.ceil(gears); i++) {
          const angle = i * (Math.PI * 2) / gears;
          const radius = 40 + i * 10;
          const x = centerX + Math.cos(angle) * (i * radiusIncrement + 50);
          const y = centerY + Math.sin(angle) * (i * radiusIncrement + 50);
          const connectedTo = connections.length && gearType !== "Planetary" ? connections[connections.length - 1] : null;
          const gearRotation = (rotationSpeed * (i + 1) / gearRatio);
          const stress = showStress ? calculateStress(i, gearRotation, temperature, pressure, vibration) : 0;
          const gearDrawn = drawGear(x, y, radius, toothCount, gearRotation, connectedTo, involuteProfile, currentColor, stress, gearType, systemGroup); // Pass systemGroup

          // Update bounding box
          if (gearType !== "Rack") { // Rack doesn't have a center point like circular gears for bounding box
            minX = Math.min(minX, x - radius);
            minY = Math.min(minY, y - radius);
            maxX = Math.max(maxX, x + radius);
            maxY = Math.max(maxY, y + radius);
          }


          if (gearType !== "Rack" && gearType !== "Planetary") connections.push({ x, y });

          if (document.getElementById('showTrailCheckbox').checked && gearType !== "Rack" && gearType !== "Planetary") {
            const pointLocal = { x: radius, y: 0 };
            const rotatedPoint = {
              x: pointLocal.x * Math.cos(gearRotation) - pointLocal.y * Math.sin(gearRotation),
              y: pointLocal.x * Math.sin(gearRotation) + pointLocal.y * Math.cos(gearRotation)
            };
            const worldPoint = { x: x + rotatedPoint.x, y: y + rotatedPoint.y };
            trailPoints[i].push(worldPoint);
            if (trailPoints[i].length > parseInt(document.getElementById('trailLengthControl').value))
              trailPoints[i].shift();
          }
        }

        // Center the system in the SVG viewbox
        const systemWidth = maxX - minX;
        const systemHeight = maxY - minY;
        const offsetX = -((minX + maxX) / 2); // Calculate centering offset
        const offsetY = -((minY + maxY) / 2);
        systemGroup.translate(offsetX, offsetY);

        if (document.getElementById('showTrailCheckbox').checked && gearType !== "Rack" && gearType !== "Planetary") {
          trailPoints.forEach(points => {
            if (points.length > 1) {
              const pathString = points.map((p, i) => (i === 0 ? 'M' : 'L') + (p.x + offsetX) + ' ' + (p.y + offsetY)).join(' '); // Apply offset to trail points
              svgCanvas.path(pathString).stroke({ color: '#6c757d', width: 1 }).fill('none');
            }
          });
        }

        if (showStress) {
          debugPanel.style.display = 'block';
          let debugInfo = '<h3>Stress Analysis:</h3>';
          for (let i = 0; i < Math.ceil(gears); i++) {
            const gearRotation = (rotationSpeed * (i + 1) / gearRatio);
            debugInfo += `<p>Gear ${i + 1}: ${calculateStress(i, gearRotation, temperature, pressure, vibration).toFixed(2)}</p>`;
          }
          debugPanel.innerHTML = debugInfo;
        } else {
          debugPanel.style.display = 'none';
        }

        svgCanvas.node.addEventListener('mousemove', (e) => {
          const rect = svgCanvas.node.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          // Adjust mouse coordinates for SVG centering translation
          const svgMouseX = mouseX - offsetX;
          const svgMouseY = mouseY - offsetY;

          for (let i = 0; i < Math.ceil(gears); i++) {
            const angle = i * (Math.PI * 2) / gears;
            const radius = 40 + i * 10;
            const x = centerX + Math.cos(angle) * (i * radiusIncrement + 50);
            const y = centerY + Math.sin(angle) * (i * radiusIncrement + 50);
            if (Math.sqrt((svgMouseX - x) ** 2 + (svgMouseY - y) ** 2) < radius + 10) {
              displayGearDetails(i, x, y);
              return;
            }
            gearDetails.style.display = 'none';
            cadDetails.style.display = 'none';
          }
        });

        const perf = calculatePerformance(specs);
        performanceMetrics.style.display = 'block';
        performanceMetrics.innerHTML = `
          <h3>Performance Metrics:</h3>
          <ul>
            <li><strong>Torque:</strong> ${perf.torque.toFixed(2)} Nm</li>
            <li><strong>Angular Velocity:</strong> ${perf.angularVelocity.toFixed(2)} rad/s</li>
            <li><strong>Estimated Mass:</strong> ${perf.mass.toFixed(2)} kg</li>
            <li><strong>Power Loss:</strong> ${perf.powerLoss.toFixed(2)} W</li>
          </ul>`;
      };

      // Animate the 2D system
      const animateSystem = (specs) => {
        drawSystem(rotationSpeed += parseFloat(document.getElementById('simSpeedControl').value), specs);
        animateFrame = requestAnimationFrame(() => animateSystem(specs));
      };

      // Generate specifications
      const generateSpecs = () => {
        cancelAnimationFrame(animateFrame);
        const specs = {
          powerOutput: parseFloat(document.getElementById('powerOutput').value),
          dimensions: document.getElementById('dimensions').value,
          rpm: parseFloat(document.getElementById('rpm').value),
          efficiency: parseFloat(document.getElementById('efficiency').value),
          material: document.getElementById('material').value,
          gearType: document.getElementById('gearType').value,
          gears: parseFloat(document.getElementById('gears').value),
          axialOffset: parseFloat(document.getElementById('axialOffset').value),
          gearRatio: parseFloat(document.getElementById('gearRatio').value),
          toothCount: parseFloat(document.getElementById('toothCount').value),
          shaftDiameter: parseFloat(document.getElementById('shaftDiameter').value),
          involuteProfile: document.getElementById('involuteProfile').checked,
          colorScheme: document.getElementById('colorScheme').value,
          customColor: document.getElementById('customColor').value,
          meshDetails: document.getElementById('meshDetails').checked,
          showStress: document.getElementById('showStress').checked,
          showCad: document.getElementById('showCad').checked,
          physicsSim: document.getElementById('physicsSim').checked
        };

        if (!specs.powerOutput || !specs.dimensions || !specs.rpm || !specs.efficiency) {
          alert('Please enter valid values for Power Output, Dimensions, RPM, and Efficiency.');
          return;
        }

        currentSpecs = specs;
        trailPoints = Array.from({ length: Math.ceil(specs.gears) }, () => []);
        document.getElementById('specs').innerHTML = `
          <strong>Power Output:</strong> ${specs.powerOutput} W<br>
          <strong>Dimensions:</strong> ${specs.dimensions} mm<br>
          <strong>RPM:</strong> ${specs.rpm} RPM<br>
          <strong>Efficiency:</strong> ${specs.efficiency}%<br>
          <strong>Material:</strong> ${specs.material}<br>
          <strong>Gear Type:</strong> ${specs.gearType}<br>
          <strong>Gears:</strong> ${specs.gears}<br>
          <strong>Axial Offset:</strong> ${specs.axialOffset} mm<br>
          <strong>Gear Ratio:</strong> ${specs.gearRatio}<br>
          <strong>Tooth Count:</strong> ${specs.toothCount}<br>
          <strong>Shaft Diameter:</strong> ${specs.shaftDiameter} mm<br>
          <strong>Involute Profile:</strong> ${specs.involuteProfile ? 'Yes' : 'No'}<br>
          <strong>Optimized RPM:</strong> ${(specs.rpm * (specs.efficiency / 100)).toFixed(2)} RPM`;
        document.getElementById('output').style.display = 'block';
        document.getElementById('controlPanel').style.display = 'flex';
        document.getElementById('exportButtons').style.display = 'flex';
        document.getElementById('simulationOptions').style.display = 'flex';
        document.getElementById('environmentalControls').style.display = 'flex';
        document.getElementById('loadingOverlay').style.display = 'flex';
        create3DGears(specs);
        animateSystem(specs);
      };

      // Create 3D gears with physics
      const create3DGears = (specs) => {
        const { gears, gearType, axialOffset, shaftDiameter, meshDetails, colorScheme, customColor, toothCount, involuteProfile, physicsSim } = specs;
        const threeCanvas = document.getElementById('threeCanvas');
        threeCanvas.innerHTML = '';
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, threeCanvas.clientWidth / 500, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(threeCanvas.clientWidth, 500);
        threeCanvas.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        gearGroup = new THREE.Group();

        const materialColor = colorScheme === 'custom' ? parseInt(customColor.slice(1), 16) :
                             colorScheme === 'grayscale' ? 0x808080 :
                             colorScheme === 'neon' ? 0x00FF00 : 0x007BFF;

        if (physicsSim) {
          world = new CANNON.World();
          world.gravity.set(0, 0, -parseFloat(document.getElementById('gravityControl').value));
        }

        let lastGear = null;
        const bodies = [];

        for (let i = 0; i < Math.ceil(gears); i++) {
          let geometry, radius = 5, height = 2, segments = 32;
          const angle = i * (Math.PI * 2) / gears;
          switch (gearType) {
            case "Spur":
              geometry = involuteProfile ? createInvoluteGearGeometry(radius, toothCount, height, segments) :
                        new THREE.CylinderGeometry(radius, radius, height, segments);
              addShaft(geometry, shaftDiameter, height);
              break;
            case "Bevel":
              geometry = new THREE.ConeGeometry(radius, height, segments);
              addShaft(geometry, shaftDiameter, height);
              break;
            case "Helical":
              geometry = new THREE.CylinderGeometry(radius, radius, height, segments, 1, true);
              geometry.rotateZ(Math.PI / 6);
              addShaft(geometry, shaftDiameter, height);
              break;
            case "Worm":
              geometry = new THREE.TorusGeometry(radius, 1, 16, 100);
              geometry.rotateX(Math.PI / 2);
              addShaft(geometry, shaftDiameter, height);
              break;
            case "Rack":
              geometry = new THREE.BoxGeometry(radius * 10, radius * 2, height);
              break;
            case "Planetary":
              geometry = new THREE.Group();
              const sunGeo = involuteProfile ? createInvoluteGearGeometry(radius / 2, toothCount / 2, height, segments) :
                            new THREE.CylinderGeometry(radius / 2, radius / 2, height, segments);
              addShaft(sunGeo, shaftDiameter, height);
              const sun = new THREE.Mesh(sunGeo, new THREE.MeshStandardMaterial({ color: materialColor }));
              geometry.add(sun);
              for (let j = 0; j < 3; j++) {
                const planetGeo = involuteProfile ? createInvoluteGearGeometry(radius / 4, toothCount / 4, height, segments) :
                                new THREE.CylinderGeometry(radius / 4, radius / 4, height, segments);
                addShaft(planetGeo, shaftDiameter / 2, height);
                const planet = new THREE.Mesh(planetGeo, new THREE.MeshStandardMaterial({ color: materialColor }));
                planet.position.set(Math.cos(j * 2 * Math.PI / 3) * (radius / 2 + radius / 4), Math.sin(j * 2 * Math.PI / 3) * (radius / 2 + radius / 4), 0);
                geometry.add(planet);
              }
              break;
          }

          if (meshDetails && gearType !== "Rack" && gearType !== "Planetary") {
            const detailGeo = new THREE.CylinderGeometry(radius * 0.1, radius * 0.1, height * 1.2, segments);
            const detailMesh = new THREE.Mesh(detailGeo);
            detailMesh.position.set(0, 0, -height / 1.1);
            geometry.merge(detailMesh.geometry, detailMesh.matrix);
            for (let j = 0; j < segments; j++) {
              const dGeo = new THREE.BoxGeometry(radius * 0.1, radius * 0.05, height * 1.1);
              const dMesh = new THREE.Mesh(dGeo);
              dMesh.rotation.z = j * (2 * Math.PI) / segments;
              dMesh.position.set(Math.cos(j * (2 * Math.PI) / segments) * radius * 1.1, Math.sin(j * (2 * Math.PI) / segments) * radius * 1.1, 0);
              geometry.merge(dMesh.geometry, dMesh.matrix);
            }
          }

          const material = new THREE.MeshStandardMaterial({ color: materialColor, roughness: 0.4, metalness: 0.6 });
          const gear = gearType === "Planetary" ? geometry : new THREE.Mesh(geometry, material);
          const x = Math.cos(angle) * (i * 10 + 20);
          const y = Math.sin(angle) * (i * 10 + 20);

          if (gearType !== "Rack") {
            gear.position.set(x, y, axialOffset * i);
            gearGroup.add(gear);
            if (lastGear && gearType !== "Planetary") {
              const connector = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([lastGear.position, gear.position]),
                new THREE.LineBasicMaterial({ color: 0xff0000 })
              );
              scene.add(connector);
            }
            lastGear = gear;

            if (physicsSim && gearType !== "Planetary") {
              const shape = new CANNON.Cylinder(radius, radius, height, segments);
              const body = new CANNON.Body({ mass: 1 });
              body.addShape(shape);
              body.position.set(x, y, axialOffset * i);
              world.addBody(body);
              bodies.push({ mesh: gear, body });
            }
          } else {
            gear.position.set(0, 0, 0);
            gearGroup.add(gear);
            if (physicsSim) {
              const shape = new CANNON.Box(new CANNON.Vec3(radius * 10 / 2, radius * 2 / 2, height / 2));
              const body = new CANNON.Body({ mass: 0 }); // Static
              body.addShape(shape);
              body.position.set(0, 0, 0);
              world.addBody(body);
              bodies.push({ mesh: gear, body });
            }
          }
        }

        scene.add(gearGroup);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        camera.position.z = 50;

        mixers = [];
        clock = new THREE.Clock();
        for (let i = 0; i < Math.ceil(gears); i++) {
          const gear = gearType === "Planetary" ? gearGroup.children[i].children[0] : gearGroup.children[i];
          const clip = new THREE.AnimationClip(`Gear${i}Rotation`, -1, [
            new THREE.KeyframeTrack('.rotation[z]', [0, 10], [0, Math.PI * 2 * (i + 1) / specs.gearRatio])
          ]);
          const mixer = new THREE.AnimationMixer(gear);
          mixer.clipAction(clip).play();
          mixers.push(mixer);
          if (gearType === "Planetary") {
            for (let j = 1; j < 4; j++) {
              const planet = gearGroup.children[i].children[j];
              const planetClip = new THREE.AnimationClip(`Planet${i}-${j}Rotation`, -1, [
                new THREE.KeyframeTrack('.rotation[z]', [0, 10], [0, -Math.PI * 2 * (i + 1) / (specs.gearRatio * 2)])
              ]);
              const planetMixer = new THREE.AnimationMixer(planet);
              planetMixer.clipAction(planetClip).play();
              mixers.push(planetMixer);
            }
          }
        }

        const updateCamera = () => {
          camera.position.z = 50 / parseFloat(document.getElementById('zoomControl').value);
          camera.rotation.x = parseFloat(document.getElementById('angleXControl').value) * Math.PI / 180;
          camera.rotation.y = parseFloat(document.getElementById('angleYControl').value) * Math.PI / 180;
          camera.rotation.z = parseFloat(document.getElementById('angleZControl').value) * Math.PI / 180;
        };
        ['zoomControl', 'angleXControl', 'angleYControl', 'angleZControl'].forEach(id =>
          document.getElementById(id).addEventListener('input', updateCamera));

        const animate = () => {
          requestAnimationFrame(animate);
          const delta = clock.getDelta();
          mixers.forEach(mixer => mixer.update(delta));
          if (physicsSim) {
            world.step(1 / 60);
            bodies.forEach(({ mesh, body }) => {
              mesh.position.copy(body.position);
              mesh.quaternion.copy(body.quaternion);
            });
          }
          renderer.render(scene, camera);
        };
        updateCamera();
        animate();
        document.getElementById('loadingOverlay').style.display = 'none';
      };

      // Involute gear geometry
      const createInvoluteGearGeometry = (radius, toothCount, height, segments) => {
        const shape = new THREE.Shape();
        const toothAngle = (2 * Math.PI) / toothCount;
        for (let i = 0; i < Math.ceil(toothCount); i++) {
          const angle = i * toothAngle;
          const startX = Math.cos(angle) * radius;
          const startY = Math.sin(angle) * radius;
          const baseX = Math.cos(angle + toothAngle / 2) * (radius - radius / 10);
          const baseY = Math.sin(angle + toothAngle / 2) * (radius - radius / 10);
          const tipX = Math.cos(angle + toothAngle) * radius;
          const tipY = Math.sin(angle + toothAngle) * radius;
          shape.moveTo(startX, startY);
          shape.lineTo(baseX, baseY);
          shape.lineTo(tipX, tipY);
        }
        return new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
      };

      // Add shaft to gear
      const addShaft = (geometry, diameter, length) => {
        const shaftGeometry = new THREE.CylinderGeometry(diameter / 2, diameter / 2, length * 1.5, 32);
        const shaftMesh = new THREE.Mesh(shaftGeometry);
        shaftMesh.rotation.x = Math.PI / 2;
        geometry.merge(shaftMesh.geometry, shaftMesh.matrix);
      };

      // Export functions
      const export2DPNG = () => {
        const canvas = document.createElement('canvas');
        canvas.width = svgCanvas.width();
        canvas.height = 500;
        const ctx = canvas.getContext('2d');
        const svgData = svgCanvas.svg();
        const img = new Image();
        img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
        img.onload = () => {
          ctx.drawImage(img, 0, 0);
          const link = document.createElement('a');
          link.href = canvas.toDataURL('image/png');
          link.download = 'gearbox_2d.png';
          link.click();
        };
      };

      const export2DSVG = () => {
        const svgString = svgCanvas.svg();
        const blob = new Blob([svgString], { type: 'image/svg+xml' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'gearbox_2d.svg';
        link.click();
      };

      const export3DSTL = () => {
        document.getElementById('loadingOverlay').style.display = 'flex';
        const exporter = new THREE.STLExporter();
        const stlString = exporter.parse(scene);
        const blob = new Blob([stlString], { type: 'text/plain' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'gearbox_3d.stl';
        link.onload = () => document.getElementById('loadingOverlay').style.display = 'none';
        link.click();
      };

      const exportGIF = async () => {
        document.getElementById('loadingOverlay').style.display = 'flex';
        const gif = new GIF({ workers: 2, quality: 10, width: svgCanvas.width(), height: 500 });
        const frameCount = 60;
        const currentSpeed = parseFloat(document.getElementById('simSpeedControl').value);
        document.getElementById('simSpeedControl').value = 0.5;
        rotationSpeed = 0;

        for (let i = 0; i < frameCount; i++) {
          drawSystem(rotationSpeed += 0.5, currentSpecs);
          const svgData = svgCanvas.svg();
          const canvas = document.createElement('canvas');
          canvas.width = svgCanvas.width();
          canvas.height = 500;
          const ctx = canvas.getContext('2d');
          const img = new Image();
          img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
          await new Promise(resolve => img.onload = resolve);
          ctx.drawImage(img, 0, 0);
          gif.addFrame(ctx, { delay: 1000 / 60 });
        }

        document.getElementById('simSpeedControl').value = currentSpeed;
        gif.on('finished', (blob) => {
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'gearbox_animation.gif';
          link.onload = () => document.getElementById('loadingOverlay').style.display = 'none';
          link.click();
        });
        gif.render();
      };

      const exportGLB = () => {
        document.getElementById('loadingOverlay').style.display = 'flex';
        const exporter = new THREE.GLTFExporter();
        exporter.parse(scene, (gltf) => {
          const blob = new Blob([JSON.stringify(gltf)], { type: 'model/gltf-binary' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'gearbox_animated.glb';
          link.onload = () => document.getElementById('loadingOverlay').style.display = 'none';
          link.click();
        });
      };

      const exportJSON = () => {
        const json = JSON.stringify(currentSpecs, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'gearbox_specs.json';
        link.click();
      };

      const exportDXF = () => {
        const dxf = new DXF();
        const centerX = 0; // Center is now 0,0 as per viewbox
        const centerY = 0;
        const radiusIncrement = 20;
        for (let i = 0; i < Math.ceil(currentSpecs.gears); i++) {
          const angle = i * (Math.PI * 2) / currentSpecs.gears;
          const radius = 40 + i * 10;
          const x = centerX + Math.cos(angle) * (i * radiusIncrement + 50);
          const y = centerY + Math.sin(angle) * (i * radiusIncrement + 50);
          if (currentSpecs.gearType === "Planetary") {
            const sunRadius = radius / 2;
            const planetRadius = radius / 4;
            dxf.addCircle(x, y, sunRadius);
            for (let j = 0; j < 3; j++) {
              const px = x + Math.cos(j * 2 * Math.PI / 3) * (sunRadius + planetRadius);
              const py = y + Math.sin(j * 2 * Math.PI / 3) * (sunRadius + planetRadius);
              dxf.addCircle(px, py, planetRadius);
            }
          } else if (currentSpecs.gearType !== "Rack") {
            const points = [];
            const angleIncrement = (Math.PI * 2) / currentSpecs.toothCount;
            for (let j = 0; j < Math.ceil(currentSpecs.toothCount); j++) {
              const angle = j * angleIncrement;
              const outerX = Math.cos(angle) * radius;
              const outerY = Math.sin(angle) * radius;
              const innerX = Math.cos(angle + angleIncrement / 2) * (radius - radius / 5);
              const innerY = Math.sin(angle + angleIncrement / 2) * (radius - radius / 5);
              points.push([x + outerX, y + outerY], [x + innerX, y + innerY]);
            }
            dxf.addPolyline(points);
            dxf.addCircle(x, y, radius);
          } else {
            const toothWidth = radius / 5;
            const toothHeight = radius / 3;
            const points = [];
            for (let k = 0; k < Math.ceil(currentSpecs.toothCount); k++) {
              const startX = x - (currentSpecs.toothCount * toothWidth) / 2 + k * toothWidth;
              const startY = y - toothHeight / 2;
              points.push([startX, startY], [startX, startY + toothHeight], [startX + toothWidth, startY + toothHeight], [startX + toothWidth, startY]);
            }
            dxf.addPolyline(points);
          }
        }
        const blob = new Blob([dxf.toDXFString()], { type: 'application/dxf' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'gearbox_cad.dxf';
        link.click();
      };

      const exportCSV = () => {
        const perf = calculatePerformance(currentSpecs);
        const csv = `Metric,Value\nTorque (Nm),${perf.torque.toFixed(2)}\nAngular Velocity (rad/s),${perf.angularVelocity.toFixed(2)}\nEstimated Mass (kg),${perf.mass.toFixed(2)}\nPower Loss (W),${perf.powerLoss.toFixed(2)}`;
        const blob = new Blob([csv], { type: 'text/csv' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'gearbox_performance.csv';
        link.click();
      };

      // Event listeners
      document.getElementById('generateButton').addEventListener('click', generateSpecs);
      document.getElementById('export2DPNGButton').addEventListener('click', export2DPNG);
      document.getElementById('export2DSVGButton').addEventListener('click', export2DSVG);
      document.getElementById('export3DSTLButton').addEventListener('click', export3DSTL);
      document.getElementById('exportGIFButton').addEventListener('click', exportGIF);
      document.getElementById('exportGLBButton').addEventListener('click', exportGLB);
      document.getElementById('exportJSONButton').addEventListener('click', exportJSON);
      document.getElementById('exportDXFButton').addEventListener('click', exportDXF);
      document.getElementById('exportCSVButton').addEventListener('click', exportCSV);
    });
  </script>
</body>
</html>
