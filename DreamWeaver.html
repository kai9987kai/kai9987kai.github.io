<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Dream Weaver v3.2.2</title>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 1rem; background: #eef1f5; color: #2c3e50; display: flex; flex-direction: column; align-items: center;}
    .container { background: #ffffff; padding: 2rem; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.12); width: 98%; max-width: 1300px;}
    h1 { color: #3498db; text-align: center; margin-bottom: 1.5rem;}
    .grid-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 1.5rem; margin-bottom:1.5rem;}
    .control-group { padding: 1.2em; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; }
    .control-group h3 { margin-top: 0; margin-bottom: 1em; color: #3498db; border-bottom: 2px solid #3498db; padding-bottom: 0.4em; font-size: 1.1em;}
    .control-group label { margin-right: 0.5em; display: inline-block; min-width:130px; margin-bottom: .5em; font-size:0.9em; color: #495057;}
    .control-group input[type="number"], .control-group input[type="range"], .control-group input[type="text"] { 
        width: calc(100% - 140px); padding: .6em .8em; margin-bottom: .6em; border:1px solid #ced4da; border-radius:5px; box-sizing: border-box; font-size:0.9em;
    }
    .control-group input[type="checkbox"] { margin-right: 0.5em; vertical-align: middle; transform: scale(1.1);}
    .controls button, .feedback-controls button { padding: .8em 1.3em; margin: .5em; font-size:0.95em; cursor:pointer; background-color: #5dade2; color:white; border:none; border-radius:5px; transition: background-color 0.2s ease, transform 0.1s ease; }
    .controls button:hover, .feedback-controls button:hover { background-color: #3498db; transform: translateY(-1px);}
    .controls button:active, .feedback-controls button:active {transform: translateY(0px);}
    .controls button:disabled, .feedback-controls button:disabled { cursor:not-allowed; opacity:.6; background-color: #bac8d3;}
    .feedback-controls button.like { background-color: #2ecc71; }
    .feedback-controls button.like:hover { background-color: #27ae60; }
    .feedback-controls button.style-ref { background-color: #f39c12; }
    .feedback-controls button.style-ref:hover { background-color: #e67e22; }

    #pattern-canvas { border: 3px solid #5dade2; background: #fff; display:block; margin: 1.2em auto; border-radius:6px; box-shadow: 0 0 10px rgba(80,150,220,0.3);}
    #status { background:#fdfdfd; padding:1em; border:1px solid #dee2e6; max-height:230px; overflow-y:auto; white-space:pre-wrap; font-size: 0.8em; margin-top:1rem; border-radius:5px; line-height:1.4;}
    #artistic-title { font-weight: 600; font-size: 1.2em; margin: 0.7em auto; text-align: center; color: #2980b9; min-height:1.3em; padding:.4em; background:#eaf5ff; border-radius:5px; border-left: 4px solid #3498db;}
    #latent-interpolate-slider { width: calc(100% - 140px); }
    .meta-status, .style-ref-status {font-size: 0.9em; color: #495057; margin-bottom: 0.5em; text-align: center; background: #e9ecef; padding: 0.6em; border-radius: 5px;}
  </style>
</head>
<body>
  <div class="container">
    <h1>Quantum Dream Weaver <sub>v3.2.2</sub></h1>

    <div class="grid-container">
      <div class="control-group">
        <h3>Meta-Exploration Control</h3>
        <label for="numEpochs">Epochs (0=Infinite):</label><input type="number" id="numEpochs" value="1" min="0"><br>
        <label for="itersPerEpoch">Arch/Epoch:</label><input type="number" id="itersPerEpoch" value="2" min="1"><br>
        <label for="nuancesPerArch">Nuances/Arch:</label><input type="number" id="nuancesPerArch" value="3" min="1">
        <div class="meta-status" id="epochStatus">Epoch: - | Arch Params: Not Set</div>
      </div>

      <div class="control-group">
        <h3>Base Architecture Parameters</h3>
        <label for="minLayers">Min Hidden Blocks:</label><input type="number" id="minLayers" value="1" min="0"><br>
        <label for="maxLayers">Max Hidden Blocks:</label><input type="number" id="maxLayers" value="2" min="0"><br>
        <label for="minUnits">Min Units:</label><input type="number" id="minUnits" value="32" min="8"><br>
        <label for="maxUnits">Max Units:</label><input type="number" id="maxUnits" value="64" min="8"><br>
        <label for="minModUnits">Min Mod Units (%):</label><input type="number" id="minModUnits" value="15" min="5" max="50"><br>
        <label for="maxModUnits">Max Mod Units (%):</label><input type="number" id="maxModUnits" value="35" min="5" max="50">
      </div>
      
      <div class="control-group">
        <h3>Pattern Generation</h3>
        <label for="latentDim">Visual Latent Dim:</label><input type="number" id="latentDim" value="16" min="4"><br>
        <label for="imgSize">Image Size (px):</label><input type="number" id="imgSize" value="64" min="16" step="16"><br>
        <label for="colorOutput">Color Output:</label><input type="checkbox" id="colorOutput"><br>
        <label for="animatePattern">Long Animation:</label><input type="checkbox" id="animatePattern">
      </div>
      
      <div class="control-group">
        <h3>Text Conditioning</h3>
        <label for="textPrompt">Text Prompt:</label><input type="text" id="textPrompt" placeholder="e.g., cosmic flow, ethereal ruins"><br>
        <small>Uses Universal Sentence Encoder (loads once).</small>
      </div>
    </div>
    
    <div class="control-group">
      <h3>Artistic Guidance</h3>
      <div class="feedback-controls">
          <button id="likePattern" class="like" disabled>üëç Like & Keep Arch/Latent</button>
          <button id="setStyleRef" class="style-ref" disabled>Set Current as Style Reference</button>
      </div>
      <div class="style-ref-status" id="styleRefStatus">Style Reference: None</div>
    </div>


    <div class="controls">
      <button id="startMetaLoop">Start Meta-Exploration</button>
      <button id="stopMetaLoop" style="display:none;">Stop All Exploration</button>
      <button id="generateNewPattern" disabled>Generate New Pattern (Current Arch)</button>
    </div>
    <div class="controls feedback-controls">
        <button id="selectArchA" disabled>Select Current for Admixture (A)</button>
        <button id="selectArchB" disabled>Select Current for Admixture (B)</button>
        <button id="createAdmixture" disabled>Create Admixture Model</button>
    </div>
    
    <div class="control-group">
        <h3>Latent Space Interpolation</h3>
        <button id="setLatentA" disabled>Set Visual Latent A</button>
        <button id="setLatentB" disabled>Set Visual Latent B</button><br>
        <label for="latent-interpolate-slider">A <-> B (Visual):</label>
        <input type="range" id="latent-interpolate-slider" min="0" max="1" step="0.01" value="0.5" disabled>
    </div>

    <div class="controls">
      <button id="saveArchitecture" disabled>Save Arch & Metadata</button>
      <button id="loadArchitecture">Load Arch & Metadata</button>
      <button id="savePatternImage" disabled>Save Pattern Image</button>
    </div>
    
    <div id="artistic-title">Artistic Title Will Appear Here</div>
    <div>
      <canvas id="pattern-canvas" width="64" height="64"></canvas>
    </div>
    <div id="status">Idle. Configure parameters. Press "Start Meta-Exploration".</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js"></script>

  <script>
    // ‚Äî‚Äî Dynamic QuantumLayer ‚Äî‚Äî 
    class DynamicQuantumLayer extends tf.layers.Layer { 
        constructor(units, cfg) { 
            super(cfg || {}); 
            this.units = units; 
            this.latentModulationUnits = (cfg && cfg.latentModulationUnits) ? cfg.latentModulationUnits : Math.max(4, Math.floor(units * 0.25));
        }
        build(inputShape) { this.theta_base = this.addWeight('theta_base', [1, this.units], 'float32', tf.initializers.randomUniform({ minval: 0, maxval: 2 * Math.PI })); this.theta_mod_projection_kernel = this.addWeight('theta_mod_kernel', [this.latentModulationUnits, this.units], 'float32', tf.initializers.glorotNormal()); this.theta_mod_projection_bias = this.addWeight('theta_mod_bias', [1, this.units], 'float32', tf.initializers.zeros()); super.build(inputShape); }
        call(inputs) { return tf.tidy(() => { const x = Array.isArray(inputs) ? inputs[0] : inputs; const inputSliceForModulation = x.slice([0, 0], [-1, this.latentModulationUnits]); const kernel = this.theta_mod_projection_kernel.read(); const bias = this.theta_mod_projection_bias.read(); const baseTheta = this.theta_base.read(); const raw_modulation = tf.matMul(inputSliceForModulation, kernel).add(bias); const theta_modulation = tf.tanh(raw_modulation); const t = baseTheta.add(theta_modulation.mul(0.25)); return tf.sigmoid(x.mul(t.cos()).add(tf.sub(1, x.abs()).mul(t.sin()))); }); }
        getConfig() { const config = super.getConfig(); return {...config, units: this.units, latentModulationUnits: this.latentModulationUnits }; }
        static get className() { return 'DynamicQuantumLayer'; }
    }
    tf.serialization.registerClass(DynamicQuantumLayer);

    const ui = { 
        statusEl: document.getElementById('status'), startMetaLoopBtn: document.getElementById('startMetaLoop'), stopMetaLoopBtn: document.getElementById('stopMetaLoop'), epochStatusEl: document.getElementById('epochStatus'), numEpochsInp: document.getElementById('numEpochs'), itersPerEpochInp: document.getElementById('itersPerEpoch'), nuancesPerArchInp: document.getElementById('nuancesPerArch'), minLayersInp: document.getElementById('minLayers'), maxLayersInp: document.getElementById('maxLayers'), minUnitsInp: document.getElementById('minUnits'), maxUnitsInp: document.getElementById('maxUnits'), minModUnitsInp: document.getElementById('minModUnits'), maxModUnitsInp: document.getElementById('maxModUnits'), generateNewPatternBtn: document.getElementById('generateNewPattern'), saveArchitectureBtn: document.getElementById('saveArchitecture'), loadArchitectureBtn: document.getElementById('loadArchitecture'), savePatternImageBtn: document.getElementById('savePatternImage'), canvasEl: document.getElementById('pattern-canvas'), ctx: document.getElementById('pattern-canvas').getContext('2d'), latentDimInp: document.getElementById('latentDim'), imgSizeInp: document.getElementById('imgSize'), colorOutputInp: document.getElementById('colorOutput'), animatePatternInp: document.getElementById('animatePattern'), textPromptInp: document.getElementById('textPrompt'), artisticTitleEl: document.getElementById('artistic-title'), setLatentABtn: document.getElementById('setLatentA'), setLatentBBtn: document.getElementById('setLatentB'), latentInterpolateSlider: document.getElementById('latent-interpolate-slider'), likePatternBtn: document.getElementById('likePattern'), setStyleRefBtn: document.getElementById('setStyleRef'), styleRefStatusEl: document.getElementById('styleRefStatus'), selectArchABtn: document.getElementById('selectArchA'), selectArchBBtn: document.getElementById('selectArchB'), createAdmixtureBtn: document.getElementById('createAdmixture')
    };

    let generation=0, currentModel=null, currentArch=null, currentModelMetadata=null, stopAllFlag=false, metaRunning=false; 
    let keptArch = null; 
    let likedArchPool = []; 
    let archForAdmixtureA = { model: null, arch: null, weights: null, metadata: null }; 
    let archForAdmixtureB = { model: null, arch: null, weights: null, metadata: null }; 
    let styleReference = { arch: null }; 
    let currentEpoch = 0; 
    let latentA_visual = null, latentB_visual = null; 
    let animationFrameId = null; let currentFullLatentForMicroLoop = null; 
    let useModel = null; 
    const TEXT_EMBEDDING_DIM = 512; 
    const ABS_MIN_LAYERS=0, ABS_MAX_LAYERS=6, ABS_MIN_UNITS=8, ABS_MAX_UNITS=192; 
    const ABS_MIN_MOD_UNITS_PERCENT=5, ABS_MAX_MOD_UNITS_PERCENT=60;

    async function loadUseModel() { if (useModel) return useModel; log("Loading Universal Sentence Encoder model (once)..."); try { useModel = await use.load(); log("Universal Sentence Encoder model loaded successfully."); } catch (err) { log("Error loading USE model: " + err.message); console.error("USE Load Error:", err); throw err; } return useModel; }
    function log(msg){ ui.statusEl.textContent += '\n'+msg; ui.statusEl.scrollTop = ui.statusEl.scrollHeight; }
    function clearCanvas() { const imgSize = parseInt(ui.imgSizeInp.value); ui.canvasEl.width = imgSize; ui.canvasEl.height = imgSize; ui.ctx.fillStyle = '#EEE'; ui.ctx.fillRect(0,0,ui.canvasEl.width, ui.canvasEl.height); }

    function makeGeneratorModel(arch, totalInputDim, outputChannels, genIdentifier){
      const inp = tf.input({shape:[totalInputDim], name: `gen${genIdentifier}_combined_input`}); 
      let x = tf.layers.dense({units: arch.units, activation: 'relu', name: `gen${genIdentifier}_dense_in`}).apply(inp);
      for(let i=0; i<arch.hiddenBlocks; i++){ x = tf.layers.dense({units: arch.units, activation: 'relu', name: `gen${genIdentifier}_dense_h${i}`}).apply(x); x = new DynamicQuantumLayer(arch.units, {name: `gen${genIdentifier}_q_h${i}`, latentModulationUnits: arch.latentModulationUnits}).apply(x); }
      const numPixels = parseInt(ui.imgSizeInp.value) * parseInt(ui.imgSizeInp.value);
      x = tf.layers.dense({units: numPixels * outputChannels, activation: 'sigmoid', name: `gen${genIdentifier}_dense_out`}).apply(x); 
      const out = tf.layers.reshape({targetShape: [parseInt(ui.imgSizeInp.value), parseInt(ui.imgSizeInp.value), outputChannels], name: `gen${genIdentifier}_reshape_out`}).apply(x);
      return tf.model({inputs:inp, outputs:out});
    }

    async function generateFullInputVector(textPromptStr, baseVisualLatent = null) { 
        const visualLatentDim = parseInt(ui.latentDimInp.value); const visualLatentVec = baseVisualLatent ? baseVisualLatent.clone() : tf.randomNormal([1, visualLatentDim]);
        if (textPromptStr && textPromptStr.trim() !== "") { if (!useModel) await loadUseModel(); if (!useModel) { log("USE model not available. Using visual latent only."); return visualLatentVec; } const textEmbeddings = await useModel.embed([textPromptStr]); const fullInput = tf.concat([visualLatentVec, textEmbeddings], 1); textEmbeddings.dispose(); if (!baseVisualLatent && visualLatentVec && !visualLatentVec.isDisposed) visualLatentVec.dispose(); return fullInput; } else { return visualLatentVec; }
    }
    
    async function generateAndDisplayPattern(model, providedFullLatentVector = null, textPromptForTitle = "", storeAsMicroLoopLatent = false) {
        if (!model || model.isDisposedInternal) { log("Model not available."); ui.savePatternImageBtn.disabled = true; return null; }
        const imgSize = parseInt(ui.imgSizeInp.value); const visualLatentDim = parseInt(ui.latentDimInp.value);
        const outputChannels = ui.colorOutputInp.checked ? 3 : 1; ui.canvasEl.width = imgSize; ui.canvasEl.height = imgSize;
        let localFullLatentToUse; 
        if (providedFullLatentVector && !providedFullLatentVector.isDisposed) { localFullLatentToUse = providedFullLatentVector.clone(); } 
        else { 
            if(providedFullLatentVector && providedFullLatentVector.isDisposed) log("Warning: providedFullLatentVector was disposed, generating new.");
            localFullLatentToUse = await generateFullInputVector(textPromptForTitle || ui.textPromptInp.value.trim()); 
        }
        
        if(storeAsMicroLoopLatent) { 
            if(currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) currentFullLatentForMicroLoop.dispose();
            currentFullLatentForMicroLoop = localFullLatentToUse.clone(); 
        }

        const visualLatentForReturn = tf.tidy(() => localFullLatentToUse.slice([0,0], [1, visualLatentDim]).clone());
        const fullLatentForReturn = localFullLatentToUse.clone(); 

        tf.tidy(() => { 
            const generatedTensor = model.predict(localFullLatentToUse); const reshapedTensor = generatedTensor.squeeze(); 
            const data = reshapedTensor.dataSync(); const imageData = ui.ctx.createImageData(imgSize, imgSize); 
            for (let i = 0; i < imgSize * imgSize; i++) { if (outputChannels === 3) { imageData.data[i * 4 + 0] = data[i * 3 + 0] * 255; imageData.data[i * 4 + 1] = data[i * 3 + 1] * 255; imageData.data[i * 4 + 2] = data[i * 3 + 2] * 255; imageData.data[i * 4 + 3] = 255; } else { const intensity = data[i] * 255; imageData.data[i * 4 + 0] = intensity; imageData.data[i * 4 + 1] = intensity; imageData.data[i * 4 + 2] = intensity; imageData.data[i * 4 + 3] = 255;}} 
            ui.ctx.putImageData(imageData, 0, 0); ui.savePatternImageBtn.disabled = false; 
            if (currentArch) { generateArtisticTitle(textPromptForTitle || ui.textPromptInp.value.trim(), currentArch); }
        });
        localFullLatentToUse.dispose(); 
        return { visualLatent: visualLatentForReturn, fullLatent: fullLatentForReturn };
    }

    function generateArtisticTitle(prompt, arch) { 
        let title = ""; const qWords = ["Quantum", "Procedural", "Encoded", "Synth", "Flux", "Cipher", "Aether", "Chrono", "Woven", "Noetic", "Recursive"]; const effectWords = ["Echoes", "Tapestry", "Nebula", "Ripples", "Visions", "Horizons", "Fractals", "Dreams", "Realms", "Glyphs", "Spirals", "Matrix", "Memoirs", "Circuits", "Harmonics", "Fields"];
        if (prompt && prompt.length > 0) { const promptWords = prompt.split(" "); const mainPromptWord = promptWords[Math.floor(Math.random() * promptWords.length)]; title += `${qWords[Math.floor(Math.random() * qWords.length)]} "${mainPromptWord.charAt(0).toUpperCase() + mainPromptWord.slice(1)}" ${effectWords[Math.floor(Math.random() * effectWords.length)]}`; } else { title += `${qWords[Math.floor(Math.random() * qWords.length)]} ${effectWords[Math.floor(Math.random() * effectWords.length)]}`; }
        if (arch && typeof arch.hiddenBlocks !== 'undefined' && typeof arch.units !== 'undefined') { title += ` (HB${arch.hiddenBlocks},U${arch.units},M${arch.latentModulationUnits || 'std'})`; } else if (arch) { title += ` (Loaded Arch)`; } ui.artisticTitleEl.textContent = title;
    }
    
    function updateUIForActiveModel(isActive) { 
        ui.generateNewPatternBtn.disabled = !isActive; ui.saveArchitectureBtn.disabled = !isActive; 
        ui.likePatternBtn.disabled = !isActive; ui.setStyleRefBtn.disabled = !isActive;
        ui.selectArchABtn.disabled = !isActive; ui.selectArchBBtn.disabled = !isActive;
        ui.createAdmixtureBtn.disabled = !(archForAdmixtureA.arch && archForAdmixtureB.arch); 
        ui.setLatentABtn.disabled = !isActive; ui.setLatentBBtn.disabled = !isActive;
        ui.latentInterpolateSlider.disabled = !isActive || !latentA_visual || !latentB_visual;
        ui.savePatternImageBtn.disabled = true; 
    }

    function animatePatternCore(isLongAnimation = false) { 
        if ((isLongAnimation && !ui.animatePatternInp.checked) || !currentModel || !currentFullLatentForMicroLoop || currentFullLatentForMicroLoop.isDisposed) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; return;
        }
        const newLatent = tf.tidy(() => {
            const visualLatentDim = parseInt(ui.latentDimInp.value);
            const visualPart = currentFullLatentForMicroLoop.slice([0,0], [1, visualLatentDim]);
            const textPart = currentFullLatentForMicroLoop.slice([0, visualLatentDim], [1, -1]); 
            const perturbation = tf.randomNormal(visualPart.shape, 0, isLongAnimation ? 0.02 : 0.008); 
            const newVisualPart = visualPart.add(perturbation).clipByValue(-2, 2);
            return tf.concat([newVisualPart, textPart], 1);
        });
        if (currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) currentFullLatentForMicroLoop.dispose();
        currentFullLatentForMicroLoop = newLatent;
        generateAndDisplayPattern(currentModel, currentFullLatentForMicroLoop.clone(), ui.textPromptInp.value.trim()); 
        animationFrameId = requestAnimationFrame(() => animatePatternCore(isLongAnimation));
    }
    ui.animatePatternInp.onchange = async () => { 
        if (ui.animatePatternInp.checked && currentModel) { 
            if (currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) currentFullLatentForMicroLoop.dispose();
            currentFullLatentForMicroLoop = null; // Ensure it's null before generateAndDisplayPattern sets it
            const initialLatents = await generateAndDisplayPattern(currentModel, null, ui.textPromptInp.value.trim(), true); 
            if (initialLatents && initialLatents.fullLatent && !initialLatents.fullLatent.isDisposed) { 
                // currentFullLatentForMicroLoop is set inside generateAndDisplayPattern
                initialLatents.visualLatent.dispose(); initialLatents.fullLatent.dispose(); 
                animatePatternCore(true); 
            } else { log("Failed to get initial latent for long animation."); ui.animatePatternInp.checked = false; if(initialLatents && initialLatents.visualLatent) initialLatents.visualLatent.dispose(); if(initialLatents && initialLatents.fullLatent) initialLatents.fullLatent.dispose();}
        } else { if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; }
    };
    
    function updateEpochStatus() { 
        const minL = parseInt(ui.minLayersInp.value); const maxL = parseInt(ui.maxLayersInp.value);
        const minU = parseInt(ui.minUnitsInp.value); const maxU = parseInt(ui.maxUnitsInp.value);
        const minMU = parseInt(ui.minModUnitsInp.value); const maxMU = parseInt(ui.maxModUnitsInp.value);
        ui.epochStatusEl.textContent = `Epoch: ${currentEpoch} | Arch: L[${minL}-${maxL}], U[${minU}-${maxU}], M[${minMU}%-${maxMU}%]`;
    }

    async function runNuanceLoop(textPromptStr) { 
        const nuancesPerArch = parseInt(ui.nuancesPerArchInp.value) || 3;
        log(`--- Starting Nuance Loop (${nuancesPerArch} variations) ---`);
        let firstNuanceLatent = null; let lastNuanceLatent = null;

        for (let nuanceIter = 0; nuanceIter < nuancesPerArch; nuanceIter++) {
            if (stopAllFlag) break;
            log(`Nuance ${nuanceIter + 1}/${nuancesPerArch}...`);
            let latentToPassForThisNuance;

            if (nuanceIter === 0) {
                latentToPassForThisNuance = (currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) ? 
                                            currentFullLatentForMicroLoop.clone() : null;
            } else { 
                if (!currentFullLatentForMicroLoop || currentFullLatentForMicroLoop.isDisposed) {
                    log("Warning: Micro-loop latent missing/disposed in nuance iter > 0. Generating new.");
                    latentToPassForThisNuance = null; 
                } else {
                    const baseForPerturbation = currentFullLatentForMicroLoop.clone();
                    const newPerturbedGlobalLatent = tf.tidy(() => {
                        const visualLatentDim = parseInt(ui.latentDimInp.value);
                        const visualPart = baseForPerturbation.slice([0,0], [1, visualLatentDim]);
                        const textPart = baseForPerturbation.slice([0, visualLatentDim], [1, -1]);
                        const perturbation = tf.randomNormal(visualPart.shape, 0, 0.05); 
                        const newVisualPart = visualPart.add(perturbation).clipByValue(-2,2);
                        return tf.concat([newVisualPart, textPart], 1); 
                    });
                    if (currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) currentFullLatentForMicroLoop.dispose();
                    currentFullLatentForMicroLoop = newPerturbedGlobalLatent; // newPerturbedGlobalLatent is owned by currentFullLatentForMicroLoop
                    baseForPerturbation.dispose();
                    latentToPassForThisNuance = currentFullLatentForMicroLoop.clone(); // Pass a clone
                }
            }
            
            const result = await generateAndDisplayPattern(currentModel, latentToPassForThisNuance, textPromptStr, true); 
            if(latentToPassForThisNuance) latentToPassForThisNuance.dispose();

            if (result && result.fullLatent) { 
                if (nuanceIter === 0 && !result.fullLatent.isDisposed) firstNuanceLatent = result.fullLatent.clone();
                if (nuanceIter === nuancesPerArch - 1 && !result.fullLatent.isDisposed) lastNuanceLatent = result.fullLatent.clone();
                result.visualLatent.dispose(); result.fullLatent.dispose(); 
            }
            await tf.nextFrame();
        }

        if (firstNuanceLatent && !firstNuanceLatent.isDisposed && lastNuanceLatent && !lastNuanceLatent.isDisposed && !stopAllFlag && !ui.animatePatternInp.checked) {
            log("Generating short latent traversal animation...");
            const traversalSteps = 30; 
            for (let i = 0; i <= traversalSteps; i++) {
                if (stopAllFlag) break; const t = i / traversalSteps;
                const interpolatedFullLatent = tf.tidy(() => { return firstNuanceLatent.mul(1 - t).add(lastNuanceLatent.mul(t)); });
                await generateAndDisplayPattern(currentModel, interpolatedFullLatent, textPromptStr, false); 
                interpolatedFullLatent.dispose();
                if (i < traversalSteps) await tf.nextFrame(); 
            } log("Short traversal complete.");
        }
        if (firstNuanceLatent && !firstNuanceLatent.isDisposed) firstNuanceLatent.dispose(); 
        if (lastNuanceLatent && !lastNuanceLatent.isDisposed) lastNuanceLatent.dispose();
        log(`--- Nuance Loop finished ---`);
    }

    async function runArchitectureGenerationLoop() { 
        const itersPerEpoch = parseInt(ui.itersPerEpochInp.value) || 3;
        log(`--- Starting Epoch ${currentEpoch}, Arch Iterations: ${itersPerEpoch} ---`); updateEpochStatus();
        for (let iter = 0; iter < itersPerEpoch; iter++) {
            if (stopAllFlag) break; generation++; 
            log(`\n===== Arch Gen ${generation} (Epoch ${currentEpoch}, Iter ${iter+1}/${itersPerEpoch}) =====`);
            if (currentModel) { currentModel.dispose(); currentModel = null; }
            let minL = parseInt(ui.minLayersInp.value); let maxL = parseInt(ui.maxLayersInp.value);
            let minU = parseInt(ui.minUnitsInp.value); let maxU = parseInt(ui.maxUnitsInp.value);
            let minMUPercent = parseInt(ui.minModUnitsInp.value); let maxMUPercent = parseInt(ui.maxModUnitsInp.value);
            
            if(currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) { currentFullLatentForMicroLoop.dispose(); currentFullLatentForMicroLoop = null; }

            let localKeptArch = null; 
            if (keptArch !== null && typeof keptArch !== 'undefined') { localKeptArch = keptArch; }

            if (likedArchPool.length > 0 && Math.random() < 0.6) { 
                const likedItem = likedArchPool.shift(); 
                localKeptArch = likedItem.arch; 
                log("Using a previously liked architecture as base for mutation.");
                if(likedItem.fullLatent && !likedItem.fullLatent.isDisposed) {
                     if(currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) currentFullLatentForMicroLoop.dispose();
                     currentFullLatentForMicroLoop = likedItem.fullLatent.clone(); 
                } else if (likedItem.fullLatent && likedItem.fullLatent.isDisposed) { log("Warning: Liked item's latent was already disposed."); }
                ui.likePatternBtn.style.backgroundColor = '#2ecc71'; 
            }

            if (localKeptArch) { 
                log("Mutating kept/liked architecture...");
                let muPercent = (localKeptArch.latentModulationUnits / localKeptArch.units * 100) + Math.floor((Math.random()-0.5)*10);
                muPercent = Math.max(minMUPercent, Math.min(maxMUPercent, muPercent));
                currentArch = { 
                    hiddenBlocks: Math.max(minL, Math.min(maxL, localKeptArch.hiddenBlocks + (Math.random() > 0.5 ? 1 : -1))),
                    units: Math.max(minU, Math.min(maxU, localKeptArch.units + Math.floor((Math.random() - 0.5) * 16))),
                };
                currentArch.latentModulationUnits = Math.max(4, Math.floor(currentArch.units * (muPercent/100)));
                if (keptArch === localKeptArch) { keptArch = null; }
            } else {
                const numHiddenBlocks = minL + Math.floor(Math.random() * (maxL - minL + 1));
                const numUnits = minU + Math.floor(Math.random() * (maxU - minU + 1));
                const muPercent = minMUPercent + Math.floor(Math.random() * (maxMUPercent - minMUPercent + 1));
                currentArch = { hiddenBlocks: numHiddenBlocks, units: numUnits, latentModulationUnits: Math.max(4, Math.floor(numUnits * (muPercent / 100))) };
            }
            log(`New Arch ‚Üí HB:${currentArch.hiddenBlocks}, U:${currentArch.units}, MU:${currentArch.latentModulationUnits}`); 
            const visualLatentDim = parseInt(ui.latentDimInp.value);
            let totalInputDim = visualLatentDim;
            const textPromptStr = ui.textPromptInp.value.trim();
            if (textPromptStr !== "") { if(!useModel) await loadUseModel(); if(useModel) totalInputDim += TEXT_EMBEDDING_DIM; }
            currentModel = makeGeneratorModel(currentArch, totalInputDim, ui.colorOutputInp.checked ? 3 : 1, `g${generation}e${currentEpoch}i${iter}`);
            currentModelMetadata = { architecture: {...currentArch}, visualLatentDim, textPrompt: textPromptStr, imgSize: parseInt(ui.imgSizeInp.value), colorOutput: ui.colorOutputInp.checked, sourceGlobalGen: generation, sourceEpoch: currentEpoch };
            log(`Model created (Input Dim: ${totalInputDim}).`);
            updateUIForActiveModel(true); 
            await runNuanceLoop(textPromptStr); 
            if (ui.animatePatternInp.checked && !stopAllFlag) { animatePatternCore(true); } 
            await tf.nextFrame(); 
        }
        log(`--- Epoch ${currentEpoch} finished ---`);
    }

    function driftArchitectureParameters() { 
        log("Drifting architecture parameters for next epoch..."); 
        let minL = parseInt(ui.minLayersInp.value); let maxL = parseInt(ui.maxLayersInp.value); 
        let minU = parseInt(ui.minUnitsInp.value); let maxU = parseInt(ui.maxUnitsInp.value);
        let minMU = parseInt(ui.minModUnitsInp.value); let maxMU = parseInt(ui.maxModUnitsInp.value);
        const useStyleRefBias = styleReference.arch && Math.random() < 0.5; 
        if (useStyleRefBias) log("Applying style reference bias to parameter drift...");
        if (Math.random() < 0.3) { minL += (Math.random() > 0.5 ? 1 : -1); } if (Math.random() < 0.3) { maxL += (Math.random() > 0.5 ? 1 : -1); }
        if (useStyleRefBias && styleReference.arch.hiddenBlocks !== undefined) { minL = Math.round(minL * 0.7 + styleReference.arch.hiddenBlocks * 0.3); maxL = Math.round(maxL * 0.7 + styleReference.arch.hiddenBlocks * 0.3); }
        if (Math.random() < 0.4) { minU += Math.floor((Math.random() - 0.5) * 10); } if (Math.random() < 0.4) { maxU += Math.floor((Math.random() - 0.5) * 10); }
        if (useStyleRefBias && styleReference.arch.units !== undefined) { minU = Math.round(minU * 0.7 + styleReference.arch.units * 0.3); maxU = Math.round(maxU * 0.7 + styleReference.arch.units * 0.3); }
        if (Math.random() < 0.4) { minMU += Math.floor((Math.random() - 0.5) * 10); } if (Math.random() < 0.4) { maxMU += Math.floor((Math.random() - 0.5) * 10); }
        if (useStyleRefBias && styleReference.arch.latentModulationUnits !== undefined && styleReference.arch.units > 0) { const styleRefMUPercent = (styleReference.arch.latentModulationUnits / styleReference.arch.units) * 100; minMU = Math.round(minMU * 0.7 + styleRefMUPercent * 0.3); maxMU = Math.round(maxMU * 0.7 + styleRefMUPercent * 0.3); }
        minL = Math.max(ABS_MIN_LAYERS, Math.min(minL, ABS_MAX_LAYERS -1)); maxL = Math.max(minL, Math.min(maxL, ABS_MAX_LAYERS)); 
        minU = Math.max(ABS_MIN_UNITS, Math.min(minU, ABS_MAX_UNITS - 8)); maxU = Math.max(minU + 8, Math.min(maxU, ABS_MAX_UNITS)); 
        minMU = Math.max(ABS_MIN_MOD_UNITS_PERCENT, Math.min(minMU, ABS_MAX_MOD_UNITS_PERCENT - 5)); maxMU = Math.max(minMU + 5, Math.min(maxMU, ABS_MAX_MOD_UNITS_PERCENT));
        ui.minLayersInp.value = minL; ui.maxLayersInp.value = maxL; ui.minUnitsInp.value = minU; ui.maxUnitsInp.value = maxU; ui.minModUnitsInp.value = minMU; ui.maxModUnitsInp.value = maxMU;
        log(`New Arch Params: L[${minL}-${maxL}], U[${minU}-${maxU}], M[${minMU}%-${maxMU}%]`); updateEpochStatus();
    }
    ui.startMetaLoopBtn.onclick = async ()=>{ 
      if (metaRunning) { log("Meta-Exploration is already running."); return; } metaRunning = true; stopAllFlag = false; currentEpoch = 0; generation = 0; ui.startMetaLoopBtn.disabled = true; ui.stopMetaLoopBtn.style.display = 'inline'; ui.loadArchitectureBtn.disabled = true; if(ui.numEpochsInp.value !== "0" && likedArchPool.length === 0 && !styleReference.arch) clearCanvas(); const numEpochs = parseInt(ui.numEpochsInp.value); const runInfinite = numEpochs === 0; log(`üöÄüöÄ Meta-Exploration Started. Epochs: ${runInfinite ? "Infinite" : numEpochs} üöÄüöÄ`);
      try { while(!stopAllFlag && (runInfinite || currentEpoch < numEpochs)) { currentEpoch++; await runArchitectureGenerationLoop(); if (stopAllFlag) break; if (!runInfinite && currentEpoch >= numEpochs) break; driftArchitectureParameters(); await tf.nextFrame(); }} catch(err){ log(`‚ùå META-LOOP CRITICAL ERROR: ${err.message}\n${err.stack || ''}`); console.error(err); } finally { metaRunning = false; ui.startMetaLoopBtn.disabled = false; ui.stopMetaLoopBtn.style.display = 'none'; ui.loadArchitectureBtn.disabled = false; const finalMessage = stopAllFlag ? `\n‚èπÔ∏è Meta-Exploration stopped by user at Epoch ${currentEpoch}.` : `\n‚úÖ Meta-Exploration finished ${currentEpoch} epochs.`; log(finalMessage); updateUIForActiveModel(currentModel && !currentModel.isDisposedInternal); }
    };
    
    ui.stopMetaLoopBtn.onclick = ()=>{ 
      stopAllFlag=true; ui.stopMetaLoopBtn.disabled = true; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } log('üõëüõë STOP ALL EXPLORATION REQUESTED‚Ä¶');
    };

    ui.generateNewPatternBtn.onclick = async () => { 
        if (ui.animatePatternInp.checked) { ui.animatePatternInp.checked = false; } 
        if (currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) { currentFullLatentForMicroLoop.dispose(); currentFullLatentForMicroLoop = null;}
        const textPromptStr = ui.textPromptInp.value.trim();
        const resultLatents = await generateAndDisplayPattern(currentModel, null, textPromptStr, true); 
        if(resultLatents) { 
            if(resultLatents.visualLatent && !resultLatents.visualLatent.isDisposed) resultLatents.visualLatent.dispose(); 
            if(resultLatents.fullLatent && !resultLatents.fullLatent.isDisposed) resultLatents.fullLatent.dispose(); 
            // currentFullLatentForMicroLoop is already set by generateAndDisplayPattern
        }
    };
    
    ui.savePatternImageBtn.onclick = () => { 
        const dataURL = ui.canvasEl.toDataURL('image/png'); const link = document.createElement('a'); const ts = new Date().toISOString().replace(/[:.-]/g, '').slice(0, -4); link.download = `qdw_pattern_${ts}.png`; link.href = dataURL; document.body.appendChild(link); link.click(); document.body.removeChild(link); log("Pattern image saved.");
    };
    
    ui.likePatternBtn.onclick = () => { 
        if (currentArch && currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed && currentModelMetadata) {
            const likedItem = { arch: {...currentArch}, fullLatent: currentFullLatentForMicroLoop.clone(), metadata: {...currentModelMetadata} };
            likedArchPool.push(likedItem); if(likedArchPool.length > 10) { const old = likedArchPool.shift(); if (old.fullLatent && !old.fullLatent.isDisposed) old.fullLatent.dispose(); }
            log(`Pattern Liked! Arch & Latent added to liked pool (size: ${likedArchPool.length}).`);
            ui.likePatternBtn.style.backgroundColor = '#1e7e34'; setTimeout(() => { ui.likePatternBtn.style.backgroundColor = '#2ecc71';}, 300); 
            keptArch = {...currentArch}; 
        } else { log("Cannot like: No current arch/active latent/metadata, or latent disposed.");}
    };

    ui.setStyleRefBtn.onclick = () => {
        if (currentArch) {
            styleReference.arch = {...currentArch}; 
            log(`Style Reference Set: HB=${currentArch.hiddenBlocks}, U=${currentArch.units}, MU=${currentArch.latentModulationUnits}.`);
            ui.styleRefStatusEl.textContent = `Style Ref: HB${currentArch.hiddenBlocks}, U=${currentArch.units}, M${currentArch.latentModulationUnits}`;
            ui.setStyleRefBtn.style.backgroundColor = '#d35400'; 
             setTimeout(() => { ui.setStyleRefBtn.style.backgroundColor = '#f39c12';}, 300);
        } else { log("No current architecture to set as style reference."); }
    };
    
    function cleanupAdmixtureSelection(sel) { if (sel.weights) sel.weights.forEach(w => w.dispose()); sel.model = null; sel.arch = null; sel.weights = null; sel.metadata = null;}
    ui.selectArchABtn.onclick = () => { 
        if (currentModel && currentArch && currentModelMetadata) { cleanupAdmixtureSelection(archForAdmixtureA); archForAdmixtureA.arch = {...currentArch}; archForAdmixtureA.weights = currentModel.getWeights().map(w => w.clone()); archForAdmixtureA.metadata = {...currentModelMetadata}; log("Arch A selected for admixture."); ui.selectArchABtn.style.backgroundColor = '#0056b3'; ui.createAdmixtureBtn.disabled = !(archForAdmixtureA.arch && archForAdmixtureB.arch); } else { log("No current model/arch/metadata."); }
    };
    ui.selectArchBBtn.onclick = () => { 
         if (currentModel && currentArch && currentModelMetadata) { cleanupAdmixtureSelection(archForAdmixtureB); archForAdmixtureB.arch = {...currentArch}; archForAdmixtureB.weights = currentModel.getWeights().map(w => w.clone()); archForAdmixtureB.metadata = {...currentModelMetadata}; log("Arch B selected for admixture."); ui.selectArchBBtn.style.backgroundColor = '#0056b3'; ui.createAdmixtureBtn.disabled = !(archForAdmixtureA.arch && archForAdmixtureB.arch); } else { log("No current model/arch/metadata."); }
    };
    ui.createAdmixtureBtn.onclick = async () => { 
        if (!archForAdmixtureA.arch || !archForAdmixtureB.arch || !archForAdmixtureA.weights || !archForAdmixtureB.weights) { alert("Select two architectures (A and B)."); return; }
        if (archForAdmixtureA.arch.hiddenBlocks !== archForAdmixtureB.arch.hiddenBlocks || archForAdmixtureA.arch.units !== archForAdmixtureB.arch.units || archForAdmixtureA.arch.latentModulationUnits !== archForAdmixtureB.arch.latentModulationUnits) { alert("Admixture requires architectures with same HB, Units, and ModUnits."); log("Admixture failed: Incompatible architectures."); return; }
        if (archForAdmixtureA.weights.length !== archForAdmixtureB.weights.length) { alert("Admixture failed: Weight array lengths differ."); log("Admixture failed: Weight array lengths differ."); return; }
        log("Creating admixture model by averaging weights..."); const admixtureArch = {...archForAdmixtureA.arch}; const admixtureMetadata = {...archForAdmixtureA.metadata}; let totalInputDim = admixtureMetadata.visualLatentDim; if (admixtureMetadata.textPrompt && admixtureMetadata.textPrompt !== "") { if(!useModel) await loadUseModel(); if(useModel) totalInputDim += TEXT_EMBEDDING_DIM; } const admixtureModel = makeGeneratorModel(admixtureArch, totalInputDim, admixtureMetadata.colorOutput ? 3:1, `adm${generation}`); const newWeights = tf.tidy(() => { return archForAdmixtureA.weights.map((wA, i) => { const wB = archForAdmixtureB.weights[i]; if (!tf.util.arraysEqual(wA.shape, wB.shape)) { log(`Warn: Weight shape mismatch at ${i}. Using A.`); return wA.clone(); } return wA.add(wB).div(tf.scalar(2)); }); }); await admixtureModel.setWeights(newWeights); newWeights.forEach(w => w.dispose()); if (currentModel) currentModel.dispose(); if (currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) currentFullLatentForMicroLoop.dispose(); currentFullLatentForMicroLoop = null; currentModel = admixtureModel; currentArch = admixtureArch; currentModelMetadata = admixtureMetadata; generation++; log("Admixture model created."); 
        const resultLatents = await generateAndDisplayPattern(currentModel, null, admixtureMetadata.textPrompt, true); 
        if (resultLatents) { if(resultLatents.visualLatent && !resultLatents.visualLatent.isDisposed)resultLatents.visualLatent.dispose(); if(resultLatents.fullLatent && !resultLatents.fullLatent.isDisposed)resultLatents.fullLatent.dispose(); } 
        updateUIForActiveModel(true); cleanupAdmixtureSelection(archForAdmixtureA); ui.selectArchABtn.style.backgroundColor = ''; cleanupAdmixtureSelection(archForAdmixtureB); ui.selectArchBBtn.style.backgroundColor = ''; ui.createAdmixtureBtn.disabled = true;
    };
    
    ui.setLatentABtn.onclick = async () => { 
        if (currentModel) { if (latentA_visual && !latentA_visual.isDisposed) latentA_visual.dispose(); const resultLatents = await generateAndDisplayPattern(currentModel, null, ui.textPromptInp.value.trim(), true); if (resultLatents && resultLatents.visualLatent && !resultLatents.visualLatent.isDisposed) { latentA_visual = resultLatents.visualLatent; if(resultLatents.fullLatent && !resultLatents.fullLatent.isDisposed)resultLatents.fullLatent.dispose(); log("Visual Latent Point A set.");} ui.latentInterpolateSlider.disabled = !(latentA_visual && latentB_visual); }
    };
    ui.setLatentBBtn.onclick = async () => { 
        if (currentModel) { if (latentB_visual && !latentB_visual.isDisposed) latentB_visual.dispose(); const resultLatents = await generateAndDisplayPattern(currentModel, null, ui.textPromptInp.value.trim(), true); if (resultLatents && resultLatents.visualLatent && !resultLatents.visualLatent.isDisposed) { latentB_visual = resultLatents.visualLatent; if(resultLatents.fullLatent && !resultLatents.fullLatent.isDisposed)resultLatents.fullLatent.dispose(); log("Visual Latent Point B set.");} ui.latentInterpolateSlider.disabled = !(latentA_visual && latentB_visual); }
    };
    ui.latentInterpolateSlider.oninput = async () => { 
        if (latentA_visual && !latentA_visual.isDisposed && latentB_visual && !latentB_visual.isDisposed && currentModel) { if (ui.animatePatternInp.checked) { ui.animatePatternInp.checked = false; } const textPromptStr = ui.textPromptInp.value.trim(); let textEmbedding = null; let baseFullLatentForText = null; if(currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed && textPromptStr) { baseFullLatentForText = currentFullLatentForMicroLoop.clone(); } else if (textPromptStr !== "") { if(!useModel) await loadUseModel(); if(useModel) textEmbedding = await useModel.embed([textPromptStr]); }
            tf.tidy(() => { const t = parseFloat(ui.latentInterpolateSlider.value); const interpolatedVisualLatent = latentA_visual.mul(1 - t).add(latentB_visual.mul(t)); let fullInterpolatedLatent; 
                if (baseFullLatentForText) { const textPart = baseFullLatentForText.slice([0, parseInt(ui.latentDimInp.value)],[1,-1]); fullInterpolatedLatent = tf.concat([interpolatedVisualLatent, textPart],1); if(textPart && !textPart.isDisposed) textPart.dispose(); if(baseFullLatentForText && !baseFullLatentForText.isDisposed) baseFullLatentForText.dispose(); }
                else if (textEmbedding) { fullInterpolatedLatent = tf.concat([interpolatedVisualLatent, textEmbedding], 1); if(textEmbedding && !textEmbedding.isDisposed) textEmbedding.dispose(); } 
                else { fullInterpolatedLatent = interpolatedVisualLatent.clone(); } 
                generateAndDisplayPattern(currentModel, fullInterpolatedLatent, textPromptStr, false); // `false` for storeAsMicroLoopLatent
                if(fullInterpolatedLatent && !fullInterpolatedLatent.isDisposed) fullInterpolatedLatent.dispose(); // Dispose the one created for interpolation
            }); 
        }
    };
    ui.saveArchitectureBtn.onclick = async ()=>{ 
      if(!currentModel||currentModel.isDisposedInternal || !currentArch || !currentModelMetadata){ alert('No active model/architecture/metadata to save.'); return; } const ts = new Date().toISOString().replace(/[:.-]/g, '').slice(0,-4); const archFilenamePart = `arch_hb${currentArch.hiddenBlocks}_u${currentArch.units}_m${currentArch.latentModulationUnits}`; const modelFilename = `qdw-model-g${generation}-e${currentEpoch}-${archFilenamePart}-${ts}`; log(`üíæ Saving: 1) ${modelFilename}.json (+.bin weights) AND 2) ${modelFilename}-metadata.json`); try { await currentModel.save(`downloads://${modelFilename}`); const metadataToSave = {...currentModelMetadata, architecture: currentArch, sourceGlobalGen: generation, sourceEpoch: currentEpoch, timestamp: new Date().toISOString() }; const metadataStr = JSON.stringify(metadataToSave, null, 2); const metadataBlob = new Blob([metadataStr], {type: 'application/json'}); const metadataLink = document.createElement('a'); metadataLink.href = URL.createObjectURL(metadataBlob); metadataLink.download = `${modelFilename}-metadata.json`; document.body.appendChild(metadataLink); metadataLink.click(); document.body.removeChild(metadataLink); URL.revokeObjectURL(metadataLink.href); log(`‚úîÔ∏è Arch & Metadata saved! Prompt: "${metadataToSave.textPrompt}"`); alert('Architecture and Metadata saved.'); } catch(e){ log(`‚ùå Save error: ${e.message}`); alert(`Save error: ${e.message}`);}
    };
    ui.loadArchitectureBtn.onclick = async () => { 
        if (metaRunning) { alert("Stop meta-exploration before loading."); return;} log("Select BOTH model .json AND -metadata.json."); const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = '.json'; fileInput.multiple = true; fileInput.onchange = async (event) => { const files = event.target.files; if (files.length < 2) { alert("Select both files."); return; } let modelJsonFile = null, metadataJsonFile = null; for (const file of files) { if (file.name.endsWith('-metadata.json')) metadataJsonFile = file; else if (file.name.endsWith('.json')) modelJsonFile = file; } if (!modelJsonFile || !metadataJsonFile) { alert("Files not identified."); return; } log(`Loading: Model ${modelJsonFile.name}, Meta ${metadataJsonFile.name}`); try { const metadataStr = await metadataJsonFile.text(); const loadedMetadata = JSON.parse(metadataStr); log("Meta: Prompt: \"" + loadedMetadata.textPrompt + "\", Arch: " + JSON.stringify(loadedMetadata.architecture)); const modelFilesToLoad = Array.from(files).filter(f => f.name === modelJsonFile.name || f.name === modelJsonFile.name.replace(".json",".weights.bin") ); const loadedModel = await tf.loadLayersModel(tf.io.browserFiles(modelFilesToLoad)); if (currentModel && !currentModel.isDisposedInternal) { currentModel.dispose(); } currentModel = loadedModel; currentArch = loadedMetadata.architecture; currentModelMetadata = loadedMetadata; generation = loadedMetadata.sourceGlobalGen || 'loaded'; currentEpoch = loadedMetadata.sourceEpoch || 'loaded'; ui.latentDimInp.value = loadedMetadata.visualLatentDim; ui.textPromptInp.value = loadedMetadata.textPrompt || ""; ui.imgSizeInp.value = loadedMetadata.imgSize; ui.colorOutputInp.checked = loadedMetadata.colorOutput; ui.minLayersInp.value = currentArch.hiddenBlocks; ui.maxLayersInp.value = currentArch.hiddenBlocks; ui.minUnitsInp.value = currentArch.units; ui.maxUnitsInp.value = currentArch.units; if(typeof currentArch.latentModulationUnits !== 'undefined' && currentArch.units > 0) { const modPercent = Math.round((currentArch.latentModulationUnits / currentArch.units) * 100); ui.minModUnitsInp.value = modPercent; ui.maxModUnitsInp.value = modPercent; } else { ui.minModUnitsInp.value = 15; ui.maxModUnitsInp.value = 35;} updateEpochStatus(); log(`‚úîÔ∏è Arch loaded. Global Gen: ${generation}, Epoch: ${currentEpoch}`); 
        if(currentFullLatentForMicroLoop && !currentFullLatentForMicroLoop.isDisposed) currentFullLatentForMicroLoop.dispose(); currentFullLatentForMicroLoop = null;
        const resultLatents = await generateAndDisplayPattern(currentModel, null, ui.textPromptInp.value.trim(), true); 
        if (resultLatents) { if(resultLatents.visualLatent && !resultLatents.visualLatent.isDisposed) resultLatents.visualLatent.dispose(); if(resultLatents.fullLatent && !resultLatents.fullLatent.isDisposed) resultLatents.fullLatent.dispose(); } 
        updateUIForActiveModel(true); if (latentA_visual && !latentA_visual.isDisposed) latentA_visual.dispose(); if (latentB_visual && !latentB_visual.isDisposed) latentB_visual.dispose(); latentA_visual = null; latentB_visual = null; ui.latentInterpolateSlider.disabled = true; likedArchPool = []; styleReference.arch = null; ui.styleRefStatusEl.textContent = "Style Reference: None"; cleanupAdmixtureSelection(archForAdmixtureA); cleanupAdmixtureSelection(archForAdmixtureB); ui.selectArchABtn.style.backgroundColor=''; ui.selectArchBBtn.style.backgroundColor=''; ui.createAdmixtureBtn.disabled=true;} catch (e) { log(`‚ùå Load error: ${e.message}.`); console.error(e); } }; fileInput.click();
    };
    
    clearCanvas(); 
    log("Idle. Configure parameters. Press 'Start Meta-Exploration'.");
    log("USE model loads on first text use.");
    updateUIForActiveModel(false);
    updateEpochStatus();

  </script>
</body>
</html>
