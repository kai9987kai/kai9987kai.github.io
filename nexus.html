<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Quantum Nexus v5.5 - Advanced Neural Interface Enhanced</title>
  <style>
    /* Base CSS Variables and Themes */
    :root {
      --quantum-primary: #00ffaa;
      --quantum-secondary: #ff124f;
      --neural-accent: #9b59b6;
      --cyber-dark: #0a0a1f;
      --matrix-glow: #00ff9d;
      --holo-blue: rgba(52,152,219,0.2);
      --quantum-gradient: linear-gradient(135deg, var(--quantum-primary), var(--quantum-secondary));
      --neural-mesh: repeating-linear-gradient(45deg, rgba(155,89,182,0.1) 0px, transparent 1px);
      --synergy-glow: #ffde59;
      --bg-color: var(--cyber-dark);
      --text-color: #fff;
      --overlay-bg: rgba(0,0,0,0.7);
      --font-size: 14px;
      --btn-font-size: 16px;
      --btn-padding: 14px 20px;
      --toggle-size: 48px;
      --node-height: 80px;
      --node-width: 80px;
    }
    body.light-mode {
      --bg-color: #f5f5f5;
      --text-color: #000;
      --overlay-bg: rgba(255,255,255,0.8);
    }
    /* Background Animation */
    @keyframes bgGradient {
      0% { background: linear-gradient(135deg, #0a0a1f, #001f3f); }
      50% { background: linear-gradient(135deg, #001f3f, #0a0a1f); }
      100% { background: linear-gradient(135deg, #0a0a1f, #001f3f); }
    }
    body {
      background: var(--bg-color);
      color: var(--text-color);
      font-family: 'Space Grotesk', system-ui, sans-serif;
      overflow: hidden;
      perspective: 1000px;
      transition: background 0.3s, color 0.3s;
      animation: bgGradient 60s ease-in-out infinite;
      font-size: var(--font-size);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    /* Quantum Matrix Background */
    .quantum-matrix {
      position: fixed;
      inset: 0;
      background: 
        linear-gradient(rgba(10,10,31,0.95), rgba(10,10,31,0.95)),
        var(--neural-mesh),
        repeating-linear-gradient(90deg, transparent 0px, transparent 2px, rgba(0,255,170,0.1) 3px, transparent 4px);
      animation: matrixFlow 20s linear infinite;
      z-index: -1;
      mask-image: radial-gradient(circle at center, black 40%, transparent 70%);
    }
    @keyframes matrixFlow { to { --quantum-hue: 360deg; } }
    
    /* Streamlined Layout */
    .holo-interface {
      display: grid;
      grid-template-columns: 300px 1fr 300px;
      gap: 20px;
      padding: 20px;
      height: 100vh;
      transform-style: preserve-3d;
      position: relative;
    }
    
    /* Top Buttons */
    .top-buttons {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }
    .top-buttons button {
      background: var(--quantum-gradient);
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      color: var(--cyber-dark);
      transition: transform 0.2s, box-shadow 0.2s;
      font-size: var(--btn-font-size);
    }
    .top-buttons button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,255,170,0.3); }
    
    /* Additional Top Buttons for new features */
    .top-buttons .extra {
      padding: 10px 14px;
      font-size: 16px;
    }
    
    /* Simulation Info Overlay */
    .sim-info {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: var(--overlay-bg);
      color: var(--text-color);
      padding: 10px 14px;
      border-radius: 6px;
      font-family: 'Space Mono', monospace;
      z-index: 90;
      font-size: 13px;
    }
    
    /* Neural Command Section */
    .neural-command {
      background: rgba(10,10,31,0.85);
      border: 1px solid var(--quantum-primary);
      border-radius: 12px;
      padding: 16px;
      backdrop-filter: blur(8px);
      transform-style: preserve-3d;
      animation: commandFloat 6s infinite ease-in-out;
      position: relative;
    }
    @keyframes commandFloat { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
    
    .quantum-visualization {
      position: relative;
      height: 300px;
      background: rgba(0,255,170,0.05);
      border-radius: 8px;
      overflow: hidden;
      transform-style: preserve-3d;
    }
    
    .neural-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin: 16px 0;
    }
    /* Neural Node Buttons – taller, with pulsating hover effect */
    .neural-node {
      background: rgba(0,255,170,0.1);
      border: 2px solid var(--quantum-primary);
      border-radius: 8px;
      position: relative;
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      height: var(--node-height);
      width: var(--node-width);
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
    }
    .neural-node:hover {
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 var(--quantum-primary); }
      50% { box-shadow: 0 0 10px 4px var(--quantum-primary); }
      100% { box-shadow: 0 0 0 0 var(--quantum-primary); }
    }
    .neural-node::before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 110%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.75);
      color: #fff;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    .neural-node:hover::before { opacity: 1; }
    .neural-node.active {
      transform: translateZ(20px);
      box-shadow: 0 0 20px var(--quantum-primary);
    }
    
    /* Quantum Gates Section */
    .quantum-gates {
      margin: 16px 0;
    }
    .gates-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    .gate-btn {
      background: var(--quantum-gradient);
      color: var(--cyber-dark);
      border: none;
      border-radius: 6px;
      padding: 10px;
      cursor: pointer;
      font-family: 'Space Mono', monospace;
      font-size: 14px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .gate-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,255,170,0.3);
    }
    .gate-btn.selected {
      box-shadow: 0 0 10px var(--quantum-primary);
    }
    
    .quantum-console {
      background: rgba(10,10,31,0.9);
      border: 1px solid var(--neural-accent);
      border-radius: 6px;
      padding: 12px;
      font-family: 'Space Mono', monospace;
      height: 180px;
      overflow-y: auto;
      margin: 16px 0;
      font-size: 12px;
    }
    .quantum-console::-webkit-scrollbar { width: 4px; background: rgba(0,255,170,0.1); }
    .quantum-console::-webkit-scrollbar-thumb { background: var(--quantum-primary); border-radius: 4px; }
    
    .command-interface { display: flex; gap: 10px; margin: 16px 0; }
    .quantum-input {
      flex: 1;
      background: rgba(10,10,31,0.8);
      border: 1px solid var(--quantum-primary);
      border-radius: 6px;
      color: var(--quantum-primary);
      padding: 10px 14px;
      font-family: 'Space Mono', monospace;
      font-size: 12px;
    }
    .quantum-button {
      background: var(--quantum-gradient);
      color: var(--cyber-dark);
      border: none;
      border-radius: 6px;
      padding: var(--btn-padding);
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s;
      font-size: var(--btn-font-size);
    }
    .quantum-button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,255,170,0.3); }
    
    .voice-button {
      background: var(--neural-accent);
      border: none;
      border-radius: 50%;
      width: var(--toggle-size);
      height: var(--toggle-size);
      cursor: pointer;
      font-size: 20px;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Modal Styles */
    .research-modal, .chat-modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .research-modal-content, .chat-modal-content {
      background: rgba(10,10,31,0.95);
      padding: 16px;
      border-radius: 8px;
      max-width: 480px;
      width: 90%;
      box-shadow: 0 0 20px var(--matrix-glow);
      text-align: center;
      font-family: 'Space Mono', monospace;
      position: relative;
      font-size: 12px;
    }
    .research-close, .chat-close {
      position: absolute;
      top: 8px;
      right: 12px;
      font-size: 20px;
      cursor: pointer;
    }
    .research-modal-content ul { list-style: none; padding: 0; }
    .research-modal-content li { margin: 8px 0; }
    .research-modal-content a {
      color: var(--quantum-primary);
      text-decoration: none;
      font-weight: bold;
    }
    .research-modal-content a:hover { text-decoration: underline; }
    .chat-messages {
      height: 180px;
      overflow-y: auto;
      border: 1px solid var(--neural-accent);
      border-radius: 6px;
      padding: 8px;
      margin: 8px 0;
      background: rgba(0,0,0,0.6);
      text-align: left;
      font-size: 12px;
    }
    .chat-input {
      width: 100%;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid var(--quantum-primary);
      font-family: 'Space Mono', monospace;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="quantum-matrix"></div>

  <!-- Top Buttons -->
  <div class="top-buttons">
    <button id="darkModeToggle">Toggle Dark Mode</button>
    <button id="chatBtn">Chat</button>
    <button id="soundToggle">Sound On</button>
    <button id="saveSnapshotBtn">Save Snapshot</button>
    <button class="extra" id="toggleTrailsBtn">Toggle Trails</button>
    <button class="extra" id="cycleThemeBtn">Cycle Theme</button>
  </div>

  <!-- Simulation Info Overlay -->
  <div class="sim-info" id="simInfo">
    Energy: 100 | Coherence: 100 | Entanglement: 0 | Synergy: 0 | Speed: 1x | Active Nodes: 0
  </div>
  
  <div class="holo-interface">
    <!-- Research Modal Button -->
    <button class="research-button" id="researchBtn">Research</button>
    
    <section class="neural-command">
      <h2>Quantum Neural Interface</h2>
      <div class="quantum-visualization" id="neuralViz">
        <!-- Visualization Canvas -->
      </div>
      
      <div class="neural-grid" id="neuralGrid"></div>
      
      <div class="quantum-gates">
        <h3>Quantum Gates</h3>
        <div class="gates-grid">
          <button class="gate-btn" data-gate="H">H</button>
          <button class="gate-btn" data-gate="X">X</button>
          <button class="gate-btn" data-gate="Y">Y</button>
          <button class="gate-btn" data-gate="Z">Z</button>
          <button class="gate-btn" data-gate="CNOT">CNOT</button>
          <button class="gate-btn" data-gate="Measure">Measure</button>
        </div>
      </div>
      
      <div class="command-interface">
        <input type="text" class="quantum-input" placeholder="Enter command (reset, status, entangle, superpose, synergy, research, help)...">
        <button class="voice-button" id="voiceBtn">🎤</button>
        <button class="quantum-button" id="executeBtn">Execute</button>
      </div>
      
      <div class="speed-control">
        <label for="speedSlider">Simulation Speed:</label>
        <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1" style="width:100%; height:32px;">
      </div>
      
      <div class="quantum-console" id="quantumConsole"></div>
      <button class="quantum-button" id="clearConsoleBtn">Clear Console</button>
    </section>
  </div>

  <!-- Research Modal -->
  <div id="researchModal" class="research-modal">
    <div class="research-modal-content">
      <span class="research-close" id="modalCloseBtn">×</span>
      <h2>Recent Research Papers</h2>
      <ul id="researchList">
        <li><a href="https://www.mdpi.com/1099-4300/25/4/694" target="_blank">Programming Quantum Neural Networks on NISQ Systems</a> cite</li>
        <li><a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC9100496/" target="_blank">Optoelectronic Neural Interfaces Based on Quantum Dots</a> cite</li>
        <li><a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC7243676/" target="_blank">Next-generation Interfaces for Studying Neural Function</a> cite</li>
        <li><a href="https://www.nature.com/articles/s41467-020-20729-5" target="_blank">A Co-design Framework of Neural Networks and Quantum Circuits</a> cite</li>
      </ul>
    </div>
  </div>
  
  <!-- Chat Modal -->
  <div id="chatModal" class="chat-modal">
    <div class="chat-modal-content">
      <span class="chat-close" id="chatCloseBtn">×</span>
      <h2>Quantum Chat Assistant</h2>
      <div class="chat-messages" id="chatMessages"></div>
      <input type="text" class="chat-input" id="chatInput" placeholder="Type your message...">
      <button class="quantum-button" id="sendChatBtn">Send</button>
    </div>
  </div>

  <script>
    class QuantumNeuralCore {
      constructor() {
        this.nodes = new Map();
        this.quantumState = { energy: 100, coherence: 100, entanglement: 0, synergy: 0 };
        this.simulationSpeed = 1;
        this.audioOn = false;
        this.trailsEnabled = false;
        this.themeIndex = 0;
        this.themes = [
          { particle: 'rgba(0,255,170,0.8)', nodeBorder: '#00ffaa' },
          { particle: 'rgba(255,100,0,0.8)', nodeBorder: '#ff124f' },
          { particle: 'rgba(150,0,200,0.8)', nodeBorder: '#9b59b6' }
        ];
        this.currentGate = null;
        this.selectedNodes = [];
        this.initialize();
      }

      initialize() {
        this.setupNeuralGrid();
        this.setupGateButtons();
        this.loadState();
        this.initializeVisualizer();
        this.setupEventListeners();
        this.startQuantumSimulation();
        this.updateNodesUI();
        this.updateSimInfo();
        this.logQuantumEvent('Quantum Neural Interface Initialized');
        this.startAnomalyEvents();
        this.setupKeyboardShortcuts();
      }

      setupNeuralGrid() {
        const grid = document.getElementById('neuralGrid');
        const nodeTypes = ['quantum', 'neural', 'temporal', 'spatial', 'entangle', 'collapse', 'superpose', 'teleport'];
        nodeTypes.forEach(type => {
          const node = document.createElement('div');
          node.className = 'neural-node';
          node.dataset.type = type;
          node.dataset.tooltip = `${type} node: inactive`;
          node.addEventListener('click', () => {
            if (this.currentGate) {
              this.applyGateToNode(node);
            } else {
              this.activateNode(node);
            }
          });
          grid.appendChild(node);
          this.nodes.set(type, { active: false, energy: 100 });
        });
      }

      setupGateButtons() {
        const gateBtns = document.querySelectorAll('.gate-btn');
        gateBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            this.currentGate = btn.dataset.gate;
            document.querySelectorAll('.gate-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            if (this.currentGate === 'CNOT') {
              this.selectedNodes = [];
              this.logQuantumEvent('Select control node for CNOT');
            } else if (this.currentGate === 'Measure') {
              this.logQuantumEvent('Select node to measure');
            } else {
              this.logQuantumEvent(`Select node to apply ${this.currentGate} gate`);
            }
          });
        });
      }

      applyGateToNode(node) {
        const type = node.dataset.type;
        const state = this.nodes.get(type);
        if (!state.active) {
          this.logQuantumEvent('Node must be active to apply gate');
          return;
        }
        if (this.currentGate === 'CNOT') {
          if (this.selectedNodes.length < 2) {
            if (!this.selectedNodes.includes(type)) {
              this.selectedNodes.push(type);
              if (this.selectedNodes.length === 1) {
                this.logQuantumEvent(`Control node selected: ${type}. Select target node.`);
              } else if (this.selectedNodes.length === 2) {
                this.applyCNOT(this.selectedNodes[0], type);
                this.selectedNodes = [];
                this.currentGate = null;
                document.querySelectorAll('.gate-btn').forEach(b => b.classList.remove('selected'));
              }
            } else {
              this.logQuantumEvent('Cannot select the same node twice for CNOT');
            }
          }
        } else {
          if (this.currentGate === 'Measure') {
            this.measureNode(type);
          } else {
            this.applySingleQubitGate(this.currentGate, type);
          }
          this.currentGate = null;
          document.querySelectorAll('.gate-btn').forEach(b => b.classList.remove('selected'));
        }
      }

      applySingleQubitGate(gate, type) {
        switch (gate) {
          case 'H':
            this.quantumState.coherence += 10;
            this.quantumState.energy -= 5;
            this.logQuantumEvent(`Applied Hadamard gate to ${type} node`);
            break;
          case 'X':
            const stateX = this.nodes.get(type);
            stateX.active = !stateX.active;
            this.updateNodesUI();
            this.logQuantumEvent(`Applied X gate to ${type} node, toggled activation`);
            break;
          case 'Y':
            this.quantumState.coherence -= 5;
            this.quantumState.energy -= 3;
            this.logQuantumEvent(`Applied Y gate to ${type} node`);
            break;
          case 'Z':
            this.quantumState.coherence -= 3;
            this.quantumState.energy -= 2;
            this.logQuantumEvent(`Applied Z gate to ${type} node`);
            break;
        }
        this.saveState();
      }

      applyCNOT(controlType, targetType) {
        this.quantumState.entanglement += 15;
        this.quantumState.coherence -= 5;
        this.logQuantumEvent(`Applied CNOT gate with control ${controlType} and target ${targetType}`);
        this.saveState();
      }

      measureNode(type) {
        const state = this.nodes.get(type);
        state.active = false;
        this.updateNodesUI();
        this.quantumState.coherence -= 10;
        this.quantumState.energy += 20;
        this.logQuantumEvent(`Measured ${type} node, deactivated and gained energy`);
        this.saveState();
      }

      updateNodesUI() {
        let activeCount = 0;
        this.nodes.forEach((state, type) => {
          const nodeEl = document.querySelector(`[data-type="${type}"]`);
          if (nodeEl) {
            if (state.active) {
              nodeEl.classList.add('active');
              nodeEl.dataset.tooltip = `${type} node: active`;
              activeCount++;
            } else {
              nodeEl.classList.remove('active');
              nodeEl.dataset.tooltip = `${type} node: inactive`;
            }
          }
        });
        this.activeNodesCount = activeCount;
      }

      loadState() {
        const savedState = localStorage.getItem('quantumState');
        if (savedState) {
          this.quantumState = JSON.parse(savedState);
        }
        const savedNodes = localStorage.getItem('nodesState');
        if (savedNodes) {
          const nodesState = JSON.parse(savedNodes);
          this.nodes.forEach((state, type) => {
            if (nodesState[type]) {
              state.active = nodesState[type].active;
              state.energy = nodesState[type].energy;
            }
          });
        }
      }

      saveState() {
        localStorage.setItem('quantumState', JSON.stringify(this.quantumState));
        const nodesState = {};
        this.nodes.forEach((state, type) => {
          nodesState[type] = { active: state.active, energy: state.energy };
        });
        localStorage.setItem('nodesState', JSON.stringify(nodesState));
      }

      initializeVisualizer() {
        const viz = document.getElementById('neuralViz');
        const canvas = document.createElement('canvas');
        viz.appendChild(canvas);
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
        this.initializeParticles();
      }

      resizeCanvas() {
        if (this.canvas && this.ctx) {
          this.canvas.width = document.getElementById('neuralViz').clientWidth;
          this.canvas.height = document.getElementById('neuralViz').clientHeight;
        }
      }

      initializeParticles() {
        this.particles = Array.from({ length: 50 }, () => ({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          radius: Math.random() * 3 + 1,
          color: this.themes[this.themeIndex].particle
        }));
      }

      startQuantumSimulation() {
        let lastTime = 0;
        const animate = (timestamp) => {
          const delta = (timestamp - lastTime) * this.simulationSpeed;
          lastTime = timestamp;
          if (!this.trailsEnabled) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          } else {
            this.ctx.fillStyle = 'rgba(10,10,31,0.05)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          }
          this.updateParticles(delta);
          this.renderVisualizer();
          this.updateQuantumState();
          this.updateSimInfo();
          requestAnimationFrame(animate);
        };
        requestAnimationFrame(animate);
      }

      updateParticles(delta) {
        const activeCount = this.activeNodesCount || 0;
        this.particles.forEach(p => {
          p.x += p.vx * (1 + activeCount * 0.1) * (delta / 16);
          p.y += p.vy * (1 + activeCount * 0.1) * (delta / 16);
          if (p.x < 0 || p.x > this.canvas.width) p.vx *= -1;
          if (p.y < 0 || p.y > this.canvas.height) p.vy *= -1;
        });
      }

      renderVisualizer() {
        this.particles.forEach(p => {
          const gradient = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius);
          gradient.addColorStop(0, p.color);
          gradient.addColorStop(1, 'rgba(0,255,170,0)');
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          this.ctx.fillStyle = gradient;
          this.ctx.fill();
        });
      }

      activateNode(node) {
        const type = node.dataset.type;
        const state = this.nodes.get(type);
        if (state) {
          state.active = !state.active;
          node.classList.toggle('active');
          node.dataset.tooltip = `${type} node: ${state.active ? 'active' : 'inactive'}`;
          this.logQuantumEvent(`${type} node ${state.active ? 'activated' : 'deactivated'}`);
          this.updateQuantumState();
          this.saveState();
          this.updateNodesUI();
          this.playBeep();
        }
      }

      updateQuantumState() {
        const activeNodes = Array.from(this.nodes.values()).filter(state => state.active);
        this.quantumState.energy = Math.max(0, 100 - activeNodes.length * 0.5);
        this.quantumState.coherence = Math.max(0, 100 - activeNodes.length * 3);
        this.quantumState.entanglement = activeNodes.length * 12.5;
        if (this.quantumState.synergy > 0) {
          this.quantumState.energy += this.quantumState.synergy;
          this.quantumState.coherence += this.quantumState.synergy * 0.5;
          this.logQuantumEvent(`Synergy activated! Energy boosted by ${this.quantumState.synergy.toFixed(2)}`);
          this.quantumState.synergy *= 0.95;
        }
        if (activeNodes.length > 0) {
          this.logQuantumEvent(`Quantum state updated – Energy: ${this.quantumState.energy.toFixed(2)}, Coherence: ${this.quantumState.coherence.toFixed(2)}, Entanglement: ${this.quantumState.entanglement.toFixed(2)}`);
        }
        this.saveState();
      }

      updateSimInfo() {
        const simInfo = document.getElementById('simInfo');
        simInfo.textContent = `Energy: ${this.quantumState.energy.toFixed(2)} | Coherence: ${this.quantumState.coherence.toFixed(2)} | Entanglement: ${this.quantumState.entanglement.toFixed(2)} | Synergy: ${this.quantumState.synergy.toFixed(2)} | Speed: ${this.simulationSpeed}x | Active Nodes: ${this.activeNodesCount || 0}`;
      }

      logQuantumEvent(message) {
        const consoleEl = document.getElementById('quantumConsole');
        const log = document.createElement('div');
        log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        consoleEl.appendChild(log);
        consoleEl.scrollTop = consoleEl.scrollHeight;
      }

      setupEventListeners() {
        const input = document.querySelector('.quantum-input');
        const executeBtn = document.getElementById('executeBtn');
        const clearConsoleBtn = document.getElementById('clearConsoleBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        executeBtn.addEventListener('click', () => {
          const command = input.value.trim();
          if (command) {
            this.executeCommand(command);
            input.value = '';
          }
        });
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') executeBtn.click();
        });
        clearConsoleBtn.addEventListener('click', () => {
          document.getElementById('quantumConsole').innerHTML = '';
          this.logQuantumEvent('Console cleared');
        });
        document.getElementById('researchBtn').addEventListener('click', () => this.showResearchModal());
        document.getElementById('modalCloseBtn').addEventListener('click', () => this.hideResearchModal());
        document.getElementById('chatBtn').addEventListener('click', () => this.showChatModal());
        document.getElementById('chatCloseBtn').addEventListener('click', () => this.hideChatModal());
        document.getElementById('sendChatBtn').addEventListener('click', () => this.sendChatMessage());
        voiceBtn.addEventListener('click', () => this.startVoiceRecognition());
        document.getElementById('speedSlider').addEventListener('input', (e) => {
          this.simulationSpeed = parseFloat(e.target.value);
        });
        document.getElementById('darkModeToggle').addEventListener('click', () => {
          document.body.classList.toggle('light-mode');
        });
        document.getElementById('saveSnapshotBtn').addEventListener('click', () => this.saveSnapshot());
        document.getElementById('soundToggle').addEventListener('click', () => this.toggleAmbientSound());
        document.getElementById('toggleTrailsBtn').addEventListener('click', () => this.toggleTrails());
        document.getElementById('cycleThemeBtn').addEventListener('click', () => this.cycleTheme());
      }

      executeCommand(command) {
        this.logQuantumEvent(`Executing command: ${command}`);
        const commandEffects = {
          reset: () => this.resetSystem(),
          status: () => this.showStatus(),
          entangle: () => this.entangleNodes(),
          superpose: () => this.superpose(),
          synergy: () => this.synergizeNodes(),
          research: () => this.showResearchModal(),
          help: () => this.showHelp()
        };
        const effect = commandEffects[command.toLowerCase()];
        if (effect) effect();
        else this.logQuantumEvent('Unknown command');
      }

      showHelp() {
        this.logQuantumEvent('Available commands: reset, status, entangle, superpose, synergy, research, help');
        this.logQuantumEvent('Available gates: H, X, Y, Z, CNOT, Measure');
      }

      resetSystem() {
        this.nodes.forEach((state, type) => {
          state.active = false;
          const nodeEl = document.querySelector(`[data-type="${type}"]`);
          if (nodeEl) nodeEl.classList.remove('active');
        });
        Object.assign(this.quantumState, { energy: 100, coherence: 100, entanglement: 0, synergy: 0 });
        this.logQuantumEvent('System reset complete');
        this.saveState();
        this.updateNodesUI();
      }

      showStatus() {
        const status = Object.entries(this.quantumState)
          .map(([k, v]) => `${k}: ${v.toFixed(2)}`)
          .join(', ');
        this.logQuantumEvent(`System Status – ${status}`);
      }

      entangleNodes() {
        const activeNodes = Array.from(this.nodes.entries()).filter(([_, state]) => state.active);
        if (activeNodes.length >= 2) {
          this.quantumState.entanglement += 10;
          this.logQuantumEvent(`Entangled ${activeNodes.length} nodes`);
        } else {
          this.logQuantumEvent('Need at least 2 active nodes for entanglement');
        }
        this.saveState();
      }

      superpose() {
        const activeNode = Array.from(this.nodes.entries()).find(([_, state]) => state.active);
        if (activeNode) {
          this.quantumState.coherence += 5;
          this.logQuantumEvent(`Superposition achieved for ${activeNode[0]} node`);
        } else {
          this.logQuantumEvent('Need an active node for superposition');
        }
        this.saveState();
      }

      synergizeNodes() {
        const activeNodes = Array.from(this.nodes.entries()).filter(([_, state]) => state.active);
        if (activeNodes.length >= 2) {
          const boost = activeNodes.length * 2;
          this.quantumState.synergy += boost;
          this.logQuantumEvent(`Synergized ${activeNodes.length} nodes – synergy boost: ${boost}`);
        } else {
          this.logQuantumEvent('Need at least 2 active nodes for synergy');
        }
        this.saveState();
      }

      showResearchModal() {
        this.logQuantumEvent("Displaying recent research papers");
        document.getElementById('researchModal').style.display = 'flex';
      }

      hideResearchModal() {
        document.getElementById('researchModal').style.display = 'none';
      }

      showChatModal() {
        this.logQuantumEvent("Opening Quantum Chat Assistant");
        document.getElementById('chatModal').style.display = 'flex';
      }

      hideChatModal() {
        document.getElementById('chatModal').style.display = 'none';
      }

      sendChatMessage() {
        const chatInput = document.getElementById('chatInput');
        const message = chatInput.value.trim();
        if (message) {
          this.appendChatMessage("User", message);
          setTimeout(() => {
            const response = this.generateChatResponse(message);
            this.appendChatMessage("Quantum Assistant", response);
          }, 1000);
          chatInput.value = '';
        }
      }

      appendChatMessage(sender, message) {
        const chatMessages = document.getElementById('chatMessages');
        const msgDiv = document.createElement('div');
        msgDiv.textContent = `${sender}: ${message}`;
        chatMessages.appendChild(msgDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      generateChatResponse(userMsg) {
        userMsg = userMsg.toLowerCase();
        if (userMsg.includes('hello')) return "Hello! How can I assist with quantum operations today?";
        if (userMsg.includes('status')) return `Current state: Energy ${this.quantumState.energy.toFixed(2)}, Coherence ${this.quantumState.coherence.toFixed(2)}.`;
        if (userMsg.includes('gate')) return "Quantum gates like H, X, Y, Z, CNOT can be applied to active nodes to manipulate the quantum state.";
        if (userMsg.includes('measure')) return "Measuring a node collapses its state, deactivating it and affecting the system's coherence and energy.";
        if (userMsg.includes('help')) return "Available commands: reset, status, entangle, superpose, synergy, research, help. Available gates: H, X, Y, Z, CNOT, Measure.";
        return "I'm still learning—could you elaborate on your query?";
      }

      startVoiceRecognition() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          alert("Voice recognition not supported in this browser.");
          return;
        }
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        recognition.start();
        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          document.querySelector('.quantum-input').value = transcript;
          this.logQuantumEvent(`Voice command recognized: ${transcript}`);
        };
        recognition.onerror = (event) => {
          this.logQuantumEvent(`Voice recognition error: ${event.error}`);
        };
      }

      playBeep() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = ctx.createOscillator();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, ctx.currentTime);
        oscillator.connect(ctx.destination);
        oscillator.start();
        oscillator.stop(ctx.currentTime + 0.1);
      }

      startAnomalyEvents() {
        setInterval(() => {
          this.particles.forEach(p => {
            if (Math.random() < 0.05) {
              p.color = `rgba(${Math.floor(Math.random()*256)}, ${Math.floor(Math.random()*256)}, ${Math.floor(Math.random()*256)}, 0.8)`;
              this.logQuantumEvent("Quantum anomaly: Particle color shift detected.");
            }
          });
        }, 5000);
      }

      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          switch (e.key.toLowerCase()) {
            case 'r': this.resetSystem(); break;
            case 's': this.showStatus(); break;
            case 'e': this.entangleNodes(); break;
            case 'p': this.superpose(); break;
            case 'y': this.synergizeNodes(); break;
            case 'd':
              const researchModal = document.getElementById('researchModal');
              researchModal.style.display = (researchModal.style.display === 'flex') ? 'none' : 'flex';
              break;
            case 'c':
              const chatModal = document.getElementById('chatModal');
              chatModal.style.display = (chatModal.style.display === 'flex') ? 'none' : 'flex';
              break;
          }
        });
      }

      saveSnapshot() {
        const snapshot = {
          quantumState: this.quantumState,
          particles: this.particles,
          nodes: Array.from(this.nodes.entries()).map(([type, state]) => ({ type, ...state }))
        };
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(snapshot, null, 2));
        const dlAnchorElem = document.createElement('a');
        dlAnchorElem.setAttribute("href", dataStr);
        dlAnchorElem.setAttribute("download", "quantum_snapshot.json");
        document.body.appendChild(dlAnchorElem);
        dlAnchorElem.click();
        dlAnchorElem.remove();
        this.logQuantumEvent("Snapshot saved.");
      }

      toggleAmbientSound() {
        if (!this.audioCtx) {
          this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          this.oscillator = this.audioCtx.createOscillator();
          this.oscillator.type = 'sine';
          this.oscillator.frequency.setValueAtTime(220, this.audioCtx.currentTime);
          this.oscillator.connect(this.audioCtx.destination);
          this.oscillator.start();
          this.audioOn = true;
          document.getElementById('soundToggle').textContent = "Sound Off";
          this.logQuantumEvent("Ambient sound enabled.");
        } else {
          this.oscillator.stop();
          this.audioCtx.close();
          this.audioCtx = null;
          this.audioOn = false;
          document.getElementById('soundToggle').textContent = "Sound On";
          this.logQuantumEvent("Ambient sound disabled.");
        }
      }

      toggleTrails() {
        this.trailsEnabled = !this.trailsEnabled;
        this.logQuantumEvent(`Particle trails ${this.trailsEnabled ? 'enabled' : 'disabled'}`);
      }

      cycleTheme() {
        this.themeIndex = (this.themeIndex + 1) % this.themes.length;
        const newTheme = this.themes[this.themeIndex];
        this.particles.forEach(p => p.color = newTheme.particle);
        document.querySelectorAll('.neural-node').forEach(node => {
          node.style.borderColor = newTheme.nodeBorder;
        });
        this.logQuantumEvent(`Theme cycled to index ${this.themeIndex}`);
      }
    }

    // Initialize the Quantum Neural Core
    const quantumCore = new QuantumNeuralCore();

    // Chat input Enter key handler
    document.getElementById('chatInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        document.getElementById('sendChatBtn').click();
      }
    });
  </script>
</body>
</html>
