```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROJECT 1X4G Super Brain Simulation</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #1e1e2e;
            color: #f8f8f2;
            margin: 0;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .simulation-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .panel {
            background-color: #2a2a3a;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }
        .visualization {
            flex: 2;
            min-width: 300px;
        }
        .controls {
            flex: 1;
            min-width: 250px;
        }
        canvas {
            width: 100%;
            background-color: #000;
            border-radius: 4px;
        }
        h1, h2, h3 {
            color: #bd93f9;
        }
        button {
            background-color: #6272a4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #8be9fd;
            color: #282a36;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
        }
        .component {
            margin: 15px 0;
            border-top: 1px solid #44475a;
            padding-top: 15px;
        }
        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stat-box {
            background-color: #44475a;
            padding: 8px;
            border-radius: 4px;
            min-width: 100px;
            text-align: center;
        }
        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: #f1fa8c;
        }
        .logs {
            height: 150px;
            overflow-y: auto;
            background-color: #282a36;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            margin-top: 10px;
        }
        .log-entry {
            margin: 2px 0;
            font-size: 0.9em;
        }
        .info-tooltip {
            display: inline-block;
            margin-left: 5px;
            background-color: #6272a4;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            text-align: center;
            font-size: 12px;
            cursor: help;
            position: relative;
        }
        .info-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 24px;
            top: -5px;
            width: 200px;
            background-color: #44475a;
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            font-size: 14px;
            font-family: Arial, sans-serif;
            text-align: left;
        }
        .tabs {
            display: flex;
            margin-bottom: 10px;
        }
        .tab {
            padding: 8px 16px;
            background-color: #44475a;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            margin-right: 2px;
        }
        .tab.active {
            background-color: #6272a4;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PROJECT 1X4G: Hybrid Super Brain Simulation</h1>
            <p>Neural-Quantum-Biological System with Genetic Modification</p>
        </div>
        
        <div class="simulation-container">
            <div class="panel visualization">
                <h2>Simulation Visualization</h2>
                <div class="tabs">
                    <div class="tab active" data-tab="grn">Gene Regulatory Network</div>
                    <div class="tab" data-tab="neurons">Neural Activity</div>
                    <div class="tab" data-tab="learning">Learning Progress</div>
                </div>
                <div class="tab-content active" id="grn-tab">
                    <canvas id="grn-canvas" height="300"></canvas>
                    <div class="component">
                        <h3>GRN State Visualization</h3>
                        <div id="grn-state-display"></div>
                    </div>
                </div>
                <div class="tab-content" id="neurons-tab">
                    <canvas id="neurons-canvas" height="300"></canvas>
                    <div class="component">
                        <h3>Neural Activity Monitor</h3>
                        <canvas id="spike-monitor" height="150"></canvas>
                    </div>
                </div>
                <div class="tab-content" id="learning-tab">
                    <canvas id="learning-canvas" height="300"></canvas>
                    <div class="component">
                        <h3>Reward History</h3>
                        <canvas id="reward-chart" height="150"></canvas>
                    </div>
                </div>
                
                <div class="component">
                    <h3>System Statistics</h3>
                    <div class="stats">
                        <div class="stat-box">
                            <div>Episode</div>
                            <div class="value" id="episode-count">0</div>
                        </div>
                        <div class="stat-box">
                            <div>Current Reward</div>
                            <div class="value" id="current-reward">0.00</div>
                        </div>
                        <div class="stat-box">
                            <div>Avg Reward</div>
                            <div class="value" id="avg-reward">0.00</div>
                        </div>
                        <div class="stat-box">
                            <div>Error</div>
                            <div class="value" id="error-value">0.00</div>
                        </div>
                    </div>
                </div>
                
                <div class="component">
                    <h3>System Logs</h3>
                    <div class="logs" id="log-container"></div>
                </div>
            </div>
            
            <div class="panel controls">
                <h2>Simulation Controls</h2>
                <div class="component">
                    <button id="start-btn">Start Simulation</button>
                    <button id="pause-btn">Pause</button>
                    <button id="reset-btn">Reset</button>
                </div>
                
                <div class="component">
                    <h3>Environment Parameters</h3>
                    <div class="slider-container">
                        <label for="num-genes">Number of Genes: <span id="num-genes-value">10</span>
                            <span class="info-tooltip" data-tooltip="Number of genes in the Gene Regulatory Network.">?</span>
                        </label>
                        <input type="range" id="num-genes" min="5" max="20" value="10">
                    </div>
                    <div class="slider-container">
                        <label for="interaction-strength">Gene Interaction Strength: <span id="interaction-strength-value">0.5</span>
                            <span class="info-tooltip" data-tooltip="Controls the strength of gene-to-gene interactions.">?</span>
                        </label>
                        <input type="range" id="interaction-strength" min="0.1" max="1.0" step="0.1" value="0.5">
                    </div>
                    <div class="slider-container">
                        <label for="env-noise">Environment Noise: <span id="env-noise-value">0.1</span>
                            <span class="info-tooltip" data-tooltip="Amount of random noise added to gene expression levels.">?</span>
                        </label>
                        <input type="range" id="env-noise" min="0" max="0.5" step="0.05" value="0.1">
                    </div>
                </div>
                
                <div class="component">
                    <h3>Neural System Parameters</h3>
                    <div class="slider-container">
                        <label for="bio-neurons">Biological Neurons: <span id="bio-neurons-value">100</span>
                            <span class="info-tooltip" data-tooltip="Number of simulated biological neurons.">?</span>
                        </label>
                        <input type="range" id="bio-neurons" min="50" max="200" step="10" value="100">
                    </div>
                    <div class="slider-container">
                        <label for="snn-neurons">Neuromorphic Neurons: <span id="snn-neurons-value">1000</span>
                            <span class="info-tooltip" data-tooltip="Number of neurons in the simulated neuromorphic chip.">?</span>
                        </label>
                        <input type="range" id="snn-neurons" min="500" max="2000" step="100" value="1000">
                    </div>
                    <div class="slider-container">
                        <label for="firing-threshold">Firing Threshold (mV): <span id="firing-threshold-value">-50</span>
                            <span class="info-tooltip" data-tooltip="Membrane potential threshold for neuron firing.">?</span>
                        </label>
                        <input type="range" id="firing-threshold" min="-70" max="-30" step="1" value="-50">
                    </div>
                </div>
                
                <div class="component">
                    <h3>Learning Parameters</h3>
                    <div class="slider-container">
                        <label for="learning-rate">Learning Rate: <span id="learning-rate-value">0.001</span>
                            <span class="info-tooltip" data-tooltip="Step size for the reinforcement learning algorithm.">?</span>
                        </label>
                        <input type="range" id="learning-rate" min="0.0001" max="0.01" step="0.0001" value="0.001">
                    </div>
                    <div class="slider-container">
                        <label for="discount-factor">Discount Factor: <span id="discount-factor-value">0.99</span>
                            <span class="info-tooltip" data-tooltip="Weight given to future rewards (γ in RL).">?</span>
                        </label>
                        <input type="range" id="discount-factor" min="0.8" max="0.999" step="0.001" value="0.99">
                    </div>
                    <div class="slider-container">
                        <label for="exploration-rate">Exploration Rate: <span id="exploration-rate-value">0.2</span>
                            <span class="info-tooltip" data-tooltip="Probability of taking a random action (ε in ε-greedy).">?</span>
                        </label>
                        <input type="range" id="exploration-rate" min="0.01" max="0.5" step="0.01" value="0.2">
                    </div>
                </div>
                
                <div class="component">
                    <h3>Genetic Modification</h3>
                    <div class="slider-container">
                        <label for="gene-mod-interval">Modification Interval: <span id="gene-mod-interval-value">100</span>
                            <span class="info-tooltip" data-tooltip="Number of episodes between genetic modifications.">?</span>
                        </label>
                        <input type="range" id="gene-mod-interval" min="10" max="500" step="10" value="100">
                    </div>
                    <div class="slider-container">
                        <label for="mod-strength">Modification Strength: <span id="mod-strength-value">0.1</span>
                            <span class="info-tooltip" data-tooltip="Magnitude of genetic parameter changes.">?</span>
                        </label>
                        <input type="range" id="mod-strength" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>
                    <button id="apply-gene-mod">Force Genetic Modification</button>
                </div>
                
                <div class="component">
                    <h3>Quantum Processor</h3>
                    <div class="slider-container">
                        <label for="quantum-influence">Quantum Influence: <span id="quantum-influence-value">0.3</span>
                            <span class="info-tooltip" data-tooltip="Degree to which quantum randomness affects decision-making.">?</span>
                        </label>
                        <input type="range" id="quantum-influence" min="0" max="1" step="0.05" value="0.3">
                    </div>
                    <button id="quantum-enhance">Apply Quantum Enhancement</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Main simulation code
        class Project1X4GSimulation {
            constructor() {
                // Initialize simulation state FIRST
                this.running = false;
                this.episodeCount = 0;
                this.stepCount = 0;
                this.rewardHistory = [];
                this.logs = [];
                
                // Then initialize simulation components
                this.initializeParameters();
                this.initializeGRN();
                this.initializeBioNeurons();
                this.initializeNeuromorphicChip();
                this.initializeQuantumProcessor();
                this.initializeReinforcementLearning();
                
                // Setup UI handlers
                this.setupUIHandlers();
                this.setupVisualization();
                
                this.logMessage("System initialized successfully!");
            }
            
            initializeParameters() {
                // Environment parameters
                this.numGenes = parseInt(document.getElementById('num-genes').value);
                this.interactionStrength = parseFloat(document.getElementById('interaction-strength').value);
                this.envNoise = parseFloat(document.getElementById('env-noise').value);
                
                // Neural system parameters
                this.bioNeuronCount = parseInt(document.getElementById('bio-neurons').value);
                this.snnNeuronCount = parseInt(document.getElementById('snn-neurons').value);
                this.firingThreshold = parseInt(document.getElementById('firing-threshold').value);
                
                // Learning parameters
                this.learningRate = parseFloat(document.getElementById('learning-rate').value);
                this.discountFactor = parseFloat(document.getElementById('discount-factor').value);
                this.explorationRate = parseFloat(document.getElementById('exploration-rate').value);
                
                // Genetic modification parameters
                this.geneModInterval = parseInt(document.getElementById('gene-mod-interval').value);
                this.modStrength = parseFloat(document.getElementById('mod-strength').value);
                
                // Quantum parameters
                this.quantumInfluence = parseFloat(document.getElementById('quantum-influence').value);
                
                // Time parameters
                this.dt = 0.01; // Time step for simulation
                this.timeConstants = {
                    tau: 20, // Membrane time constant (ms)
                    R: 1.0   // Membrane resistance
                };
            }
            
            initializeGRN() {
                // Initialize gene regulatory network
                this.geneExpressionLevels = new Array(this.numGenes).fill(0).map(() => Math.random());
                this.targetExpressionLevels = new Array(this.numGenes).fill(0).map(() => 0.5 + 0.3 * (Math.random() - 0.5));
                
                // Generate interaction matrix for gene regulation
                this.interactionMatrix = Array(this.numGenes).fill().map(() => 
                    Array(this.numGenes).fill().map(() => 
                        (Math.random() < 0.3) ? this.interactionStrength * (Math.random() * 2 - 1) : 0
                    )
                );
                
                this.logMessage(`GRN initialized with ${this.numGenes} genes`);
            }
            
            initializeBioNeurons() {
                // Initialize biological neurons (leaky integrate-and-fire)
                this.bioNeurons = Array(this.bioNeuronCount).fill().map(() => ({
                    V: -70, // Membrane potential (mV)
                    refractory: 0, // Refractory period counter
                    lastSpike: -1000, // Time of last spike
                    spikeHistory: [], // Recent spike times
                    threshold: this.firingThreshold,
                    tau: this.timeConstants.tau * (0.8 + 0.4 * Math.random()), // Randomize time constants
                    weights: Array(this.numGenes).fill().map(() => Math.random() * 2 - 1) // Input weights
                }));
                
                this.logMessage(`Biological neural network initialized with ${this.bioNeuronCount} neurons`);
            }
            
            initializeNeuromorphicChip() {
                // Initialize neuromorphic chip (spiking neural network)
                this.snnLayers = [
                    this.bioNeuronCount, // Input layer size matches bio neurons
                    Math.floor(this.snnNeuronCount * 0.6), // Hidden layer
                    Math.floor(this.snnNeuronCount * 0.4), // Hidden layer
                    this.numGenes // Output layer size matches number of genes/actions
                ];
                
                // Create neurons for each layer
                this.snnNeurons = [];
                for (let layer = 0; layer < this.snnLayers.length; layer++) {
                    const layerNeurons = Array(this.snnLayers[layer]).fill().map(() => ({
                        potential: 0,
                        threshold: -50 + 10 * Math.random(),
                        lastSpike: -1000,
                        spikeCount: 0,
                        tau: 10 + 10 * Math.random()
                    }));
                    this.snnNeurons.push(layerNeurons);
                }
                
                // Create weights between layers
                this.snnWeights = [];
                for (let layer = 0; layer < this.snnLayers.length - 1; layer++) {
                    const layerWeights = Array(this.snnLayers[layer]).fill().map(() => 
                        Array(this.snnLayers[layer + 1]).fill().map(() => 
                            (Math.random() * 2 - 1) * 0.1
                        )
                    );
                    this.snnWeights.push(layerWeights);
                }
                
                this.logMessage(`Neuromorphic chip initialized with ${this.snnNeuronCount} neurons`);
            }
            
            initializeQuantumProcessor() {
                // Simulate a quantum processor for enhanced randomness/decisions
                this.qubits = 5;
                this.quantumCircuit = {
                    // Simplified quantum state representation
                    state: Array(Math.pow(2, this.qubits)).fill(0),
                    
                    // Initialize to uniform superposition
                    initialize: () => {
                        const normFactor = 1 / Math.sqrt(Math.pow(2, this.qubits));
                        this.quantumCircuit.state = this.quantumCircuit.state.map(() => normFactor);
                    },
                    
                    // Apply random unitary gates (simplified)
                    applyGates: () => {
                        // Apply random phase shifts
                        this.quantumCircuit.state = this.quantumCircuit.state.map(amp => {
                            const phase = Math.random() * 2 * Math.PI;
                            return { real: amp * Math.cos(phase), imag: amp * Math.sin(phase) };
                        });
                        
                        // Normalize
                        const sum = Math.sqrt(this.quantumCircuit.state.reduce((sum, val) => 
                            sum + val.real * val.real + val.imag * val.imag, 0));
                            
                        this.quantumCircuit.state = this.quantumCircuit.state.map(val => ({
                            real: val.real / sum,
                            imag: val.imag / sum
                        }));
                    },
                    
                    // Measure to get a classical result
                    measure: () => {
                        const probabilities = this.quantumCircuit.state.map(val => 
                            val.real * val.real + val.imag * val.imag);
                            
                        // Convert to cumulative probabilities
                        const cumulative = [];
                        let sum = 0;
                        for (const p of probabilities) {
                            sum += p;
                            cumulative.push(sum);
                        }
                        
                        // Random sampling
                        const r = Math.random();
                        for (let i = 0; i < cumulative.length; i++) {
                            if (r <= cumulative[i]) return i;
                        }
                        return cumulative.length - 1;
                    }
                };
                
                // Initialize quantum circuit
                this.quantumCircuit.initialize();
                
                this.logMessage("Quantum processor simulation initialized");
            }
            
            initializeReinforcementLearning() {
                // Initialize PPO-based reinforcement learning
                this.rl = {
                    buffer: [], // Experience replay buffer
                    bufferSize: 1000,
                    batchSize: 64,
                    policy: {
                        // Neural network weights (simplified)
                        // This will be influenced by the SNN output
                        weights: Array(this.numGenes).fill().map(() => Math.random() * 0.1)
                    },
                    valueFunction: {
                        // Simple linear value function for simplicity
                        weights: Array(this.numGenes).fill().map(() => Math.random() * 0.1),
                        bias: 0
                    },
                    
                    // Update policy using PPO (simplified)
                    updatePolicy: (states, actions, rewards, nextStates) => {
                        // Calculate advantages (simplified)
                        const values = states.map(state => this.estimateValue(state));
                        const nextValues = nextStates.map(state => this.estimateValue(state));
                        
                        const advantages = rewards.map((r, i) => 
                            r + this.discountFactor * nextValues[i] - values[i]);
                            
                        // Update policy weights (simplified PPO update)
                        for (let i = 0; i < this.rl.policy.weights.length; i++) {
                            let weightUpdate = 0;
                            for (let j = 0; j < states.length; j++) {
                                weightUpdate += advantages[j] * actions[j][i] * states[j][i];
                            }
                            this.rl.policy.weights[i] += this.learningRate * weightUpdate / states.length;
                        }
                        
                        // Update value function
                        for (let i = 0; i < this.rl.valueFunction.weights.length; i++) {
                            let weightUpdate = 0;
                            for (let j = 0; j < states.length; j++) {
                                const tdError = rewards[j] + this.discountFactor * nextValues[j] - values[j];
                                weightUpdate += tdError * states[j][i];
                            }
                            this.rl.valueFunction.weights[i] += this.learningRate * weightUpdate / states.length;
                        }
                    },
                    
                    // Store experience in buffer
                    storeExperience: (state, action, reward, nextState) => {
                        this.rl.buffer.push({ state, action, reward, nextState });
                        if (this.rl.buffer.length > this.rl.bufferSize) {
                            this.rl.buffer.shift();
                        }
                    },
                    
                    // Sample batch from buffer
                    sampleBatch: () => {
                        if (this.rl.buffer.length < this.rl.batchSize) return null;
                        
                        const batch = [];
                        for (let i = 0; i < this.rl.batchSize; i++) {
                            const idx = Math.floor(Math.random() * this.rl.buffer.length);
                            batch.push(this.rl.buffer[idx]);
                        }
                        
                        return {
                            states: batch.map(exp => exp.state),
                            actions: batch.map(exp => exp.action),
                            rewards: batch.map(exp => exp.reward),
                            nextStates: batch.map(exp => exp.nextState)
                        };
                    }
                };
                
                this.logMessage("Reinforcement learning system initialized");
            }
            
            // Estimate value of a state
            estimateValue(state) {
                return state.reduce((sum, val, idx) => 
                    sum + val * this.rl.valueFunction.weights[idx], 0) 
                    + this.rl.valueFunction.bias;
            }
            
            // Update gene expression levels based on ODEs
            updateGRN(actions) {
                const newLevels = [...this.geneExpressionLevels];
                
                // Apply gene regulatory network dynamics
                for (let i = 0; i < this.numGenes; i++) {
                    // Calculate regulation term
                    let regulation = 0;
                    for (let j = 0; j < this.numGenes; j++) {
                        regulation += this.interactionMatrix[j][i] * this.geneExpressionLevels[j];
                    }
                    
                    // Hill function-like nonlinearity
                    const hillCoefficient = 2;
                    const activationLevel = 1 / (1 + Math.exp(-hillCoefficient * regulation));
                    
                    // Update using ODE (dx/dt = f(x) + u)
                    const change = (activationLevel - this.geneExpressionLevels[i]) + actions[i];
                    newLevels[i] += this.dt * change;
                    
                    // Add noise
                    newLevels[i] += this.envNoise * (Math.random() * 2 - 1) * this.dt;
                    
                    // Clamp values
                    newLevels[i] = Math.max(0, Math.min(1, newLevels[i]));
                }
                
                this.geneExpressionLevels = newLevels;
            }
            
            // Calculate reward based on distance to target state
            calculateReward() {
                let sumSquaredError = 0;
                for (let i = 0; i < this.numGenes; i++) {
                    sumSquaredError += Math.pow(this.geneExpressionLevels[i] - this.targetExpressionLevels[i], 2);
                }
                
                // Negative of mean squared error
                const reward = -sumSquaredError / this.numGenes;
                return reward;
            }
            
            // Run biological neurons for one step
            runBioNeurons() {
                const spikes = Array(this.bioNeuronCount).fill(0);
                
                // Update each neuron
                for (let i = 0; i < this.bioNeuronCount; i++) {
                    const neuron = this.bioNeurons[i];
                    
                    // Skip if in refractory period
                    if (neuron.refractory > 0) {
                        neuron.refractory--;
                        continue;
                    }
                    
                    // Calculate input current based on gene expression
                    let I = 0;
                    for (let j = 0; j < this.numGenes; j++) {
                        I += neuron.weights[j] * this.geneExpressionLevels[j];
                    }
                    
                    // Update membrane potential using leaky integrate-and-fire model
                    const dv = (-neuron.V + neuron.threshold + I * this.timeConstants.R) / neuron.tau;
                    neuron.V += dv * this.dt * 1000; // Convert to ms
                    
                    // Check for spike
                    if (neuron.V >= neuron.threshold) {
                        spikes[i] = 1;
                        neuron.lastSpike = this.stepCount;
                        neuron.spikeHistory.push(this.stepCount);
                        if (neuron.spikeHistory.length > 20) neuron.spikeHistory.shift();
                        
                        // Reset and refractory period
                        neuron.V = -70; // Reset potential
                        neuron.refractory = 20; // 20 ms refractory period
                    }
                    
                    // Add noise
                    neuron.V += 0.1 * (Math.random() * 2 - 1);
                }
                
                return spikes;
            }
            
            // Process spikes through the neuromorphic chip
            runNeuromorphicChip(inputSpikes) {
                // Convert spikes to layer activations
                let layerActivations = inputSpikes.map(spike => spike * 10); // Scale up spike effect
                
                // Process through each layer
                for (let layer = 0; layer < this.snnLayers.length - 1; layer++) {
                    const nextLayerActivations = Array(this.snnLayers[layer + 1]).fill(0);
                    
                    // Process each neuron in current layer
                    for (let i = 0; i < this.snnLayers[layer]; i++) {
                        if (layerActivations[i] > 0) {
                            // Propagate to next layer
                            for (let j = 0; j < this.snnLayers[layer + 1]; j++) {
                                nextLayerActivations[j] += layerActivations[i] * this.snnWeights[layer][i][j];
                            }
                        }
                    }
                    
                    // Apply activation function to next layer
                    layerActivations = nextLayerActivations.map(a => {
                        // Simplified spiking process
                        const neuronIdx = this.snnLayers.slice(0, layer + 1).reduce((sum, size) => sum + size, 0);
                        const spikeProb = 1 / (1 + Math.exp(-a + 3)); // Logistic function
                        return Math.random() < spikeProb ? 1 : 0;
                    });
                }
                
                // Convert final layer activation to control actions
                const actions = Array(this.numGenes).fill(0);
                for (let i = 0; i < this.numGenes; i++) {
                    // Combine output neuron activity
                    actions[i] = layerActivations[i] * 0.1; // Scale down
                    
                    // Apply policy influence
                    actions[i] += this.rl.policy.weights[i] * 0.2;
                    
                    // Apply quantum influence
                    if (Math.random() < this.quantumInfluence) {
                        this.quantumCircuit.applyGates();
                        const qResult = this.quantumCircuit.measure();
                        const qInfluence = (qResult / Math.pow(2, this.qubits) - 0.5) * 0.2;
                        actions[i] += qInfluence;
                    }
                    
                    // Add exploration
                    if (Math.random() < this.explorationRate) {
                        actions[i] += (Math.random() * 2 - 1) * 0.2;
                    }
                    
                    // Clamp values
                    actions[i] = Math.max(-0.1, Math.min(0.1, actions[i]));
                }
                
                return actions;
            }
            
            // Apply genetic modifications to biological neurons
            applyGeneticModification() {
                // Evaluate performance
                const recentRewards = this.rewardHistory.slice(-50);
                const avgReward = recentRewards.reduce((sum, r) => sum + r, 0) / recentRewards.length;
                
                // Select neurons to modify (e.g., 10%)
                const numToModify = Math.ceil(this.bioNeuronCount * 0.1);
                const neuronIndices = Array(this.bioNeuronCount).fill().map((_, i) => i);
                
                // Shuffle and take first numToModify
                for (let i = neuronIndices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [neuronIndices[i], neuronIndices[j]] = [neuronIndices[j], neuronIndices[i]];
                }
                
                const toModify = neuronIndices.slice(0, numToModify);
                
                // Apply modifications
                for (const idx of toModify) {
                    const neuron = this.bioNeurons[idx];
                    
                    // Modify threshold
                    neuron.threshold += this.modStrength * (Math.random() * 2 - 1) * 10;
                    neuron.threshold = Math.max(-70, Math.min(-30, neuron.threshold));
                    
                    // Modify time constant
                    neuron.tau *= 1 + this.modStrength * (Math.random() * 2 - 1) * 0.2;
                    neuron.tau = Math.max(10, Math.min(50, neuron.tau));
                    
                    // Modify weights
                    for (let i = 0; i < neuron.weights.length; i++) {
                        neuron.weights[i] *= 1 + this.modStrength * (Math.random() * 2 - 1) * 0.3;
                    }
                }
                
                this.logMessage(`Applied genetic modification to ${numToModify} neurons`);
            }
            
            // One simulation step
            simulationStep() {
                // Run biological neurons
                const bioSpikes = this.runBioNeurons();
                
                // Process through neuromorphic chip
                const actions = this.runNeuromorphicChip(bioSpikes);
                
                // Store current state
                const currentState = [...this.geneExpressionLevels];
                
                // Update GRN with actions
                this.updateGRN(actions);
                
                // Calculate reward
                const reward = this.calculateReward();
                this.rewardHistory.push(reward);
                if (this.rewardHistory.length > 1000) this.rewardHistory.shift();
                
                // Store experience
                this.rl.storeExperience(currentState, actions, reward, [...this.geneExpressionLevels]);
                
                // Occasionally update policy
                if (this.stepCount % 20 === 0) {
                    const batch = this.rl.sampleBatch();
                    if (batch) {
                        this.rl.updatePolicy(batch.states, batch.actions, batch.rewards, batch.nextStates);
                    }
                }
                
                // Apply genetic modification if interval is reached
                if (this.episodeCount % this.geneModInterval === 0 && this.stepCount === 0) {
                    this.applyGeneticModification();
                }
                
                // Update counters
                this.stepCount++;
                
                // Check if episode should end
                if (this.stepCount >= 100) {
                    this.episodeCount++;
                    this.stepCount = 0;
                    
                    // Reset gene expression to random initial values for next episode
                    this.geneExpressionLevels = new Array(this.numGenes).fill(0).map(() => Math.random());
                    
                    // Log progress
                    if (this.episodeCount % 10 === 0) {
                        const lastRewards = this.rewardHistory.slice(-100);
                        const avgReward = lastRewards.reduce((sum, r) => sum + r, 0) / lastRewards.length;
                        this.logMessage(`Episode ${this.episodeCount}: Average reward = ${avgReward.toFixed(4)}`);
                    }
                }
                
                // Update UI
                this.updateUI();
            }
            
            // Start simulation
            start() {
                if (!this.running) {
                    this.running = true;
                    this.simInterval = setInterval(() => this.simulationStep(), 50);
                    this.logMessage("Simulation started");
                }
            }
            
            // Pause simulation
            pause() {
                if (this.running) {
                    this.running = false;
                    clearInterval(this.simInterval);
                    this.logMessage("Simulation paused");
                }
            }
            
            // Reset simulation
            reset() {
                this.pause();
                this.initializeParameters();
                this.initializeGRN();
                this.initializeBioNeurons();
                this.initializeNeuromorphicChip();
                this.initializeQuantumProcessor();
                this.initializeReinforcementLearning();
                
                this.episodeCount = 0;
                this.stepCount = 0;
                this.rewardHistory = [];
                
                this.updateUI();
                this.logMessage("Simulation reset");
            }
            
            // Add a log message
            logMessage(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.logs.unshift({ time: timestamp, message });
                if (this.logs.length > 50) this.logs.pop();
                
                // Update log display
                const logContainer = document.getElementById('log-container');
                logContainer.innerHTML = this.logs.map(log => 
                    `<div class="log-entry">[${log.time}] ${log.message}</div>`
                ).join('');
            }
            
            // Setup UI handlers
            setupUIHandlers() {
                // Button handlers
                document.getElementById('start-btn').addEventListener('click', () => this.start());
                document.getElementById('pause-btn').addEventListener('click', () => this.pause());
                document.getElementById('reset-btn').addEventListener('click', () => this.reset());
                document.getElementById('apply-gene-mod').addEventListener('click', () => this.applyGeneticModification());
                document.getElementById('quantum-enhance').addEventListener('click', () => {
                    this.quantumInfluence = Math.min(1.0, this.quantumInfluence + 0.2);
                    document.getElementById('quantum-influence').value = this.quantumInfluence;
                    document.getElementById('quantum-influence-value').textContent = this.quantumInfluence.toFixed(1);
                    this.logMessage("Applied quantum enhancement");
                });
                
                // Slider handlers - update displayed values
                const sliders = [
                    'num-genes', 'interaction-strength', 'env-noise',
                    'bio-neurons', 'snn-neurons', 'firing-threshold',
                    'learning-rate', 'discount-factor', 'exploration-rate',
                    'gene-mod-interval', 'mod-strength', 'quantum-influence'
                ];
                
                for (const slider of sliders) {
                    document.getElementById(slider).addEventListener('input', (e) => {
                        document.getElementById(`${slider}-value`).textContent = e.target.value;
                    });
                }
                
                // Tab handlers
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        // Deactivate all tabs
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        
                        // Activate selected tab
                        tab.classList.add('active');
                        const tabId = `${tab.dataset.tab}-tab`;
                        document.getElementById(tabId).classList.add('active');
                    });
                });
            }
            
            // Setup visualization canvases
            setupVisualization() {
                // Setup GRN canvas
                this.grnCanvas = document.getElementById('grn-canvas');
                this.grnCtx = this.grnCanvas.getContext('2d');
                
                // Setup Neurons canvas
                this.neuronsCanvas = document.getElementById('neurons-canvas');
                this.neuronsCtx = this.neuronsCanvas.getContext('2d');
                
                // Setup Learning canvas
                this.learningCanvas = document.getElementById('learning-canvas');
                this.learningCtx = this.learningCanvas.getContext('2d');
                
                // Setup Spike monitor
                this.spikeCanvas = document.getElementById('spike-monitor');
                this.spikeCtx = this.spikeCanvas.getContext('2d');
                
                // Setup Reward chart
                this.rewardCanvas = document.getElementById('reward-chart');
                this.rewardCtx = this.rewardCanvas.getContext('2d');
            }
            
            // Update UI elements
            updateUI() {
                // Update statistics
                document.getElementById('episode-count').textContent = this.episodeCount;
                
                const currentReward = this.rewardHistory.length > 0 ? 
                    this.rewardHistory[this.rewardHistory.length - 1] : 0;
                document.getElementById('current-reward').textContent = currentReward.toFixed(4);
                
                const avgReward = this.rewardHistory.length > 0 ? 
                    this.rewardHistory.reduce((sum, r) => sum + r, 0) / this.rewardHistory.length : 0;
                document.getElementById('avg-reward').textContent = avgReward.toFixed(4);
                
                let sumSquaredError = 0;
                for (let i = 0; i < this.numGenes; i++) {
                    sumSquaredError += Math.pow(this.geneExpressionLevels[i] - this.targetExpressionLevels[i], 2);
                }
                const mse = sumSquaredError / this.numGenes;
                document.getElementById('error-value').textContent = mse.toFixed(4);
                
                // Update GRN state display
                const grnDisplay = document.getElementById('grn-state-display');
                grnDisplay.innerHTML = `<div style="display:flex;height:30px;width:100%;">
                    ${this.geneExpressionLevels.map((level, i) => {
                        const target = this.targetExpressionLevels[i];
                        return `<div style="flex:1;position:relative;margin:0 2px;height:100%;">
                            <div style="position:absolute;bottom:0;width:100%;height:${level*100}%;background-color:#7CB9E8;"></div>
                            <div style="position:absolute;bottom:${target*100}%;width:100%;height:2px;background-color:#FF5555;"></div>
                        </div>`;
                    }).join('')}
                </div>`;
                
                // Draw GRN visualization
                this.drawGRNVisualization();
                
                // Draw neural activity
                this.drawNeuralActivity();
                
                // Draw learning progress
                this.drawLearningProgress();
                
                // Draw spike monitor
                this.drawSpikeMonitor();
                
                // Draw reward chart
                this.drawRewardChart();
            }
            
            // Draw GRN visualization
            drawGRNVisualization() {
                const ctx = this.grnCtx;
                const canvas = this.grnCanvas;
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Set background
                ctx.fillStyle = '#111122';
                ctx.fillRect(0, 0, width, height);
                
                // Draw genes as nodes in a circle
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.35;
                
                // Draw interactions first
                for (let i = 0; i < this.numGenes; i++) {
                    const angle1 = (i / this.numGenes) * 2 * Math.PI;
                    const x1 = centerX + radius * Math.cos(angle1);
                    const y1 = centerY + radius * Math.sin(angle1);
                    
                    for (let j = 0; j < this.numGenes; j++) {
                        const weight = this.interactionMatrix[i][j];
                        if (Math.abs(weight) > 0.05) {
                            const angle2 = (j / this.numGenes) * 2 * Math.PI;
                            const x2 = centerX + radius * Math.cos(angle2);
                            const y2 = centerY + radius * Math.sin(angle2);
                            
                            // Draw arrow
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            
                            // Control points for curved lines
                            const midX = (x1 + x2) / 2;
                            const midY = (y1 + y2) / 2;
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Curve away from center
                            const curveOffset = dist * 0.2;
                            const cx = midX + curveOffset * (midY - centerY) / dist;
                            const cy = midY - curveOffset * (midX - centerX) / dist;
                            
                            ctx.quadraticCurveTo(cx, cy, x2, y2);
                            
                            // Color based on interaction type
                            ctx.strokeStyle = weight > 0 ? 
                                `rgba(100, 255, 100, ${Math.min(1, Math.abs(weight) * 2)})` : 
                                `rgba(255, 100, 100, ${Math.min(1, Math.abs(weight) * 2)})`;
                            ctx.lineWidth = Math.abs(weight) * 3;
                            ctx.stroke();
                            
                            // Draw arrowhead
                            const arrowSize = 5 + Math.abs(weight) * 3;
                            const angle = Math.atan2(y2 - cy, x2 - cx);
                            ctx.beginPath();
                            ctx.moveTo(x2, y2);
                            ctx.lineTo(
                                x2 - arrowSize * Math.cos(angle - Math.PI/6),
                                y2 - arrowSize * Math.sin(angle - Math.PI/6)
                            );
                            ctx.lineTo(
                                x2 - arrowSize * Math.cos(angle + Math.PI/6),
                                y2 - arrowSize * Math.sin(angle + Math.PI/6)
                            );
                            ctx.closePath();
                            ctx.fillStyle = weight > 0 ? 
                                `rgba(100, 255, 100, ${Math.min(1, Math.abs(weight) * 2)})` : 
                                `rgba(255, 100, 100, ${Math.min(1, Math.abs(weight) * 2)})`;
                            ctx.fill();
                        }
                    }
                }
                
                // Draw gene nodes
                for (let i = 0; i < this.numGenes; i++) {
                    const angle = (i / this.numGenes) * 2 * Math.PI;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    // Draw node
                    const nodeSize = 15 + this.geneExpressionLevels[i] * 10;
                    ctx.beginPath();
                    ctx.arc(x, y, nodeSize, 0, 2 * Math.PI);
                    
                    // Fill based on expression level
                    const r = Math.floor(50 + this.geneExpressionLevels[i] * 205);
                    const g = Math.floor(100 + this.geneExpressionLevels[i] * 155);
                    const b = Math.floor(200 + this.geneExpressionLevels[i] * 55);
                    
                    // Indicate target level with border
                    const targetLevel = this.targetExpressionLevels[i];
                    const error = Math.abs(this.geneExpressionLevels[i] - targetLevel);
                    const borderWidth = 2 + error * 4;
                    
                    // Fill node
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fill();
                    
                    // Draw border
                    ctx.lineWidth = borderWidth;
                    ctx.strokeStyle = error < 0.1 ? 'rgba(100, 255, 100, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                    ctx.stroke();
                    
                    // Draw target indicator
                    const targetAngle = 0;
                    const targetAngleEnd = 2 * Math.PI * targetLevel;
                    ctx.beginPath();
                    ctx.arc(x, y, nodeSize + 5, targetAngle, targetAngleEnd);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#FF5555';
                    ctx.stroke();
                    
                    // Draw gene label
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`G${i+1}`, x, y);
                }
            }
            
            // Draw neural activity visualization
            drawNeuralActivity() {
                const ctx = this.neuronsCtx;
                const canvas = this.neuronsCanvas;
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#111122';
                ctx.fillRect(0, 0, width, height);
                
                // Draw biological neurons (left side)
                const bioWidth = width * 0.3;
                const snnWidth = width - bioWidth;
                
                // Draw bio neurons
                const bioNeuronSize = Math.min(8, bioWidth / 10);
                const bioRows = Math.ceil(Math.sqrt(this.bioNeuronCount));
                const bioCols = Math.ceil(this.bioNeuronCount / bioRows);
                
                for (let i = 0; i < this.bioNeuronCount; i++) {
                    const row = Math.floor(i / bioCols);
                    const col = i % bioCols;
                    
                    const x = col * (bioWidth / bioCols) + bioWidth / (2 * bioCols);
                    const y = row * (height / bioRows) + height / (2 * bioRows);
                    
                    const neuron = this.bioNeurons[i];
                    
                    // Calculate activity level (normalized membrane potential)
                    const activity = (neuron.V - (-70)) / (neuron.threshold - (-70));
                    
                    // Draw neuron
                    ctx.beginPath();
                    ctx.arc(x, y, bioNeuronSize, 0, 2 * Math.PI);
                    
                    // Color based on activity
                    const r = Math.floor(100 + activity * 155);
                    const g = Math.floor(100 + activity * 155);
                    const b = Math.floor(255);
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fill();
                    
                    // Draw border if recently spiked
                    const timeSinceLastSpike = this.stepCount - neuron.lastSpike;
                    if (timeSinceLastSpike < 5) {
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = 'rgba(255, 255, 0, ' + (1 - timeSinceLastSpike/5) + ')';
                        ctx.stroke();
                    }
                }
                
                // Draw SNN (right side)
                const startX = bioWidth;
                const layerWidth = snnWidth / this.snnLayers.length;
                
                // Draw connections between layers
                for (let layer = 0; layer < this.snnLayers.length - 1; layer++) {
                    const layerX = startX + layer * layerWidth + layerWidth/2;
                    const nextLayerX = startX + (layer + 1) * layerWidth + layerWidth/2;
                    
                    for (let i = 0; i < this.snnLayers[layer]; i++) {
                        const y1 = (i + 0.5) * height / this.snnLayers[layer];
                        
                        for (let j = 0; j < this.snnLayers[layer + 1]; j++) {
                            const y2 = (j + 0.5) * height / this.snnLayers[layer + 1];
                            
                            // Only draw strong connections
                            const weight = this.snnWeights[layer][i][j];
                            if (Math.abs(weight) > 0.05) {
                                ctx.beginPath();
                                ctx.moveTo(layerX, y1);
                                ctx.lineTo(nextLayerX, y2);
                                
                                ctx.strokeStyle = weight > 0 ? 
                                    `rgba(100, 200, 255, ${Math.min(1, Math.abs(weight) * 5)})` : 
                                    `rgba(255, 100, 100, ${Math.min(1, Math.abs(weight) * 5)})`;
                                ctx.lineWidth = Math.abs(weight) * 2;
                                ctx.stroke();
                            }
                        }
                    }
                }
                
                // Draw layer neurons
                for (let layer = 0; layer < this.snnLayers.length; layer++) {
                    const layerX = startX + layer * layerWidth + layerWidth/2;
                    
                    for (let i = 0; i < this.snnLayers[layer]; i++) {
                        const y = (i + 0.5) * height / this.snnLayers[layer];
                        
                        // Draw neuron
                        const neuronSize = 3;
                        ctx.beginPath();
                        ctx.arc(layerX, y, neuronSize, 0, 2 * Math.PI);
                        
                        // Color based on layer
                        if (layer === 0) {
                            ctx.fillStyle = 'rgb(100, 200, 255)'; // Input layer
                        } else if (layer === this.snnLayers.length - 1) {
                            ctx.fillStyle = 'rgb(255, 200, 100)'; // Output layer
                        } else {
                            ctx.fillStyle = 'rgb(200, 200, 255)'; // Hidden layer
                        }
                        
                        ctx.fill();
                    }
                }
                
                // Draw layer labels
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                
                ctx.fillText('Biological', bioWidth / 2, 15);
                ctx.fillText('Neurons', bioWidth / 2, 30);
                
                ctx.fillText('Input', startX + layerWidth/2, 15);
                ctx.fillText('Layer', startX + layerWidth/2, 30);
                
                ctx.fillText('Hidden', startX + 2*layerWidth/2 + layerWidth/2, 15);
                ctx.fillText('Layer 1', startX + 2*layerWidth/2 + layerWidth/2, 30);
                
                ctx.fillText('Hidden', startX + 3*layerWidth/2 + layerWidth/2, 15);
                ctx.fillText('Layer 2', startX + 3*layerWidth/2 + layerWidth/2, 30);
                
                ctx.fillText('Output', startX + 4*layerWidth/2 + layerWidth/2, 15);
                ctx.fillText('Layer', startX + 4*layerWidth/2 + layerWidth/2, 30);
                
                // Draw quantum processor influence
                if (this.quantumInfluence > 0.1) {
                    ctx.fillStyle = `rgba(255, 0, 255, ${this.quantumInfluence * 0.5})`;
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Quantum Influence Active', width / 2, height - 15);
                }
            }
            
            // Draw learning progress visualization
            drawLearningProgress() {
                const ctx = this.learningCtx;
                const canvas = this.learningCanvas;
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#111122';
                ctx.fillRect(0, 0, width, height);
                
                // Draw policy visualization
                const barWidth = width / (this.numGenes * 2);
                const valueOffset = width / 2;
                
                // Draw axes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(width / 2, 0);
                ctx.lineTo(width / 2, height);
                ctx.stroke();
                
                // Draw policy weights
                ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                for (let i = 0; i < this.numGenes; i++) {
                    const x = i * barWidth * 2 + barWidth / 2;
                    const weight = this.rl.policy.weights[i];
                    const barHeight = Math.abs(weight) * height / 2;
                    
                    ctx.fillRect(
                        x, 
                        weight > 0 ? height / 2 - barHeight : height / 2,
                        barWidth,
                        barHeight
                    );
                }
                
                // Draw value function weights
                ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
                for (let i = 0; i < this.numGenes; i++) {
                    const x = valueOffset + i * barWidth * 2 + barWidth / 2;
                    const weight = this.rl.valueFunction.weights[i];
                    const barHeight = Math.abs(weight) * height / 2;
                    
                    ctx.fillRect(
                        x, 
                        weight > 0 ? height / 2 - barHeight : height / 2,
                        barWidth,
                        barHeight
                    );
                }
                
                // Draw labels
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                
                ctx.fillText('Policy Weights', width / 4, 20);
                ctx.fillText('Value Function Weights', 3 * width / 4, 20);
                
                // Legend for genetic modification
                if (this.episodeCount % this.geneModInterval === 0) {
                    ctx.fillStyle = 'rgba(255, 100, 200, 0.8)';
                    ctx.fillText('Genetic Modification Active', width / 2, height - 20);
                }
            }
            
            // Draw spike monitor
            drawSpikeMonitor() {
                const ctx = this.spikeCtx;
                const canvas = this.spikeCanvas;
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#111122';
                ctx.fillRect(0, 0, width, height);
                
                // Draw spike raster
                const timeWindow = 100; // Show last 100 steps
                const neuronHeight = height / Math.min(20, this.bioNeuronCount);
                
                // Sample neurons to display (max 20)
                const sampleSize = Math.min(20, this.bioNeuronCount);
                const sampleInterval = this.bioNeuronCount / sampleSize;
                
                for (let i = 0; i < sampleSize; i++) {
                    const neuronIdx = Math.floor(i * sampleInterval);
                    const neuron = this.bioNeurons[neuronIdx];
                    const y = i * neuronHeight + neuronHeight / 2;
                    
                    // Draw label
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`N${neuronIdx+1}`, 5, y + 3);
                    
                    // Draw spikes
                    for (const spikeTime of neuron.spikeHistory) {
                        if (this.stepCount - spikeTime < timeWindow) {
                            const x = width - (this.stepCount - spikeTime) * (width / timeWindow);
                            const spikeHeight = neuronHeight * 0.8;
                            
                            ctx.beginPath();
                            ctx.moveTo(x, y - spikeHeight / 2);
                            ctx.lineTo(x, y + spikeHeight / 2);
                            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw time axis
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height - 5);
                ctx.lineTo(width, height - 5);
                ctx.stroke();
                
                // Time markers
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                
                for (let t = 0; t <= 100; t += 20) {
                    const x = width - t * (width / timeWindow);
                    ctx.beginPath();
                    ctx.moveTo(x, height - 5);
                    ctx.lineTo(x, height - 10);
                    ctx.stroke();
                    
                    ctx.fillText(`-${t}`, x, height - 12);
                }
            }
            
            // Draw reward chart
            drawRewardChart() {
                const ctx = this.rewardCtx;
                const canvas = this.rewardCanvas;
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#111122';
                ctx.fillRect(0, 0, width, height);
                
                // Draw axes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(0, height - 20);
                ctx.lineTo(width, height - 20);
                ctx.stroke();
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(40, 10);
                ctx.lineTo(40, height - 10);
                ctx.stroke();
                
                // Draw reward history
                if (this.rewardHistory.length > 1) {
                    const historyToShow = this.rewardHistory.slice(-100);
                    const minReward = Math.min(...historyToShow, -0.5);
                    const maxReward = Math.max(...historyToShow, 0);
                    const range = maxReward - minReward;
                    
                    const pointWidth = (width - 50) / historyToShow.length;
                    
                    // Draw grid lines
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    
                    for (let r = 0; r <= 1; r += 0.25) {
                        const y = 10 + (height - 30) * (1 - r);
                        ctx.beginPath();
                        ctx.moveTo(40, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                        
                        const rewardValue = minReward + range * r;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'right';
                        ctx.fillText(rewardValue.toFixed(2), 35, y + 3);
                    }
                    
                    // Draw line graph
                    ctx.beginPath();
                    ctx.moveTo(40, height - 20 - (historyToShow[0] - minReward) / range * (height - 30));
                    
                    for (let i = 1; i < historyToShow.length; i++) {
                        const x = 40 + i * pointWidth;
                        const y = height - 20 - (historyToShow[i] - minReward) / range * (height - 30);
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.strokeStyle = 'rgba(100, 255, 200, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw moving average
                    const windowSize = 10;
                    if (historyToShow.length > windowSize) {
                        ctx.beginPath();
                        
                        let sum = historyToShow.slice(0, windowSize).reduce((a, b) => a + b, 0);
                        let avg = sum / windowSize;
                        
                        ctx.moveTo(40 + windowSize * pointWidth / 2, height - 20 - (avg - minReward) / range * (height - 30));
                        
                        for (let i = 1; i < historyToShow.length - windowSize + 1; i++) {
                            sum = sum - historyToShow[i - 1] + historyToShow[i + windowSize - 1];
                            avg = sum / windowSize;
                            
                            const x = 40 + (i + windowSize / 2) * pointWidth;
                            const y = height - 20 - (avg - minReward) / range * (height - 30);
                            ctx.lineTo(x, y);
                        }
                        
                        ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    
                    // Draw labels
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Reward History', width / 2, 15);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('Time', width - 30, height - 5);
                    
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.textAlign = 'center';
                    ctx.fillText('Reward', 0, 0);
                    ctx.restore();
                }
            }
        }
        
        // Initialize simulation when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const simulation = new Project1X4GSimulation();
            
            // Update UI on slider changes
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                slider.addEventListener('change', () => {
                    // Update corresponding value in the UI
                    document.getElementById(`${slider.id}-value`).textContent = slider.value;
                });
            });
        });
    </script>
</body>
</html>
```
